A Scala 3 class can be written with or without a braces pair {}.  A Scala 3
class that doesn't use a braces pair {} must use a colon char (:) at the
termination of the class's argument list.  All code following the colon
char (:) must appear below the argument list, and must be indented to the
right of the opening "class" keyword.  This rule applies to all Scala 3 classes
objects,and traits.

A Scala class that contains no body doesn't require a braces pair {} or
a colon char (:), but always requires a parenthesis pair (), even if
the class constructor accepts no arguments.

When a class has an argument list, it's optional to precede each argument
with the "val" keyword, or the "var" keyword, or neither.

When a class argument is preceded with the "val" or "var" keyword, the
argument becomes a public class member by default; so it can be accessed
inside and outside the class.

When a class argument isn't preceded with the "val" or "var" keyword, the
argument becomes a private "val" by default, so it can be accessed only
from within the class, and its value can never be changed.

IMPORTANT: A class can be written to contain val/var members that aren't
           included in the class's argument list!  So don't assume that
           a class's argument list references all of its val/var members.

If a class has no val/var members, or if all instantiations of that class
will always have identical val/var values, then a Scala object should be
used instead of a Scala class.

The following program demonstrates the above-mentioned rules.

class Bozo()                  // A class doesn't require any arguments.
class Book(var title:String)  // Book.title is a public var class member.
class Person(val name:String) // Person.name is a public val class member.
class Movie(name:String):     // Movie.name is a private val class member.
  def printName:Unit = println(name)

/******************
 * main()
 *****************/
@main def main():Unit =
  val bozo = Bozo()
  println(s"bozo = $bozo") // PRINTS: bozo = Bozo@357246de

  val book = Book("Scala 3 for Idiots")
  // Because the Book.title argument has been declared a var, it's a public member,
  // so it can accessed here, outside the Person class.
  println(s"book.title = ${book.title}") // PRINTS: book.title = Scala 3 for Idiots
  // Because the Book.title argument has been declared a var, we can change also
  // change it's value, as shown here...
  book.title = "Scala 3 for Geniuses"
  println(s"book.title = ${book.title}") // PRINTS: book.title = Scala 3 for Geniuses

  val person = Person("Tom")
  // Because the Person.name argument has been declared a val, it's a public member,
  // so it can be accessed here, outside the Person class.
  println(s"person.name = ${person.name}") // PRINTS: person.name = Tom

  val movie = Movie("When Galaxies Collide")
  // Because the Movie.name argument isn't preceded with the "val" or
  // "var" keyword, it becomes a private class member by default.  So
  // Movie.name can be accessed only from within the Movie class.
  print("movie.name = "); movie.printName // PRINTS: movie.name = When Galaxies Collide

============================================================================

DEFAULT ARGUMENTS
=================
Scala class constructors and Scala methods can be written to accept default arguments.
A default argument is an argument that doesn't need to be specified when the class
constructor, or the method, is invoked.  When a default argument isn't specified,
the code supplies the default value specified in the argument list.  Study the
following self-explanatory program to understand default arguments.

class Socket(val timeout: Int = 5_000, val linger: Int = 5_000):
  override def toString = s"timeout: $timeout, linger: $linger"

/******************
 * main()
 *****************/
@main def main():Unit =
  def defaultArgumentMethod(name:String = "No Name", id:Int = 0):Unit =
    println(s"name = $name,  id = $id")

  val s1 = Socket()
  println(s"s1 = $s1")  // PRINTS: s1 = timeout: 5000, linger: 5000
  val s2 = Socket(2_500)
  println(s"s2 = $s2")  // PRINTS: s2 = timeout: 2500, linger: 5000
  val s3 = Socket(10_000, 10_000)
  println(s"s3 = $s3")  // PRINTS: s3 = timeout: 10000, linger: 10000
  val s4 = Socket(timeout = 10_000)
  println(s"s4 = $s4")  // PRINTS: s4 = timeout: 10000, linger: 5000
  val s5 = Socket(linger = 10_000)
  println(s"s5 = $s5\n")  // PRINTS: s5 = timeout: 5000, linger: 10000

  defaultArgumentMethod() // PRINTS: name = No Name,  id = 0
  defaultArgumentMethod("Joe") // PRINTS: name = Joe,  id = 0
  defaultArgumentMethod(id = -123) // PRINTS: name = No Name,  id = -123
  defaultArgumentMethod(id = 987, name = "Sue") // PRINTS: name = Sue,  id = 987

============================================================================

AUXILIARY CLASS CONSTRUCTORS
============================
Most class definitions are written to have a single constructor, which
is known as the class's Primary Constructor.  However, you can define
a class that contains multiple constructors; so that class can be
instantiated using different argument lists.  These additional
constructors are called Auxiliary Constructors.

IMPORTANT: The first line of code executed by an Auxiliary Constructor
           MUST be a call to "this", which invokes the class's Primary
           Constructor.  So every time an Auxiliary Constructor is
           invoked, the first thing it must do is invoke the class's
           Primary Constructor.

import java.time.*

class Student(name:String, govtId:Int):
  // PRIMARY CONSTRUCTOR ***************************************************
  // Code at this indentation level will get executed once (and
  // only once) every time a new Student class is instantiated;
  // regardless of which constructors are invoked.
  print(s"\nname = $name, govtId = $govtId")

  // AUXILIARY CONSTRUCTOR #1 **********************************************
  def this(name:String, govtId:Int, applicationDate:LocalDate) =
    // The first line executed of an Auxiliary Constructor must invoke
    // the Primary Constructor, which is done by calling: this(name, govtId)
    this(name, govtId) // Invokes the Student class's Primary Constructor.
    print(s", applicationDate = $applicationDate")

  // AUXILIARY CONSTRUCTOR #2 **********************************************
  def this(name:String, govtId:Int, studentId:Int) =
    // The first line executed of an Auxiliary Constructor must invoke
    // the Primary Constructor, which is done by calling: this(name, govtId)
    this(name, govtId) // Invokes the Student class's Primary Constructor.
    print(s", studentId = $studentId")

/******************
 * main()
 *****************/
@main def main() =
  // The following line of code invokes ONLY the Primary Constructor.
  val stud1 = Student("Joe", 111)
  // PRINTS: name = Joe, govtId = 111

  // The following line invokes the Primary Constructor and Auxiliary Constructor #1.
  val stud2 = Student("Jane", 222, LocalDate.now());
  // PRINTS: name = Jane, govtId = 222, applicationDate = 2024-12-06

  // The following line invokes the Primary Constructor and Auxiliary Constructor #2.
  val stud3 = Student("Alice", 333, 444)
  // PRINTS: name = Alice, govtId = 333, studentId = 444
