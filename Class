This web page contains sections that cover following topics.

* Class
* Default Arguments
* Auxiliary Class Constructors
* Case Class


CLASS
=====
A Scala 3 class can be written with or without a braces pair {}.  A Scala 3
class that doesn't use a braces pair {} must use a colon char (:) at the
termination of the class's argument list.  All code following the colon
char (:) must appear on a new line below the argument list, and must be
indented to the right of the opening "class" or "case class" keywords.

Scala 3 objects and traits implement the colon char (:) in this same way.

A Scala class that contains no body doesn't require a braces pair {} or
a colon char (:), but always requires a parenthesis pair (), even if
the class constructor accepts no arguments.

When a class has an argument list, it's optional to precede each argument
with the "val" keyword, or the "var" keyword, or neither.

When a class argument is preceded with the "val" or "var" keyword, the
argument becomes a public class member by default; so it can be accessed
inside and outside the class.

When a class argument isn't preceded with the "val" or "var" keyword, the
argument becomes a private "val" by default, so it can be accessed only
from within the class, and its value can never be changed.

IMPORTANT: A class can be written to contain val/var members that aren't
           included in the class's argument list.  So don't assume that
           a class's argument list references all of its val/var members.

If a class has no val/var members, or if all instantiations of that class
will always have identical val/var values, then a Scala object should be
used instead of a Scala class.

The following program demonstrates the above-mentioned rules.

class Bozo()                  // A class doesn't require any arguments.
class Book(var title:String)  // Book.title is a public var class member.
class Person(val name:String) // Person.name is a public val class member.
class Movie(name:String):     // Movie.name is a private val class member.
  def printName:Unit = println(name)

/******************
 * main()
 *****************/
@main def main():Unit =
  val bozo = Bozo()
  println(s"bozo = $bozo") // PRINTS: bozo = Bozo@357246de

  val book = Book("Scala 3 for Idiots")
  // Because the Book.title argument has been declared a var, it's a public member,
  // so it can accessed here, outside the Person class.
  println(s"book.title = ${book.title}") // PRINTS: book.title = Scala 3 for Idiots
  // Because the Book.title argument has been declared a var, we can change also
  // change it's value, as shown here...
  book.title = "Scala 3 for Geniuses"
  println(s"book.title = ${book.title}") // PRINTS: book.title = Scala 3 for Geniuses

  val person = Person("Tom")
  // Because the Person.name argument has been declared a val, it's a public member,
  // so it can be accessed here, outside the Person class.
  println(s"person.name = ${person.name}") // PRINTS: person.name = Tom

  val movie = Movie("When Galaxies Collide")
  // Because the Movie.name argument isn't preceded with the "val" or
  // "var" keyword, it becomes a private class member by default.  So
  // Movie.name can be accessed only from within the Movie class.
  print("movie.name = "); movie.printName // PRINTS: movie.name = When Galaxies Collide

============================================================================

DEFAULT ARGUMENTS
=================
Scala class constructors and Scala methods can be written to accept default arguments.
A default argument is an argument that doesn't need to be specified when the class
constructor, or the method, is invoked.  When a default argument isn't specified,
the code supplies the default value specified in the argument list.  Study the
following self-explanatory program to understand default arguments.

class Socket(val timeout: Int = 5_000, val linger: Int = 5_000):
  override def toString = s"timeout: $timeout, linger: $linger"

/******************
 * main()
 *****************/
@main def main():Unit =
  def defaultArgumentMethod(name:String = "No Name", id:Int = 0):Unit =
    println(s"name = $name,  id = $id")

  val s1 = Socket()
  println(s"s1 = $s1")  // PRINTS: s1 = timeout: 5000, linger: 5000
  val s2 = Socket(2_500)
  println(s"s2 = $s2")  // PRINTS: s2 = timeout: 2500, linger: 5000
  val s3 = Socket(10_000, 10_000)
  println(s"s3 = $s3")  // PRINTS: s3 = timeout: 10000, linger: 10000
  val s4 = Socket(timeout = 10_000)
  println(s"s4 = $s4")  // PRINTS: s4 = timeout: 10000, linger: 5000
  val s5 = Socket(linger = 10_000)
  println(s"s5 = $s5\n")  // PRINTS: s5 = timeout: 5000, linger: 10000

  defaultArgumentMethod() // PRINTS: name = No Name,  id = 0
  defaultArgumentMethod("Joe") // PRINTS: name = Joe,  id = 0
  defaultArgumentMethod(id = -123) // PRINTS: name = No Name,  id = -123
  defaultArgumentMethod(id = 987, name = "Sue") // PRINTS: name = Sue,  id = 987

============================================================================

AUXILIARY CLASS CONSTRUCTORS
============================
Most class definitions are written to have a single constructor, which
is known as the class's Primary Constructor.  However, you can define
a class that contains multiple constructors; so that class can be
instantiated using different argument lists.  These additional
constructors are called Auxiliary Constructors.

IMPORTANT: The first line of code executed by an Auxiliary Constructor
           MUST be a call to "this", which invokes the class's Primary
           Constructor.  So every time an Auxiliary Constructor is
           invoked, the first thing it must do is invoke the class's
           Primary Constructor.

import java.time.*

class Student(name:String, govtId:Int):
  // PRIMARY CONSTRUCTOR ***************************************************
  // Code at this indentation level will get executed once (and
  // only once) every time a new Student class is instantiated;
  // regardless of which constructors are invoked.
  print(s"\nname = $name, govtId = $govtId")

  // AUXILIARY CONSTRUCTOR #1 **********************************************
  def this(name:String, govtId:Int, applicationDate:LocalDate) =
    // The first line executed of an Auxiliary Constructor must invoke
    // the Primary Constructor, which is done by calling: this(name, govtId)
    this(name, govtId) // Invokes the Student class's Primary Constructor.
    print(s", applicationDate = $applicationDate")

  // AUXILIARY CONSTRUCTOR #2 **********************************************
  def this(name:String, govtId:Int, studentId:Int) =
    // The first line executed of an Auxiliary Constructor must invoke
    // the Primary Constructor, which is done by calling: this(name, govtId)
    this(name, govtId) // Invokes the Student class's Primary Constructor.
    print(s", studentId = $studentId")

/******************
 * main()
 *****************/
@main def main() =
  // The following line of code invokes ONLY the Primary Constructor.
  val stud1 = Student("Joe", 111)
  // PRINTS: name = Joe, govtId = 111

  // The following line invokes the Primary Constructor and Auxiliary Constructor #1.
  val stud2 = Student("Jane", 222, LocalDate.now());
  // PRINTS: name = Jane, govtId = 222, applicationDate = 2024-12-06

  // The following line invokes the Primary Constructor and Auxiliary Constructor #2.
  val stud3 = Student("Alice", 333, 444)
  // PRINTS: name = Alice, govtId = 333, studentId = 444

============================================================================

CASE CLASS
==========
A Scala "case class" 




DIFFERENCES BETWEEN A SCALA "case class" AND A SCALA "class"
============================================================
Below is an example of how to create a simple class, and a simple case class.
Both of these classes store a "name" and "Id" as a val--so they are basically
equivalent classes.  However, a regular class (the PersonClass) REQUIRES its
args/params to be preceded with the keyword "val" or "var", or it won't compile.
The args/params passed to a case class (the PersonCaseClass) become "val" by
default when they're not specified.  However, you can explicitly precede the
args/params passed to a case class with the keyword "val" or "var" if you choose.

   class PersonClass(val name:String, val Id:Int)  // A class definition.
   val joe = new PersonClass("Jim", 12345)         // The class being instantiated.

   case class PersonCaseClass(name:String, id:Int) // A case class definition.
   val jim = PersonCaseClass("Joe", 98765)         // The case class being instantiated.

A Scala "case class" is different from a regular Scala class in the following 6 ways.

1) A case class MUST contain one or more args/params in its definition,
   while a plain Scala class can contain zero or more args/params.

2) The args/params passed to a plain Scala class become PUBLIC class members
   ONLY when they're preceded with the val or var keyword.  If its args/params
   aren't preceded with val/var, they become PRIVATE members, accessible only
   from within the body of the class.

   All args/params passed to a Scala case class become PUBLIC class members by
   default, regardless if they're preceded with keywords val/var, or nothing.
   If the args/params passed to a case class are preceded with nothing, they
   become val by default.

   Within the body of a plain class, or a case class, you can declare additional
   val/var class members, and define them to be "private" or "protected" members.
   If you don't define them as "private" or "protected", they are PUBLIC class
   members by default.  (In Scala, there is no keyword named "public".)
   
   The following code sample demonstrates this behavior.  Read in-line comments
   for details.
   ===========================================================================
   object Demo
   {
     // Both args/params passed to PersonClass_1 become public
     // members by default, because they're preceded with
     // keywords val or var.
     class PersonClass_1(val name: String, var age: Int) {
       def printArgs(): Unit = {
         println(s"PersonClass_1.name = $name,  PersonClass_1.age = $age")
       }
     }

     // Both args/params passed to PersonClass_2 become private class
     // members because they're NOT preceded with keywords val or var.
     // The private members "name" and "age" are accessed and printed
     // after the PersonClass_2 is instantiated, by calling the method
     // printArgs().
     class PersonClass_2(name:String, age:Int) {
       def printArgs():Unit = {
         println(s"PersonClass_2.name = $name,  PersonClass_2.age = $age")
       }
     }

     // All args/params passed to PersonCaseClass become public
     // members by default, regardless if they're preceded with
     // val, var, or nothing.
     case class PersonCaseClass(name:String, val age:Int) {
       def printArgs(): Unit = {
         println(s"PersonCaseClass.name = $name,  PersonCaseClass.age = $age")
       }
     }

     def main(args: Array[String]):Unit = {
       // **********************************
       // Test PersonClass_1 behavior:
       val person_1 = new PersonClass_1("Joe", 15)
       person_1.printArgs() // PRINTS: PersonClass_1.name = Joe,  PersonClass_1.age = 15

       // The following 2 lines compile because person_1.name and person_1.age
       // are public class members.
       var name = person_1.name
       var age  = person_1.age

       // **********************************
       // Test PersonClass_2 behavior:
       val person_2 = new PersonClass_2("Jack", 23)
       person_2.printArgs() // PRINTS: PersonClass_2.name = Jack,  PersonClass_2.age = 23

       // If you uncomment the following 2 lines, they won't compile because
       // person_2.name and person_2.age are private class members.
       // name = person_2.name  // WON'T COMPILE!
       // age  = person_2.age   // WON'T COMPILE!

       // **********************************
       // Test PersonCaseClass behavior:
       val person_3 = new PersonCaseClass("Sally", 47)
       person_3.printArgs() // PRINTS: PersonCaseClass.name = Sally,  PersonCaseClass.age = 47

       // The following 2 lines compile because ALL args/params passed
       // to a case class are ALWAYS public class members.
       name = person_3.name
       age  = person_3.age
     }
   }
   ===========================================================================

3) When a "case class" is instantiated, the following 6 methods become
   available by default, so you never need to write them yourself.

   apply()   - This method gets called automatically whenever a Scala class
               (or case class) is instantiated.  A regular class also
               supplies the apply() method by default, but you can replace
               a regular class's default apply() method by writing your own
               apply() method, if you choose.
   unapply() - This method gets called automatically whenever pattern matching
               is performed on a Scala class (or case class).  If you want
               to perform pattern matching on a regular class, you must write
               your own unapply() method because it's not provided by default.
   copy()    - Creates and returns a new "case class" instance that's a copy
               of the existing case class.  If you pass this copy() method any
               args/params, those args/params specify the case class member
               values that will be changed in the copied-to (returned) instance.
               Only the newly-created case class will contain the changes you
               specify via the args/params.  Calling copy() on a case class
               DOESN'T make any changes to the copied-from case class.
   equals()  - Determines if two Scala objects are equal.  Read the hashCode() description below.
   hashCode() - Returns an Int value.  If calling hashCode() on two Scala objects
                return the same Int value, they are equal.  You can use the equals()
                method or the '==' operator in place of calling hashCode() to
                determine equivalency.
   toString() - Renders the case class’s name and fields to a String.

4) A case class is Serializable.

5) A case class CAN be abstract, like this:   abstract case class Card(id:Int)

6) A regular class can extend a trait.  But a case class CAN'T extend a trait,
   or another case class.  However, a case class CAN extend a regular class OR
   an abstract class.  The following example will work with or without the
   "abstract" keyword:

   abstract class Card(id:Int)
   case class DebitCard(id:Int, name:String, number:Int) extends Card(id)
