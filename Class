This web page covers the Scala class, where "class" is a keyword.
A Scala class is the most common and fundamental data structure
in the Scala language.  All of the following topics are related
to the Scala class, and have a dedicated section below.

* Class
* Default Arguments
* Auxiliary Class Constructors
* Case Class


CLASS
=====
A Scala 3 class can be written with or without a braces pair {}.  A Scala 3
class that doesn't use a braces pair {} must use a colon char (:) at the
termination of the class's argument list.  All of the class's code that
follows the colon char (:) must appear on a new line below its argument
list, and must be indented to the right of the opening "class" or
"case class" keywords.  Scala 3 "case classes", objects and traits
implement the colon char (:) in this same way.

A Scala class that contains no body doesn't require a braces pair {} or
a colon char (:), but its constructor always requires a parenthesis
pair (), even when the class constructor accepts no arguments.

When a class has an argument list, it's optional to precede each argument
with the "val" keyword, or the "var" keyword, or neither.

When a class argument is preceded with the "val" or "var" keyword, the
argument becomes a public class member by default; so it can be accessed
inside and outside the class.

When a class argument isn't preceded with the "val" or "var" keyword, the
argument becomes a private "val" by default, so it can be accessed only
from within the class, and its value can never be changed.

IMPORTANT: A class can be written to contain val/var members that aren't
           included in the class's argument list.  So don't assume that
           a class's argument list references all of its val/var members.

If a class has no val/var members, or if all instantiations of that class
will always have identical val/var values, then a Scala object should be
used instead of a Scala class.

A regular class isn't Serializable by default, while a "case class" is Serializable
by default.  If you want want to make a regular class Serializable, you need to add
the text "extends Serializable" to the class definition.

For every regular class and "case class" that you write, Scala automatically
generates the following 4 methods.

apply()   -  This method gets generated and invoked automatically whenever a Scala class
             (or "case class") is instantiated.  (This method is rarely called directly
             by the programer.)  In Scala 3 you don't need to use the "new" keyword when
             instantiating a regular class, or a "case class".  You can replace a regular
             class's default apply() method by adding your own apply() method to the
             body of the regular class.  But a "case class" always implements its own
             apply() method.

equals()   - Determines if two Scala objects are equal.  Read the hashCode() description below.

hashCode() - Returns an Int value.  If calling hashCode() on two Scala objects return the
             same Int value, they are equal.  You can use the equals() method or the
             '==' operator in place of calling hashCode() to determine equivalency.

toString() - Renders the case classâ€™s name and fields to a String.  You may want
             to define your own toString() method for a class (using the 'override'
             keyword) so it prints information about the class that you desire.

The following program demonstrates the above-mentioned rules.

class Bozo()                  // A class doesn't require any arguments.
class Book(var title:String)  // Book.title is a public var class member.
class Person(val name:String) // Person.name is a public val class member.
class Movie(name:String):     // Movie.name is a private val class member.
  def printName:Unit = println(name)

/******************
 * main()
 *****************/
@main def main():Unit =
  val bozo = Bozo()
  println(s"bozo = $bozo") // PRINTS: bozo = Bozo@357246de

  val book = Book("Scala 3 for Idiots")
  // Because the Book.title argument has been declared a var, it's a public member,
  // so it can accessed here, outside the Person class.
  println(s"book.title = ${book.title}") // PRINTS: book.title = Scala 3 for Idiots
  // Because the Book.title argument has been declared a var, we can change also
  // change it's value, as shown here...
  book.title = "Scala 3 for Geniuses"
  println(s"book.title = ${book.title}") // PRINTS: book.title = Scala 3 for Geniuses

  val person = Person("Tom")
  // Because the Person.name argument has been declared a val, it's a public member,
  // so it can be accessed here, outside the Person class.
  println(s"person.name = ${person.name}") // PRINTS: person.name = Tom

  val movie = Movie("When Galaxies Collide")
  // Because the Movie.name argument isn't preceded with the "val" or
  // "var" keyword, it becomes a private class member by default.  So
  // Movie.name can be accessed only from within the Movie class.
  print("movie.name = "); movie.printName // PRINTS: movie.name = When Galaxies Collide

============================================================================

DEFAULT ARGUMENTS AND NAMED ARGUMENTS
=====================================
Scala class constructors and Scala methods can be written to accept default arguments.
A default argument is an argument that doesn't need to be specified when the class
constructor, or the method, is invoked.  When a default argument isn't specified,
the code supplies the default value specified in the argument list.

When you instantiate a class, a trait, an object, or invoke a method, you can set
any of its argument values in any order you want, by specifying the argument's name,
like this...

printAddress(streetAddress = "9876 Main St.",
             city          = "Manitowoc",
             state         = "WI",
             zipCode       = 54220)

Study the following self-explanatory program to understand default and named arguments.

class Socket(val timeout: Int = 5_000, val linger: Int = 5_000):
  override def toString = s"timeout: $timeout, linger: $linger"

/******************
 * main()
 *****************/
@main def main():Unit =
  def defaultArgumentMethod(name:String = "No Name", id:Int = 0):Unit =
    println(s"name = $name,  id = $id")

  val s1 = Socket()
  println(s"s1 = $s1")  // PRINTS: s1 = timeout: 5000, linger: 5000
  val s2 = Socket(2_500)
  println(s"s2 = $s2")  // PRINTS: s2 = timeout: 2500, linger: 5000
  val s3 = Socket(10_000, 10_000)
  println(s"s3 = $s3")  // PRINTS: s3 = timeout: 10000, linger: 10000
  val s4 = Socket(timeout = 10_000)
  println(s"s4 = $s4")  // PRINTS: s4 = timeout: 10000, linger: 5000
  val s5 = Socket(linger = 10_000)
  println(s"s5 = $s5\n")  // PRINTS: s5 = timeout: 5000, linger: 10000

  defaultArgumentMethod() // PRINTS: name = No Name,  id = 0
  defaultArgumentMethod("Joe") // PRINTS: name = Joe,  id = 0
  defaultArgumentMethod(id = -123) // PRINTS: name = No Name,  id = -123
  defaultArgumentMethod(id = 987, name = "Sue") // PRINTS: name = Sue,  id = 987

============================================================================

AUXILIARY CLASS CONSTRUCTORS
============================
Most class definitions are written to have a single constructor, which
is known as the class's Primary Constructor.  However, you can define
a class that contains multiple constructors; so that class can be
instantiated using different argument lists.  These additional
constructors are called Auxiliary Constructors.

IMPORTANT: The first line of code executed by an Auxiliary Constructor
           MUST be a call to "this", which invokes the class's Primary
           Constructor.  So every time an Auxiliary Constructor is
           invoked, the first thing it must do is invoke the class's
           Primary Constructor.

import java.time.*

class Student(name:String, govtId:Int):
  // PRIMARY CONSTRUCTOR ***************************************************
  // Code at this indentation level will get executed once (and
  // only once) every time a new Student class is instantiated;
  // regardless of which constructors are invoked.
  print(s"\nname = $name, govtId = $govtId")

  // AUXILIARY CONSTRUCTOR #1 **********************************************
  def this(name:String, govtId:Int, applicationDate:LocalDate) =
    // The first line executed of an Auxiliary Constructor must invoke
    // the Primary Constructor, which is done by calling: this(name, govtId)
    this(name, govtId) // Invokes the Student class's Primary Constructor.
    print(s", applicationDate = $applicationDate")

  // AUXILIARY CONSTRUCTOR #2 **********************************************
  def this(name:String, govtId:Int, studentId:Int) =
    // The first line executed of an Auxiliary Constructor must invoke
    // the Primary Constructor, which is done by calling: this(name, govtId)
    this(name, govtId) // Invokes the Student class's Primary Constructor.
    print(s", studentId = $studentId")

/******************
 * main()
 *****************/
@main def main() =
  // The following line of code invokes ONLY the Primary Constructor.
  val stud1 = Student("Joe", 111)
  // PRINTS: name = Joe, govtId = 111

  // The following line invokes the Primary Constructor and Auxiliary Constructor #1.
  val stud2 = Student("Jane", 222, LocalDate.now());
  // PRINTS: name = Jane, govtId = 222, applicationDate = 2024-12-06

  // The following line invokes the Primary Constructor and Auxiliary Constructor #2.
  val stud3 = Student("Alice", 333, 444)
  // PRINTS: name = Alice, govtId = 333, studentId = 444

============================================================================

Below is an example of how to create a simple class, and a simple case class.
Both of these classes store a "name" and "Id" as a val--so they are basically
equivalent classes.  However, a regular class (the PersonClass) REQUIRES its
args/params to be preceded with the keyword "val" or "var", or it won't compile.
The args/params passed to a case class (the PersonCaseClass) become "val" by
default when they're not specified.  However, you can explicitly precede the
args/params passed to a case class with the keyword "val" or "var" if you choose.

   class PersonClass(val name:String, val Id:Int)  // A class definition.
   val joe = new PersonClass("Jim", 12345)         // The class being instantiated.

   case class PersonCaseClass(name:String, id:Int) // A case class definition.
   val jim = PersonCaseClass("Joe", 98765)         // The case class being instantiated.


CASE CLASS
==========
 A "case class" requires at least one argument in its constructor.
 A regular Scala class doesn't require arguments in its  constructor.

For every "case class" that you write, Scala automatically generates the
following 2 methods.  These 2 methods aren't automatically generated by
a regular class.  For a regular class, you must manually write your own
copy() and unapply() methods, adding them to the body of the class.

copy()    - Creates and returns a new "case class" instance that's a copy
            of the existing case class.  If you pass this copy() method any
            arguments, those arguments specify the "case class" member values
            that will be changed in the copied-to (returned) instance.  Calling
            copy() without any arguments makes an exact copy of the "case class".

unapply() - The unapply() method serves as an extractor for pattern matching on
            a class.  (Pattern matching is invoked via the "match" keyword.)
            For every "case class" that you write, Scala automatically generates
            an unapply() method for you.  So you can perform pattern matching
            on every "case class" without having to write an unapply() method.
            If you want to perform pattern matching on a regular class, you must
            write your own unapply() method and add it to the class's body.

All arguments in a "case class" constructor are public class members by default;
regardless if they're preceded with no text, or the "val"/"var" keyword.
When arguments in a "case class" constructor are preceded with no text,
they become vals by default.

A "case class" is Serializable; a regular class isn't Serializable.

Like a regular Scala class, and a "case class", can be an abstract class.

In Scala 3, a "case class" can extend a trait, an abstract class, and a regular class.
