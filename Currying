CURRYING
========
In this section, the words "method" and "function" are used interchangably
because their differences aren't in this context aren't that important.
To understand the difference between a Scala method and a Scala function
see the web page titled:  Methods_and_Functions

Most Scala methods have a single argument list, which can contain zero, one, or
multiple arguments.  Scala also allows methods to have multiple argument lists,
where each argument list can contain zero, one, or multiple arguments.  The
following program demonstrates this.

WARNING: When a method/function definition contains multiple argument lists,
         and one those argument lists contains the Scala keyword "implicit",
         that method/function is NOT a curried function.  The information
         on this web page doesn't apply to implicit arguments.

----------------------------------------------------------------------------------------------
// METHODS CONTAINING SINGLE-ARGUMENT LISTS  *****************************
def method_1(number:Int):Int = number + 1
def method_2(number1:Int, number2:Int, number3:Int):Int = number1 + number2 + number3 + 1

// METHODS CONTAINING MULTIPLE-ARGUMENT LISTS  ***************************
def method_3(number1:Int)(number2:Int, number3:Int):Int = number1 + number2 + number3 + 1
def method_4(number1:Int, number2:Int)(number3:Int):Int = number1 + number2 + number3 + 1

@main def main() =
  // CALL THE SINGLE-ARGUMENT LIST METHODS.
  var intResult = method_1(123)
  println(s"1) intResult = $intResult") // PRINTS: 1) intResult = 124
  intResult = method_2(111, 222, 333)
  println(s"2) intResult = $intResult") // PRINTS: 2) intResult = 667

  // CALL THE MULTIPLE-ARGUMENT LIST METHODS.
  intResult = method_3(111)(222, 333)
  println(s"3) intResult = $intResult") // PRINTS: 3) intResult = 667
  intResult = method_4(222, 333)(111)
  println(s"4) intResult = $intResult") // PRINTS: 4) intResult = 667
end main
----------------------------------------------------------------------------------------------

In the above program it appears that a method having multiple argument lists behaves no
differently than a method containing a single argument list.  That's true only when you
invoke the method with all of its argument lists in a single call, as was done in the
above program.

When a method/function has multiple argument lists, it can be invoked by supplying it
with fewer than all of its argument lists.  When that happens the method processes
only the argument list(s) supplied, and it returns a function, instead of a final result.

You can then invoke the returned function with any number of argument lists, until you
have supplied all of the method's argument lists.  Only when you have supplied all of
the method's argument lists will a final result be returned, instead of a function.

A method/function that has multiple argument lists is known as a CURRIED METHOD/FUNCTION.
When it's invoked with fewer than all of its argument lists, it returns not a final value,
but a function; which makes it a PARTIALLY-APPLIED FUNCTION.  Once it's supplied with
all of its argument lists, it returns not a function, but a final value; which makes
it FULLY-APPLIED.  The following program demonstrates this.  Read in-line comments
for details

----------------------------------------------------------------------------------------------
@main def main() =
  // A method/function that has multiple argument lists is a curried
  // method/function.  So this add method is a curried method.
  def add(x:Int)(y:Int)(z:Int):Int = x + y + z

  // When a curried method/function is supplied with all its argument lists
  // at once (as shown here), it processes all of them.  This makes it a
  // fully-applied function, which returns a final result, not a function.
  var intResult:Int = add(77)(12)(11)   // 77 + 12 + 11 = 100
  println(s"1) intResult = $intResult") // PRINTS: 1) intResult = 100

  // When a curried method/function has processed at least one of its
  // argument lists, but not all of its argument lists, it returns
  // a partially-applied function, as demonstrated here.
  var partiallyAppliedFunc_1:Int=>(Int => Int) = add(77)
  var partiallyAppliedFunc_2:Int=>Int          = partiallyAppliedFunc_1(12)
  intResult = partiallyAppliedFunc_2(11)
  println(s"2) intResult = $intResult") // PRINTS: 2) intResult = 100

  // The above example calls the add method 3 separate times, each time
  // supplying it with a single argument list, until it becomes fully applied.
  // The following code demonstrates the add method becomes fully applied
  // by calling only twice.  The first time with 1 argument list; the second
  // time with 2 argument lists.
  partiallyAppliedFunc_1 = add(77)
  intResult = partiallyAppliedFunc_1(12)(11)
  println(s"3) intResult = $intResult") // PRINTS: 3) intResult = 100

  // This also works...
  partiallyAppliedFunc_2 = add(12)(11)
  intResult = partiallyAppliedFunc_2(77)
  println(s"4) intResult = $intResult") // PRINTS: 4) intResult = 100

  // On the following line of code, the Scala compiler automatically
  // transforms the add method into a function by performing an
  // "eta expansion" on it, and assigns it to the var curriedSum.
  // We know curriedSum is a function (not a method) because its
  // data type contains the rocket symbol (=>).  The parenthesis ()
  // used on the following line are added to make it more readable
  // and can be removed.
  var curriedSum:Int => (Int => (Int => Int)) = add

  // The curriedSum function works exactly like the add method above.
  partiallyAppliedFunc_1 = curriedSum(77)
  intResult = partiallyAppliedFunc_1(12)(11)
  println(s"5) intResult = $intResult") // PRINTS: 5) intResult = 100

  // Here we write our own function and assign it to the var curriedSum.
  // It's identical to the curriedSum function above, which was obtained
  // by transforming the add method into a function.  The parenthesis()
  // used on the following line are added to make it more readable
  // and can be removed.
  curriedSum = (x => (y => (z => x + y + z)))
  partiallyAppliedFunc_2 = add(12)(11)
  intResult = partiallyAppliedFunc_2(77)
  println(s"6) intResult = $intResult") // PRINTS: 6) intResult = 100
end main
----------------------------------------------------------------------------------------------

In most cases a curried method/function is written with multiple argument
lists.  However, it's possible for a curried method/function to have only
one argument list.  The following 2 programs demonstrates this.

----------------------------------------------------------------------------------------------
@main def main() =
  // subtractCurried_1 is a curried method defined with 2 argument lists.
  def subtractCurried_1(x:Int)(y:Int):Int = { x - y }

  // subtractCurried_2 is defined with 1 argument list, but
  // it's a curried function because it returns a function
  // that accepts a single argument list.
  def subtractCurried_2(x:Int):(Int => Int) = { (y:Int) => x - y }

  // Invoke the subtractCurried_1 method. ******************************************
  var result:Int = subtractCurried_1(1)(2) // Invoke as a fully-applied function.
  println(s"1) result = $result") // PRINTS: 1) result = -1

  var func:(Int=>Int) = subtractCurried_1(1) // Invoke as a partially-applied function.
  result = func(2) // Calling func(2) makes it fully applied.
  println(s"2) result = $result") // PRINTS: 2) result = -1

  // Invoke the subtractCurried_2 method. ******************************************
  result = subtractCurried_2(1)(2) // Invoke as a fully-applied function.
  println(s"3) result = $result") // PRINTS: 3) result = -1

  func = subtractCurried_2(1) // Invoke as a partially-applied function.
  result = func(2) // Calling func(2) makes it fully applied.
  println(s"4) result = $result") // PRINTS: 4) result = -1

  func = subtractCurried_2(_)(2) // Invoke as a partially-applied function.
  result = func(1) // Calling func(1) makes it fully applied.
  println(s"5) result = $result") // PRINTS: 5) result = -1
end main
----------------------------------------------------------------------------------------------
@main def main() =
  // Although the following 2 functions are written with only
  // one argument list, they are both curried functions because
  // they return a function that accepts a single argument list.  
  val plus5Func:(Double=>Double)  = { (x:Double) => x+5.0D }
  val squareFunc:(Double=>Double) = { (x:Double) => x*x }

  // The following line of code can be rewritten as this:
  // def funcOfGunc[A](func:(A=>A), gunc:(A=>A)):(A=>A) = { x=>func(gunc(x)) }
  // Because A, B, and C all have the same data type.
  def funcOfGunc[A,B,C](func:(B=>C), gunc:(A=>B)):(A=>C) = { x=>func(gunc(x)) }

  // funcOfGunc(plus5Func, squareFunc) returns a function that accepts
  // a single argument of type Double.  When it's called with a second
  // argument list (on the following line of code), it's invoking the
  // returned function by passing to it an argument of type Double.
  var result:Double = funcOfGunc(plus5Func, squareFunc)(7.0D)
  println("1) result = " + result) // PRINTS: 1) result = 54.0
  var func:Double=>Double = funcOfGunc(plus5Func, squareFunc)
  result = func(7.0D)
  println("2) result = " + result) // PRINTS: 2) result = 54.0
  func = funcOfGunc(plus5Func, squareFunc)(_)
  result = func(7.0D)
  println("3) result = " + result) // PRINTS: 3) result = 54.0

  // funcOfGunc(squareFunc, plus5Func) returns a function that accepts
  // a single argument of type Double.  When it's called with a second
  // argument list (on the following line of code), it's invoking the
  // returned function by passing to it an argument of type Double.
  result = funcOfGunc(squareFunc, plus5Func)(7.0D)
  println("4) result = " + result) // PRINTS: 4) result = 144.0
  func = funcOfGunc(squareFunc, plus5Func)
  result = func(7.0D)
  println("5) result = " + result) // PRINTS: 5) result = 144.0
  func = funcOfGunc(squareFunc, plus5Func)(_)
  result = func(7.0D)
  println("6) result = " + result) // PRINTS: 6) result = 144.0
end main
----------------------------------------------------------------------------------------------



CURRYING DEFINITION 1
=====================
Currying is the process of converting a function having multiple argument lists
into a sequence of functions that accepts only one argument list.  Each function,
when invoked, returns another function that consumes the next argument list.
The sequence of function calls terminates when the last function in the sequence
returns a value, instead of a function.  Any function that returns a function
having an argument list is a curried function.

CURRYING DEFINITION 2
=====================
Currying transforms a method that has multiple argument lists into a chain of functions.
Where each function in the chain gets passed a single argument list, and returns
a function that accepts a single argument list.  When a curried function is finally
called with its last argument list, the curried function becomes fully applied, and
returns not a function, but a final value.  Any function that returns a function
having an argument list is a curried function.

HOW CURRYING WORKS
==================
The first time the method executes it processes only its RIGHT-MOST argument list.
When that RIGHT-MOST argument list is processed (consumed), the method executes
again, processing its remaining RIGHT-MOST argument list.  This process repeats
until the method's LEFT-MOST argument list remains.  When the method's LEFT-MOST
argument list has been consumed (processed), the method returns a final value
and terminates.

Whenever a Scala curried function is invoked, that function becomes
either a partially-applied function, or a fully-applied function.

PARTIALLY-APPLIED FUNCTION - Invoking a curried function with fewer than all its argument
                             lists will return a function (not a value); which means the
                             function is partially applied.

FULLY-APPLIED FUNCTION - When a curried function returns a value (a List, Array, Int, etc.),
                         instead of a function, that function becomes fully applied.



----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------
