In Scala, a for-comprehension is similar to a for-loop in other
programming languages, as it has many of the same behaviors.
However, a for-comprehension can do things that a regular for-loop
cannot.  A Scala for-comprehension has this format, where the
"yield" keyword is optional.

   for (enumerators) {
     // The body of the for-comprehension exists here, between the curly
     // braces {}.  Code located within the body of a for-comprehension is
     // executed once for each iteration of the for-comprehension.  However,
     // a for-comprehension doesn't require a body of code (it's optional).
   } yield x

Enumerators consist of the collective code contained between the parenthesis
following the Scala keyword "for".  An enumerator can be either a generator,
or a filter.  Enumerators bind values to variables.  All for-comprehensions
must include at least one generator; filters are optional.  Here's an example
of a for-comprehension that includes a generator and a filter.

@main def main():Unit =
  val intList:List[Int] = List(1, 2, 3)
  // The enumerator of the following for-comprehension consists of:
  // 1) "x <- intList"  This is the GENERATOR.  For each iteration of
  //                    the for-comprehension, one of the Int values
  //                    from intList is assigned to the variable x.
  //                    A for-comprehension can contain one or more
  //                    generators.
  // 2) "if (x > 2)"    This is a FILTER.  If the value of x is greater than 2,
  //                    the print statement is executed.  A for-comprehension
  //                    can contain 0, 1, or multiple filters.
  for (x <- intList; if x > 2) {
    print(s"x = $x")  // PRINTS: x = 3
  }
end main

THE YIELD KEYWORD
=================
The Scala keyword "yield" is used with for-comprehensions.

* A for-comprehension that doesn't implement the "yield" keyword is
  a for-comprehension that doesn't return a result; it actually
  returns the type "Unit".  The only purpose of a for-comprehension
  to not return a result (by not implementing the "yield" keyword)
  is to generate some desired side effect, like printing info.
  to the screen.

* A for-comprehension that implements the "yield" keyword is a
  for-comprehension that returns a result.  This returned result
  is built by the for-comprehension iterating through the collection.
  The following program implements the "yield" keyword in two separate
  for-comprehensions, forcing them to return a result.

  @main def main():Unit =
    val intList_1:List[Int] = List(1, 2)
    val intList_2:List[Int] = List(3, 4)
    def sum(a:Int, b:Int):Int = { a + b }

    var result:List[Int] = for (x <- intList_1) yield x
    println(s"result = $result") // PRINTS: result = List(1, 2)

    // The following for-comprehension iterates through all
    // elements of intList_1 (the "outer loop") and intList_2
    // (the "inner loop").  For each iteration of this
    // for-comprehension, the sum method is invoked.
    // The "yield" keyword forces this for-comprehension
    // to return a result.
    result =
      for (a <- intList_1; b <- intList_2) yield sum(a, b)
    println(s"result = $result") // PRINTS: result = List(4, 5, 5, 6)
  end main

NESTED FOR-COMPREHENSIONS
=========================
Nesting for-comprehensions is analogous to nesting for-loops.
The follwing sample code demonstrates nested for-comprehensions.

@main def main():Unit =
  type StrFloatTuple = (String, Float)
  val intList:List[Int] = List(11, 22, 33)
  val strFloatList:List[StrFloatTuple] = List(("Eleven",   11.11F),
                                              ("Twelve",   12.12F),
                                              ("Thirteen", 13.13F))
  // "x <- intList"      is the outer generator (analogous to the outer for-loop).
  // "y <- strFloatList" is the inner generator (analogous to the inner for-loop).
  for (x <- intList; y <- strFloatList) {
    println(s"x (intList) = $x,  y (strFloatList) = $y")
    // PRINTS: x (intList) = 11,  y (strFloatList) = (Eleven,11.11)
    //         x (intList) = 11,  y (strFloatList) = (Twelve,12.12)
    //         x (intList) = 11,  y (strFloatList) = (Thirteen,13.13)
    //         x (intList) = 22,  y (strFloatList) = (Eleven,11.11)
    //         x (intList) = 22,  y (strFloatList) = (Twelve,12.12)
    //         x (intList) = 22,  y (strFloatList) = (Thirteen,13.13)
    //         x (intList) = 33,  y (strFloatList) = (Eleven,11.11)
    //         x (intList) = 33,  y (strFloatList) = (Twelve,12.12)
    //         x (intList) = 33,  y (strFloatList) = (Thirteen,13.13)
  }
  println("===============================")
  // The following for-comprehension is functionally identical to the
  // for-comprehension above.  However, the following for-comprehension
  // implements the "yield" keyword, which forces the for-comprehension
  // to return a result, which is assigned to the val result.  The
  // for-comprehension above doesn't implement the "yield" keyword;
  // so it doesn't return a result.
  val result:List[(Int, (String, Float))] =
    // "x <- intList"      is the outer generator (analogous to the outer for-loop).
    // "y <- strFloatList" is the inner generator (analogous to the inner for-loop).
    for (x <- intList; y <- strFloatList) yield (x, y)

  for (x <- result) println(s"x (intList) = ${x._1},  y (strFloatList) = ${x._2}")
  // PRINTS: The exact same text as the first for-comprehension prints above.
end main

The syntax used to designate a Scala for-comprehension is known as "syntactic sugar"
because when the compiler parses a for-comprehension, it translates all its syntax
into invoking one of more of the following 4 Scala methods.

NOTE: All Scala collections support for-comprehensions,
      so they implement the following 4 methods.

flatMap()    - Enables a collection class to work with nested for-comprehensions
               when the for-comprehension implements the "yield" keyword.

map()        - Enables a collection class to work with a for-comprehension when the
               for-comprehension implements the "yield" keyword. This map() method
               works only with a single for-comprehension, and not with nested
               for-comprehensions.  When a collection class must work with embedded
               for-comprehensions, the collection class MUST contain this map()
               method, AND the flatMap() method mentioned below.

withFilter() - Enables a collection class to work with a filter inside a for-comprehension.
               (This method is called ONLY when a for-comprehension. implements a filter.)

foreach()    - Enables a collection class to invoke the foreach() method.  Invoking foreach()
               on a collection is equivalent to iterating through all elements of the collection
               using a for-comprehension.  Here's a code sample showing how to use the foreach()
               method on some Scala collections.

If you write your own collection class and want to make it work with any type of for-comprehension,
you must write the above four methods and make them members of your collection class.  These
four methods must have signatures corresponding to the method definitions shown here.

abstract class CustomCollectionClass[A]
{
  def flatMap[B](func: A => CustomCollectionClass[B]):CustomCollectionClass[B]
  def map[B](func: A => B):CustomCollectionClass[B]
  def withFilter(func: A => Boolean):CustomCollectionClass[A]
  def foreach(func: A => Unit):Unit
}

==========================================================
==========================================================
==========================================================

A "for loop" in Scala is known as a "for comprehension."
A "for comprehension" contains these two sections.

1) The first section of a "for comprehension" contains the
   generator, which is designated by the '<-' symbol and can
   be contained between a pair of parenthesis (), or between
   a pair of curly braces {}.  This section of the "for
   comprehension" can also contain an optional filter, which
   is designated by an 'if' statement.

2) The second section of a "for comprehension" contains the code
   that executes with each iteration of the "for comprehension".
   If this section contains more than one line of code, that code
   must be contained between a pair of curly braces {}.

The following code sample shows how to construct a
"for comprehension" that...

  * Uses a generator (the '<-' symbol).
  * Uses curly braces {} and parenthesis () interchangeably.
  * Uses a filter (an 'if' statement).
   
@main def main():Unit =
  val intList:List[Int] = List(1, 2, 3)
  var result:String = ""

  for (x <- intList)
    print(s"x = $x, ") // PRINTS: x = 1, x = 2, x = 3,
  println

  for (x <- intList; if (x > 1); if (x < 3)) {
    result = s"result = $x"
    print(result) // PRINTS: result = 2
  }
  println

  for {x <- intList; if (x > 2)} {
    result = s"result = $x"
    print(result) // PRINTS: result = 3
  }
end main



For loops/comprehensions in Scala can be written the standard way
by iterating over a collection using a for loop.  The result
generated by the for loop can also be obtained by replacing
the for loop with a call to the collection's flatMap method,
as shown in the following examples.

===================================================================
@main def main():Unit =
  val intList:List[Int]   = List(1, 2, 3)
  val charList:List[Char] = List('a', 'b')

  // Using a for loop, print the paired values of intList and charList.
  val forLoopResult:List[String] = for {
    number:Int <- intList  // this generator will be a flatMap
    char:Char  <- charList // this generator will be a map inside the flatMap
  } yield s"$number-$char"
  println(s"forLoopResult = $forLoopResult")
  // PRINTS: forLoopResult = List(1-a, 1-b, 2-a, 2-b, 3-a, 3-b)

  // The following code invokes the flatMap method to obtain
  // the same result as the above for loop.
  val flatMapResult:List[String] =
    intList.flatMap((number:Int) => charList.map((char:Char) => s"$number-$char"))
  println(s"flatMapResult = $flatMapResult")
  // PRINTS: flatMapResult = List(1-a, 1-b, 2-a, 2-b, 3-a, 3-b)
end main

===================================================================

The map() function is available on many Scala collections.  The following
program demonstrates a custom map() function that also works on Scala
collections; where this custom map() implements a for comprehension.

@main def main():Unit =
  /**
   * Return the length of the String passed to this method.
   */
  def strLengthFunc(str: String): Int = str.length

  /**
   * Double the number passed to this doubleIntFunc function,
   * and return it.
   */
  def doubleIntFunc(intNumber:Int):Int = intNumber * 2

  /**
   * This custom map function replicates the behavior of Scala's
   * List.map function.
   * @param func - A Scala function accepts an argument of type B,
   *               and returns the type A.
   * @param xs - A Scala List of type B
   *
   * @return - A Scala List of type A
   */
  def map[A, B](func:B => A, xs:List[B]):List[A] =
    for x <- xs yield func(x)
  end map

  var intList:List[Int] = map(doubleIntFunc, List(1, 2, 3))
  println(s"1) intList = $intList") // PRINTS: 1) intList = List(2, 4, 6)

  intList = map(strLengthFunc, List("zzzzz", "yyyy", "xxx"))
  println(s"2) intList = $intList") // PRINTS: 2) intList = List(5, 4, 3)
end main

===================================================================
