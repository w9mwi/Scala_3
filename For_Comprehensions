In Scala, a for-comprehension is similar to a for-loop in other
programming languages, as it has many of the same behaviors.
However, a for-comprehension can do things that a regular for-loop
cannot.  A Scala for-comprehension has the following format.

   for (enumerators) {
     // The body of the for-comprehension exists here, between the curly
     // braces {}.  Code located within the body of a for-comprehension is
     // executed once for each iteration of the for-comprehension.  A
     // for-comprehension doesn't require a body of code.
   } yield x

Enumerators bind values to variables.  An enumerator can be either
a definition, a generator, or a filter.  Every for-comprehension
must contain at least one generator; while it can contain zero,
one, or multiple definitions and filters.

Nested for-comprehensions are analogous to nested "for-loops."
A for-comprehension that's nested two times will have two
generators.  A for-comprehension that's nested three times will
have three generators.  Etc.

The following code sample demonstrates a for-comprehension that
contains a definition, a generator, and a filter.  Read in-line
comments.

@main def main():Unit =
  case class Person(nameF:String, nameL:String, yearBorn:Int)

  val people:List[Person] =
    List(Person("Jim", "Beam", 1975), Person("Sue", "Glue", 1988), Person("Jack", "Ash", 1944))

  val result:List[String] =
    for {
      p <- people        // people is the GENERATOR, p is the RECEIVER
      year = p.yearBorn  // year is a DEFINITION.  A definition is used to store a value.
      if (year > 1944)   // This is a FILTER - Return only people with yearBorn > 1944.
    } yield p.nameF.concat(" " + p.nameL + " - " + year)

  println(s"result = $result") // PRINTS: result = List(Jim Beam - 1975, Sue Glue - 1988)
end main

=====================================================================================

THE YIELD KEYWORD
=================
The Scala keyword "yield" is used with for-comprehensions.

A for-comprehension that doesn't implement the "yield" keyword doesn't return
a result.  (A for-comprehension that doesn't implement the "yield" keyword
actually returns the type Unit.)  In this case, a for-comprehension is used
only for its "side effects", such as printing info. to the screen, etc.

A for-comprehension that implements the "yield" keyword is a for-comprehension
that returns a result.  This returned result is built by the for-comprehension
iterating through the collection.  The following program implements the "yield"
keyword in two separate for-comprehensions, forcing them to return a result.

@main def main():Unit =
  val intList_1:List[Int] = List(1, 2)
  val intList_2:List[Int] = List(3, 4)
  def sum(a:Int, b:Int):Int = { a + b }

  var result:List[Int] = for (x <- intList_1) yield x
  println(s"result = $result") // PRINTS: result = List(1, 2)

  // The following for-comprehension iterates through all elements of
  // intList_1 (the "outer loop") and intList_2 (the "inner loop").
  // For each iteration of this for-comprehension, the sum method
  // is invoked.  The "yield" keyword forces the for-comprehension
  // to return a result.
  result = for (a <- intList_1; b <- intList_2) yield sum(a, b)
  println(s"result = $result") // PRINTS: result = List(4, 5, 5, 6)
end main

=====================================================================================

NESTED FOR-COMPREHENSIONS
=========================
Nesting for-comprehensions is analogous to nesting for-loops.
The follwing sample code demonstrates nested for-comprehensions.

@main def main():Unit =
  type StrFloatTuple = (String, Float)
  val intList:List[Int] = List(11, 22, 33)
  val strFloatList:List[StrFloatTuple] = List(("Eleven",   11.11F),
                                              ("Twelve",   12.12F),
                                              ("Thirteen", 13.13F))
  for (x <- intList;        // This is the outer generator (analogous to an outer for-loop).
       y <- strFloatList) { // This is the inner generator (analogous to an inner for-loop).
    println(s"x (intList) = $x,  y (strFloatList) = $y")
    // PRINTS: x (intList) = 11,  y (strFloatList) = (Eleven,11.11)
    //         x (intList) = 11,  y (strFloatList) = (Twelve,12.12)
    //         x (intList) = 11,  y (strFloatList) = (Thirteen,13.13)
    //         x (intList) = 22,  y (strFloatList) = (Eleven,11.11)
    //         x (intList) = 22,  y (strFloatList) = (Twelve,12.12)
    //         x (intList) = 22,  y (strFloatList) = (Thirteen,13.13)
    //         x (intList) = 33,  y (strFloatList) = (Eleven,11.11)
    //         x (intList) = 33,  y (strFloatList) = (Twelve,12.12)
    //         x (intList) = 33,  y (strFloatList) = (Thirteen,13.13)
  }
  println("===============================")
  // The following for-comprehension is functionally identical to the
  // for-comprehension above.  However, the following for-comprehension
  // implements the "yield" keyword, which forces the for-comprehension
  // to return a result.  The for-comprehension above doesn't implement
  // the "yield" keyword, so it doesn't return a result.
  val result:List[(Int, (String, Float))] = for (x <- intList; y <- strFloatList) yield (x, y)

  for (x <- result) println(s"x (intList) = ${x._1},  y (strFloatList) = ${x._2}")
  // PRINTS: Text that's identical to the text printed by the above for-comprehension.
end main

=====================================================================================

TRANSLATING SCALA FOR-COMPREHENSIONS INTO SCALA CODE
====================================================
Scala for-comprehensions are known as "syntactic sugar" because when the compiler
parses a for-comprehension, it translates it into one of more of these 4 Scala methods.

flatMap()    - Enables a collection class to work with nested for-comprehensions
               (analogous to "nested for-loops") that implement the "yield" keyword.
               See the following code sample for how flatMap is used.

map()        - When a for-comprehension implements the "yield" keyword, the Scala
               compiler translates that for-comprehension into Scala code, which
               invokes the collection's map method to generate the result.  See
               the following code sample for how map is used.

withFilter() - Enables a collection class to work with a filter inside a for-comprehension.
               (This method is called ONLY when a for-comprehension implements a filter.)

foreach()    - Enables a collection class to invoke the foreach() method.  Invoking foreach()
               on a collection is equivalent to iterating through all elements of the collection
               using a for-comprehension.  Here's a code sample showing how to use the foreach()
               method on some Scala collections.

If you have a for-comprehension that implements the "yield" keyword, you can replace
that for-comprehension by invoking the flatMap and map methods as per these two steps...

1) When there are N number of generators in a for-comprehension, there will be
   N-1 calls to the flatMap method.  For example, if a for-comprehension is nested
   3 levels deep (it has 3 generators), the flatMap method will need to be invoked
   (N-1) times = (3-1) times = 2 times.

   WARNING: There will always be one less call to the flatMap method than the number of
            generators contained in the for-comprehension.  This means only nested
            for-comprehensions will invoke the flatMap method.  for-comprehensions
            that aren't nested (have a single generator) won't invoke the flatMap method!

2) After step 1) above is completed, invoke the Scala map() method one time.

The following programs code demonstrate how to translate for-comprehensions
that use the Scala "yield" keyword into method calls to the List.flatMap and
List.map methods.

=========================================================================
@main def main():Unit =
  val list1 = List(1, 2)
  val list2 = List("A", "B")
  val list3 = List(true, false)

  // ********************************************************
  // When a Scala for-comprehension contains no yield statement,
  // it returns "nothing" (the Scala type Unit), as demonstrated
  // by this code...
  val result_1:Unit = for (x <- list1;
                           y <- list2;
                           z <- list3) {
    println(s"x = $x,  y = $y,  z = $z")
    // PRINTS: x = 1,  y = A,  z = true
    //         x = 1,  y = A,  z = false
    //         x = 1,  y = B,  z = true
    //         x = 1,  y = B,  z = false
    //         x = 2,  y = A,  z = true
    //         x = 2,  y = A,  z = false
    //         x = 2,  y = B,  z = true
    //         x = 2,  y = B,  z = false
  }
  // Because result_1 has the data type Unit, result_1
  // prints this text to the console:  ()
  println(s"result_1 = $result_1")  // PRINTS: result_1 = ()


  // ********************************************************
  // The following for-comprehension is identical to the
  // for-comprehension above, except this for-comprehension
  // contains a yield statement, which means it returns a
  // valid result other than the Scala type Unit.
  var result_2:List[String] = for (x <- list1;
                                   y <- list2;
                                   z <- list3) yield s"($x, $y, $z)"
  println(s"result_2 = $result_2")
  // PRINTS: result_2 = List((1, A, true), (1, A, false), (1, B, true), (1, B, false),
  //                         (2, A, true), (2, A, false), (2, B, true), (2, B, false))


  // ********************************************************
  // The following code generates identical results to the
  // above for-comprehension by replacing the "for" keyword
  // with calls to the Scala List.flatMap and List.map methods.
  // NOTE: The following code doesn't contain the "yield" keyword
  //       because it's used only by Scala for-comprehensions.
  result_2 = list1.flatMap(x => list2.flatMap(y => list3.map(z => s"($x, $y, $z)")))
  println(s"result_2 = $result_2")
  // PRINTS: result_2 = List((1, A, true), (1, A, false), (1, B, true), (1, B, false),
  //                         (2, A, true), (2, A, false), (2, B, true), (2, B, false))
end main
=========================================================================

@main def main():Unit =
  val intList_1:List[Int]  = List(1, 2)
  val intList_2:List[Int]  = List(3, 4)
  val intList_3:List[Int]  = List(5, 6)
  val charList: List[Char] = List('a', 'b')
  def sum(a:Int, b:Int, c:Int):Int = a + b + c

  // ================================================================
  // The following for-comprehension generates the same result
  // as the call to intList_1.map(_*2) below.
  var result_1:List[Int] = for (x <- intList_1) yield (x*2)
  println(s"1) result_1 = $result_1") // PRINTS: 1) result_1 = List(2, 4)
  result_1 = intList_1.map(_ * 2)
  println(s"2) result_1 = $result_1") // PRINTS: 2) result_1 = List(2, 4)

  // ================================================================
  // The following for-comprehension generates the same result as
  // the combined calls to intList_1.flatMap, intList_2.flatMap,
  // and intList_3.map below.
  result_1 = for (a <- intList_1; b <- intList_2; c <- intList_3) yield sum(a,b,c)
  println(s"3) result_1 = $result_1") // PRINTS: 3) result_1 = List(9, 10, 10, 11, 10, 11, 11, 12)
  result_1 = intList_1.flatMap(a => intList_2.flatMap(b => intList_3.map(c => sum(a,b,c))))
  println(s"4) result_1 = $result_1") // PRINTS: 4) result_1 = List(9, 10, 10, 11, 10, 11, 11, 12)

  // ================================================================
  // The following for-comprehension generates the same result as the
  // combined calls to intList_1.flatMap and charList.map below.
  var result_2: List[String] = for {
    number:Int <- intList_1
    char:Char  <- charList
  } yield s"$number-$char"
  println(s"5) result_2 = $result_2")
  // PRINTS: 5) result_2 = List(1-a, 1-b, 2-a, 2-b)
  result_2 = intList_1.flatMap((number: Int) => charList.map((char: Char) => s"$number-$char"))
  println(s"6) result_2 = $result_2")
  // PRINTS: 6) result_2 = List(1-a, 1-b, 2-a, 2-b)
end main

=========================================================================

If you write your own custom collection class and want to make it work
with any type of for-comprehension, you must write the following four
methods and make them members of your collection class.  These four
methods must have signatures corresponding to the method definitions
shown here.

abstract class CustomCollectionClass[A]
{
  def flatMap[B](func: A => CustomCollectionClass[B]):CustomCollectionClass[B]
  def map[B](func: A => B):CustomCollectionClass[B]
  def withFilter(func: A => Boolean):CustomCollectionClass[A]
  def foreach(func: A => Unit):Unit
}

=========================================================================
USE FOR-COMPREHENSIONS WITH THE OPTION CLASS FOR ERROR HANDLING
===============================================================
Read the in-line comments in the following programs.

@main def main():Unit =
  def parseAge(s: String):Option[Int] = try { Some(s.toInt) } catch { case _ => None }

  val age_1:Option[Int] = parseAge("35")  // parseAge recognizes this as a VALID text number.
  val age_2:Option[Int] = parseAge("forty two") // parseAge recognizes this as an INVALID text number.

  // The Scala Option class is a special collection class that can contain
  // no more than one element.  Because the Option class is a collection, you
  // can traverse multiple Option collections via nested for-comprehensions
  // (analogous to nested for-loops).  If any of the age values obtained in
  // the for-comprehension is invalid, the entire for-comprehension will terminate
  // and return the value None,   This avoids multiple manual `isDefined` checks,
  // or nested `match` statements for error detection.
  var totalAge:Option[Int] = for {
    age1 <- age_1
    age2 <- age_2
  } yield age1 + age2
  println(s"age_1 + age_2 = $age_1 + $age_2 = $totalAge")
  // PRINTS: age_1 + age_2 = Some(35) + None = None

  val age_3 = parseAge("30")
  val age_4 = parseAge("20")
  totalAge = for {
                   age3 <- age_3
                   age4 <- age_4
  } yield age3 + age4
  println(s"age_3 + age_4 = $age_3 + $age_4 = $totalAge")
  // PRINTS: age_3 + age_4 = Some(30) + Some(20) = Some(50)
end main

=========================================================================

@main def main():Unit =
  /**
   * The for-comprehension in this calculateTotal_1 method calculates
   * the monetary value of a product stored in inventory.  If the
   * product's quantity < 1, the for-comprehension returns the Option
   * value of None.
   */
  def calculateTotal_1(quantity:Option[Int],
                       price:Option[Double]):Option[Double] =
    for {
      quantity <- quantity
      price    <- price
      if quantity > 0
    } yield (quantity * price)

  var totalPrice:Option[Double] = calculateTotal_1(Option(11), Option(9.99D))
  println(s"1) totalPrice = $totalPrice") // PRINTS: 1) totalPrice = Some(109.89)

  totalPrice = calculateTotal_1(Option(0), Option(9.99D))
  println(s"2) totalPrice = $totalPrice") // PRINTS: 2) totalPrice = None

  /**
   * This calculateTotal_2 method returns the identical result as the
   * calculateTotal_1 method above, as it replaces the for-comprehension
   * in calculateTotal_1 with method calls to Scala's Option class API.
   */
  def calculateTotal_2(quantity:Option[Int],
                       price: Option[Double]):Option[Double] =
    quantity.flatMap(quantity => price.withFilter(price => quantity > 0).map(price => quantity * price))

  totalPrice = calculateTotal_2(Option(11), Option(9.99D))
  println(s"3) totalPrice = $totalPrice") // PRINTS: 3) totalPrice = Some(109.89)

  totalPrice = calculateTotal_2(Option(0), Option(9.99D))
  println(s"4) totalPrice = $totalPrice") // PRINTS: 4) totalPrice = None
end main


