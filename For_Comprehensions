In Scala, a for-comprehension is similar to a for-loop in other
programming languages, as it has many of the same behaviors.
However, a for-comprehension can do things that a regular for-loop
cannot.  A Scala for-comprehension has this format, where the
"yield" keyword is optional.

   for (enumerators) {
     // The body of the for-comprehension exists here, between the curly
     // braces {}.  Code located within the body of a for-comprehension is
     // executed once for each iteration of the for-comprehension.  However,
     // a for-comprehension doesn't require a body of code (it's optional).
   } yield x

Enumerators consist of the collective code contained between the parenthesis
following the Scala keyword "for".  An enumerator can be either a generator,
or a filter.  Enumerators bind values to variables.  All for-comprehensions
must include at least one generator; filters are optional.  Here's an example
of a for-comprehension that includes a generator and a filter.

@main def main():Unit =
  val intList:List[Int] = List(1, 2, 3)
  // The enumerator of the following for-comprehension consists of:
  // 1) "x <- intList"  This is the GENERATOR.  For each iteration of
  //                    the for-comprehension, one of the Int values
  //                    from intList is assigned to the variable x.
  //                    A for-comprehension can contain one or more
  //                    generators.
  // 2) "if (x > 2)"    This is a FILTER.  If the value of x is greater than 2,
  //                    the print statement is executed.  A for-comprehension
  //                    can contain 0, 1, or multiple filters.
  for (x <- intList; if x > 2) {
    print(s"x = $x")  // PRINTS: x = 3
  }
end main

The above sample code performs all its functionality within the for-comprehension's
body by printing the value of x.  Therefore, the for-comprehension doesn't need to
return a value.  If you want a for-comprehension to return a value, include the
"yield" keyword as is done in the following code sample.

@main def main():Unit =
  val intList:List[Int] = List(1, 2, 3)
  val result:List[Int] = for (x <- intList) yield x
  println(s"result = $result") // PRINTS: result = List(1, 2, 3)
end main


NESTED FOR-COMPREHENSIONS
=========================
All generators within a for-comprehension must share the same type they loop over.
For example, if a for-comprehension contains a generator of type List[Int], and
another generator of type List[String, Float], it will work because both generators
are of type List, even though there is a difference between List[Int] and
List[String, Float].  The following code sample demonstrates this.

@main def main():Unit =
  type StrFloatTuple = (String, Float)
  val intList:List[Int] = List(11, 22, 33)
  val strFloatList:List[StrFloatTuple] = List(("Eleven",   11.11F),
                                              ("Twelve",   12.12F),
                                              ("Thirteen", 13.13F))
  for (x <- intList)
   for (y <- strFloatList) {
     println(s"x (intList) = $x,  y (strFloatList) = $y")
     // PRINTS: x (intList) = 11,  y (strFloatList) = (Eleven,11.11)
     //         x (intList) = 11,  y (strFloatList) = (Twelve,12.12)
     //         x (intList) = 11,  y (strFloatList) = (Thirteen,13.13)
     //         x (intList) = 22,  y (strFloatList) = (Eleven,11.11)
     //         x (intList) = 22,  y (strFloatList) = (Twelve,12.12)
     //         x (intList) = 22,  y (strFloatList) = (Thirteen,13.13)
     //         x (intList) = 33,  y (strFloatList) = (Eleven,11.11)
     //         x (intList) = 33,  y (strFloatList) = (Twelve,12.12)
     //         x (intList) = 33,  y (strFloatList) = (Thirteen,13.13)
   }
end main



==========================================================
==========================================================
==========================================================

A "for loop" in Scala is known as a "for comprehension."
A "for comprehension" contains these two sections.

1) The first section of a "for comprehension" contains the
   generator, which is designated by the '<-' symbol and can
   be contained between a pair of parenthesis (), or between
   a pair of curly braces {}.  This section of the "for
   comprehension" can also contain an optional filter, which
   is designated by an 'if' statement.

2) The second section of a "for comprehension" contains the code
   that executes with each iteration of the "for comprehension".
   If this section contains more than one line of code, that code
   must be contained between a pair of curly braces {}.

The following code sample shows how to construct a
"for comprehension" that...

  * Uses a generator (the '<-' symbol).
  * Uses curly braces {} and parenthesis () interchangeably.
  * Uses a filter (an 'if' statement).
   
@main def main():Unit =
  val intList:List[Int] = List(1, 2, 3)
  var result:String = ""

  for (x <- intList)
    print(s"x = $x, ") // PRINTS: x = 1, x = 2, x = 3,
  println

  for (x <- intList; if (x > 1); if (x < 3)) {
    result = s"result = $x"
    print(result) // PRINTS: result = 2
  }
  println

  for {x <- intList; if (x > 2)} {
    result = s"result = $x"
    print(result) // PRINTS: result = 3
  }
end main



For loops/comprehensions in Scala can be written the standard way
by iterating over a collection using a for loop.  The result
generated by the for loop can also be obtained by replacing
the for loop with a call to the collection's flatMap method,
as shown in the following examples.

===================================================================
@main def main():Unit =
  val intList:List[Int]   = List(1, 2, 3)
  val charList:List[Char] = List('a', 'b')

  // Using a for loop, print the paired values of intList and charList.
  val forLoopResult:List[String] = for {
    number:Int <- intList  // this generator will be a flatMap
    char:Char  <- charList // this generator will be a map inside the flatMap
  } yield s"$number-$char"
  println(s"forLoopResult = $forLoopResult")
  // PRINTS: forLoopResult = List(1-a, 1-b, 2-a, 2-b, 3-a, 3-b)

  // The following code invokes the flatMap method to obtain
  // the same result as the above for loop.
  val flatMapResult:List[String] =
    intList.flatMap((number:Int) => charList.map((char:Char) => s"$number-$char"))
  println(s"flatMapResult = $flatMapResult")
  // PRINTS: flatMapResult = List(1-a, 1-b, 2-a, 2-b, 3-a, 3-b)
end main

===================================================================

The map() function is available on many Scala collections.  The following
program demonstrates a custom map() function that also works on Scala
collections; where this custom map() implements a for comprehension.

@main def main():Unit =
  /**
   * Return the length of the String passed to this method.
   */
  def strLengthFunc(str: String): Int = str.length

  /**
   * Double the number passed to this doubleIntFunc function,
   * and return it.
   */
  def doubleIntFunc(intNumber:Int):Int = intNumber * 2

  /**
   * This custom map function replicates the behavior of Scala's
   * List.map function.
   * @param func - A Scala function accepts an argument of type B,
   *               and returns the type A.
   * @param xs - A Scala List of type B
   *
   * @return - A Scala List of type A
   */
  def map[A, B](func:B => A, xs:List[B]):List[A] =
    for x <- xs yield func(x)
  end map

  var intList:List[Int] = map(doubleIntFunc, List(1, 2, 3))
  println(s"1) intList = $intList") // PRINTS: 1) intList = List(2, 4, 6)

  intList = map(strLengthFunc, List("zzzzz", "yyyy", "xxx"))
  println(s"2) intList = $intList") // PRINTS: 2) intList = List(5, 4, 3)
end main

===================================================================
