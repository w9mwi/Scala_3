In Scala, a for-comprehension is similar to a for-loop in other
programming languages, as it has many of the same behaviors.
However, a for-comprehension can do things that a regular for-loop
cannot.  A Scala for-comprehension has this format, where the
"yield" keyword is optional.

   for (enumerators) {
     // The body of the for-comprehension exists here, between the curly
     // braces {}.  Code located within the body of a for-comprehension is
     // executed once for each iteration of the for-comprehension.  A
     // for-comprehension doesn't require a body of code (it's optional).
   } yield x

Enumerators consist of the collective code contained between the parenthesis
following the Scala keyword "for".  An enumerator can be either a generator,
or a filter.  Enumerators bind values to variables.  All for-comprehensions
must include at least one generator; filters are optional.  Here's an example
of a for-comprehension that includes a generator and a filter.

@main def main():Unit =
  val intList:List[Int] = List(1, 2, 3)
  // The enumerator of the following for-comprehension consists of:
  // 1) "x <- intList"  This is the GENERATOR.  For each iteration of
  //                    the for-comprehension, one of the Int values
  //                    from intList is assigned to the variable x.
  //                    A for-comprehension can contain one or more
  //                    generators.
  // 2) "if (x > 2)"    This is a FILTER.  If the value of x is greater than 2,
  //                    the print statement is executed.  A for-comprehension
  //                    can contain 0, 1, or multiple filters.
  for (x <- intList; if x > 2) {
    print(s"x = $x")  // PRINTS: x = 3
  }
end main

THE YIELD KEYWORD
=================
The Scala keyword "yield" is used with for-comprehensions.

* A for-comprehension that doesn't implement the "yield" keyword is
  a for-comprehension that doesn't return a result; it actually
  returns the type "Unit".  The only purpose of a for-comprehension
  to not return a result (by not implementing the "yield" keyword)
  is to generate some desired side effect, like printing info.
  to the screen.

* A for-comprehension that implements the "yield" keyword is a
  for-comprehension that returns a result.  This returned result
  is built by the for-comprehension iterating through the collection.
  The following program implements the "yield" keyword in two separate
  for-comprehensions, forcing them to return a result.

  @main def main():Unit =
    val intList_1:List[Int] = List(1, 2)
    val intList_2:List[Int] = List(3, 4)
    def sum(a:Int, b:Int):Int = { a + b }

    var result:List[Int] = for (x <- intList_1) yield x
    println(s"result = $result") // PRINTS: result = List(1, 2)

    // The following for-comprehension iterates through all
    // elements of intList_1 (the "outer loop") and intList_2
    // (the "inner loop").  For each iteration of this
    // for-comprehension, the sum method is invoked.
    // The "yield" keyword forces this for-comprehension
    // to return a result.
    result =
      for (a <- intList_1; b <- intList_2) yield sum(a, b)
    println(s"result = $result") // PRINTS: result = List(4, 5, 5, 6)
  end main

NESTED FOR-COMPREHENSIONS
=========================
Nesting for-comprehensions is analogous to nesting for-loops.
The follwing sample code demonstrates nested for-comprehensions.

===========================================================
@main def main():Unit =
  type StrFloatTuple = (String, Float)
  val intList:List[Int] = List(11, 22, 33)
  val strFloatList:List[StrFloatTuple] = List(("Eleven",   11.11F),
                                              ("Twelve",   12.12F),
                                              ("Thirteen", 13.13F))
  // "x <- intList"      is the outer generator (analogous to the outer for-loop).
  // "y <- strFloatList" is the inner generator (analogous to the inner for-loop).
  for (x <- intList; y <- strFloatList) {
    println(s"x (intList) = $x,  y (strFloatList) = $y")
    // PRINTS: x (intList) = 11,  y (strFloatList) = (Eleven,11.11)
    //         x (intList) = 11,  y (strFloatList) = (Twelve,12.12)
    //         x (intList) = 11,  y (strFloatList) = (Thirteen,13.13)
    //         x (intList) = 22,  y (strFloatList) = (Eleven,11.11)
    //         x (intList) = 22,  y (strFloatList) = (Twelve,12.12)
    //         x (intList) = 22,  y (strFloatList) = (Thirteen,13.13)
    //         x (intList) = 33,  y (strFloatList) = (Eleven,11.11)
    //         x (intList) = 33,  y (strFloatList) = (Twelve,12.12)
    //         x (intList) = 33,  y (strFloatList) = (Thirteen,13.13)
  }
  println("===============================")
  // The following for-comprehension is functionally identical to the
  // for-comprehension above.  However, the following for-comprehension
  // implements the "yield" keyword, which forces the for-comprehension
  // to return a result, which is assigned to the val result.  The
  // for-comprehension above doesn't implement the "yield" keyword;
  // so it doesn't return a result.
  val result:List[(Int, (String, Float))] =
    // "x <- intList"      is the outer generator (analogous to the outer for-loop).
    // "y <- strFloatList" is the inner generator (analogous to the inner for-loop).
    for (x <- intList; y <- strFloatList) yield (x, y)

  for (x <- result) println(s"x (intList) = ${x._1},  y (strFloatList) = ${x._2}")
  // PRINTS: The exact same text as the first for-comprehension prints above.
end main

===========================================================

Scala for-comprehensions are known as "syntactic sugar" because when the compiler
parses a for-comprehension, it translates each for-comprehension into one of more
of the 4 Scala methods listed here.

flatMap()    - Enables a collection class to work with nested for-comprehensions
               (analogous to "nested for-loops") that implement the "yield" keyword.
               See the following code sample for how flatMap is used.

map()        - When a for-comprehension implements the "yield" keyword, the Scala
               compiler translates that for-comprehension into Scala code, which
               invokes the collection's map method to generate the result.  See
               the following code sample for how map is used.

withFilter() - Enables a collection class to work with a filter inside a for-comprehension.
               (This method is called ONLY when a for-comprehension. implements a filter.)

foreach()    - Enables a collection class to invoke the foreach() method.  Invoking foreach()
               on a collection is equivalent to iterating through all elements of the collection
               using a for-comprehension.  Here's a code sample showing how to use the foreach()
               method on some Scala collections.

When a for-comprehension contains multiple generators (nested "for-loops"),
and it implements the "yield" keyword, Scala translates that for-comprehension
into the following method calls.

  1) When there are N number of generators in a for-comprehension, there
     will be N-1 calls to the flatMap method.  For example, if a
     for-comprehension contains two generators, Scala will invoke the
     flatMap method one time.  If the for-comprehension contains one
     generator, the flatMap method won't get called!

  2) After the flatMap methods has been invoked N-1 times, Scala invokes
     the map method one time only.

=========================================================================

@main def main():Unit =
  val intList_1:List[Int]  = List(1, 2)
  val intList_2:List[Int]  = List(3, 4)
  val intList_3:List[Int]  = List(5, 6)
  val charList: List[Char] = List('a', 'b')
  def sum(a:Int, b:Int, c:Int):Int = a + b + c

  // ================================================================
  // The following for-comprehension generates the same result
  // as the call to intList_1.map(_*2) below.
  var result_1:List[Int] = for (x <- intList_1) yield (x*2)
  println(s"1) result_1 = $result_1") // PRINTS: 1) result_1 = List(2, 4)
  result_1 = intList_1.map(_ * 2)
  println(s"2) result_1 = $result_1") // PRINTS: 2) result_1 = List(2, 4)

  // ================================================================
  // The following for-comprehension generates the same result as
  // the combined calls to intList_1.flatMap, intList_2.flatMap,
  // and intList_3.map below.
  result_1 = for (a <- intList_1; b <- intList_2; c <- intList_3) yield sum(a,b,c)
  println(s"3) result_1 = $result_1") // PRINTS: 3) result_1 = List(9, 10, 10, 11, 10, 11, 11, 12)
  result_1 = intList_1.flatMap(a => intList_2.flatMap(b => intList_3.map(c => sum(a,b,c))))
  println(s"4) result_1 = $result_1") // PRINTS: 4) result_1 = List(9, 10, 10, 11, 10, 11, 11, 12)

  // The following for-comprehension generates the same result as the
  // combined calls to intList_1.flatMap and charList.map below.
  var result_2: List[String] = for {
    number:Int <- intList_1
    char:Char  <- charList
  } yield s"$number-$char"
  println(s"5) result_2 = $result_2")
  // PRINTS: 5) result_2 = List(1-a, 1-b, 2-a, 2-b)
  result_2 = intList_1.flatMap((number: Int) => charList.map((char: Char) => s"$number-$char"))
  println(s"6) result_2 = $result_2")
  // PRINTS: 6) result_2 = List(1-a, 1-b, 2-a, 2-b)
end main

=========================================================================

If you write your own collection class and want to make it work with any type of for-comprehension,
you must write the above four methods and make them members of your collection class.  These
four methods must have signatures corresponding to the method definitions shown here.

abstract class CustomCollectionClass[A]
{
  def flatMap[B](func: A => CustomCollectionClass[B]):CustomCollectionClass[B]
  def map[B](func: A => B):CustomCollectionClass[B]
  def withFilter(func: A => Boolean):CustomCollectionClass[A]
  def foreach(func: A => Unit):Unit
}

==========================================================
==========================================================
==========================================================

A "for loop" in Scala is known as a "for comprehension."
A "for comprehension" contains these two sections.

1) The first section of a "for comprehension" contains the
   generator, which is designated by the '<-' symbol and can
   be contained between a pair of parenthesis (), or between
   a pair of curly braces {}.  This section of the "for
   comprehension" can also contain an optional filter, which
   is designated by an 'if' statement.

2) The second section of a "for comprehension" contains the code
   that executes with each iteration of the "for comprehension".
   If this section contains more than one line of code, that code
   must be contained between a pair of curly braces {}.

The following code sample shows how to construct a
"for comprehension" that...

  * Uses a generator (the '<-' symbol).
  * Uses curly braces {} and parenthesis () interchangeably.
  * Uses a filter (an 'if' statement).
   
@main def main():Unit =
  val intList:List[Int] = List(1, 2, 3)
  var result:String = ""

  for (x <- intList)
    print(s"x = $x, ") // PRINTS: x = 1, x = 2, x = 3,
  println

  for (x <- intList; if (x > 1); if (x < 3)) {
    result = s"result = $x"
    print(result) // PRINTS: result = 2
  }
  println

  for {x <- intList; if (x > 2)} {
    result = s"result = $x"
    print(result) // PRINTS: result = 3
  }
end main



For loops/comprehensions in Scala can be written the standard way
by iterating over a collection using a for loop.  The result
generated by the for loop can also be obtained by replacing
the for loop with a call to the collection's flatMap method,
as shown in the following examples.

===================================================================
@main def main():Unit =
  val intList:List[Int]   = List(1, 2, 3)
  val charList:List[Char] = List('a', 'b')

  // Using a for loop, print the paired values of intList and charList.
  val forLoopResult:List[String] = for {
    number:Int <- intList  // this generator will be a flatMap
    char:Char  <- charList // this generator will be a map inside the flatMap
  } yield s"$number-$char"
  println(s"forLoopResult = $forLoopResult")
  // PRINTS: forLoopResult = List(1-a, 1-b, 2-a, 2-b, 3-a, 3-b)

  // The following code invokes the flatMap method to obtain
  // the same result as the above for loop.
  val flatMapResult:List[String] =
    intList.flatMap((number:Int) => charList.map((char:Char) => s"$number-$char"))
  println(s"flatMapResult = $flatMapResult")
  // PRINTS: flatMapResult = List(1-a, 1-b, 2-a, 2-b, 3-a, 3-b)
end main

===================================================================

The map() function is available on many Scala collections.  The following
program demonstrates a custom map() function that also works on Scala
collections; where this custom map() implements a for comprehension.

@main def main():Unit =
  /**
   * Return the length of the String passed to this method.
   */
  def strLengthFunc(str: String): Int = str.length

  /**
   * Double the number passed to this doubleIntFunc function,
   * and return it.
   */
  def doubleIntFunc(intNumber:Int):Int = intNumber * 2

  /**
   * This custom map function replicates the behavior of Scala's
   * List.map function.
   * @param func - A Scala function accepts an argument of type B,
   *               and returns the type A.
   * @param xs - A Scala List of type B
   *
   * @return - A Scala List of type A
   */
  def map[A, B](func:B => A, xs:List[B]):List[A] =
    for x <- xs yield func(x)
  end map

  var intList:List[Int] = map(doubleIntFunc, List(1, 2, 3))
  println(s"1) intList = $intList") // PRINTS: 1) intList = List(2, 4, 6)

  intList = map(strLengthFunc, List("zzzzz", "yyyy", "xxx"))
  println(s"2) intList = $intList") // PRINTS: 2) intList = List(5, 4, 3)
end main

===================================================================
