OPTION
======
In Scala, an Option data type is a container that can store any data type.
Unlike other containers, an Option can store either one value, or no value
(never multiple values).

When an Option contains a single value, that value is wrapped inside the scala.Some class.
When an Option contains no value, that value becomes the scala.None object (instead of a null).
Therefore, every instance of scala.Option will be one of the following values:

   * scala.Some  (A Scala class that extends the class:  Option[A])
   * scala.None  (A Scala object that extends the class: Option[Nothing])

The following program demonstrates:
   * Option(54321) and Some(54321) are equivalent expressions.
   * None and Option.empty are equivalent expressions.
---------------------------------------------------------------------------------------------------
@main def main() =
  val number_1:Option[Int] = Option(54321)
  val number_2:Some[Int]   = Some(54321)
  val number_3:Option[Int] = None
  val number_4:Option[Int] = Option.empty

  if (number_1 == number_2)
  then println("number_1 == number_2") // PRINTS: number_1 == number_2
  number_2 match
    case number_1 => println("number_2 == number_1") // PRINTS: number_2 == number_1
    case _        => println("number_2 != number_1") // This line never executes.


  if (number_3 == number_4)
  then println("number_3 == number_4") // PRINTS: number_3 == number_4
  number_4 match
    case number_3 => println("number_4 == number_3") // PRINTS: number_4 == number_3
    case _        => println("number_4 != number_3") // This line never executes.
end main
---------------------------------------------------------------------------------------------------

Using the Scala Option type can prevent null pointer exceptions from occurring by explicitly
representing the presence, or absence, of a value.

* When an Option instance has a value, it is assigned the scala.Some value.
* When an Option instance has no value, it is assigned the scala.None value, instead of null.

An Option class has behavior similar to a Scala List because you can invoke
the following methods on an Option, as you can a List.

* collect()                           * forAll()
* contains()                          * forEach()
* exists()                            * isEmpty()
* filter()                            * map()
* flatMap()                           * toList()
* flatten()                           * zip(), unzip()
* fold(), foldLeft(), foldRight()

But unlike a List (which can store multiple values), an Option will have either a scala.Some
value, or it'll have the scala.None value (instead of a null value).  The reason why an
Option has behaviors similar to a List is so the programmer can traverse through multiple
different Option values in one swoop, as in a "for comprehension", as can be done with a List.

When all Option values returned by a "for comprehension" have a scala.Some value, then
there are no "exceptions", and normal processing can continue.

When any Option value returned by a "for comprehension" has a scala.None value, then
an "exception" has occurred, and your code must address that exception.

---------------------------------------------------------------------------------------------------
@main def main() =
  val combinedLists =
  for { num <- List(1, 2, 3)
        char <- List('A', 'B')
      } yield s"$num-$char"
  combinedLists.foreach(println)
  // PRINTS: 1-A
  //         1-B
  //         2-A
  //         2-B
  //         3-A
  //         3-B


  val combinedOptions =
  for {num <- Option(1, 2, 3)
       char <- Option('A', 'B')
      } yield s"$num-$char"
  combinedOptions.foreach(println) // PRINTS: (1,2,3)-(A,B)
end main
---------------------------------------------------------------------------------------------------
