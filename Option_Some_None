OPTION
======
A collection class is used to store multiple values, like the List,
ArrayBuffer, and Vector classes.  Although the Option class is a
collection class, it cannot store multiple values!  The Option class
can store either no value, or a single value.

The Option class is used to store values that have the possibility of
being invalid.  For example, if a for-comprehension, or a method call,
has the possibility of returning an invalid value, a val/var of type
Option should be declared and used to receive that value.

If an Option class represents a VALID value x, it's stored as Some(x);
where x is the value wrapped in the Some class.

If an Option class represents an INVALID or non-existent value,
its value is set to None.

To sum up, every instance of the scala.Option class will reference
one of the following:

   * scala.Some(x)  (Represents the valid value x.)
   * scala.None     (Represents an invalid or non-existent value.)

==================================================================
The following program demonstrates how to use, and how not use,
the Scala Option and Some classes.

@main def main():Unit =
  // The following line of code demonstrates that a Scala List
  // class can contain multiple elements.  But if you uncomment
  // the next line of code, the program won't compile because
  // an Option class can't contain more than one element!
  val intList:List[Int] = List(123, 456)
  // val wont_Compile:Option[Int] = Option(123, 456)  // WON'T COMPILE!

  // The scala.Some class is used to store valid values.  Therefore,
  // it would make no sense to wrap a null value (or any invalid value)
  // inside the scala.Some class, like this...
  val someNull:Some[Null] = Some(null)  // NEVER do this!!!
  println(s"1) someNull = $someNull") // PRINTS: 1) someNull = Some(null)

  // Instead of wrapping values in the Some class, wrap them in
  // the Option class.  A value wrapped in an Option class always
  // evaluates to a Some value (if it's valid), or a None value
  // (if it's invalid).
  val someOption:Option[Null] = Option(null)
  println(s"2) someOption = $someOption") // PRINTS: 2) someOption = None

  // This demonstrates that wrapping a valid value in the Option class
  // returns that valid value wrapped in the Some class.
  var optionFloat:Option[Float] = Option(-123.987F)
  println(s"3) optionFloat = $optionFloat") // PRINTS: 3) optionFloat = Some(-123.987)

  // This demonstrates that you can assign a Some value to an Option type.
  optionFloat = Some(987.123F)
  println(s"4) optionFloat = $optionFloat") // PRINTS: 4) optionFloat = Some(987.123)
end main

==================================================================

The following code show some examples of how to use the Option
class for error handling.

==================================================================
@main def main():Unit =
  // The following code demonstrates the 3 possible ways
  // to assign a value of type Option[Int] to a val/var.
  // NOTICE: Option(intNumber) = Some(intNumber)
  val intNumber:Int           = 123
  val intOption_1:Option[Int] = Option(intNumber)
  val intOption_2:Option[Int] = Some(intNumber)
  val intOption_3:Option[Int] = None
  println(s"1) intOption_1 = $intOption_1, intOption_2 = $intOption_2, intOption_3 = $intOption_3")
  // PRINTS: 1) intOption_1 = Some(123), intOption_2 = Some(123), intOption_3 = None

  if (intOption_1 == intOption_2) {
    println(s"2) intOption_1 = intOption_2 = $intOption_2")
  } // PRINTS:2) intOption_1 = intOption_2 = Some(123)


  // *************************************************************
  // Option.getOrElse
  // Returns the Option's value if the Option is nonempty;
  // otherwise, return the result of evaluating default.
  var userName_1:Option[String]  = None
  var userName_2:Option[String]  = Some("Joe Blow")
  var userName_3:Option[String]  = Some("Last Choice")
  var stringResult:String = userName_1.getOrElse("J. Doe")
  println(s"3) stringResult = $stringResult") // PRINTS: 3) stringResult = J. Doe

  stringResult = userName_2.getOrElse("J. Doe")
  println(s"4) stringResult = $stringResult") // PRINTS: 4) stringResult = Joe Blow

  // ************************************************************
  // Option.orElse
  // Return the scala.Option class if it's nonempty; otherwise,
  // return the result of evaluating the alternative(s) specified
  // in this call to Option.orElse.
  var optionResult:Option[String] = userName_1.orElse(userName_2).orElse(userName_3)
  println(s"5) optionResult = $optionResult") // PRINTS: 5) optionResult = Some(Joe Blow)

  userName_2 = None // Reset userName_2 to observe that Option.orElse returns a new value.
  optionResult = userName_1.orElse(userName_2).orElse(userName_3)
  println(s"6) optionResult = $optionResult") // PRINTS: 6) optionResult = Some(Last Choice)

  // ***************************************************************
  // Option.flatMap
  // Use Option.flatMap when the function you want to apply returns
  // an Option itself.  This prevents nested Option[Option[T]]
  // results.
  case class User(id: Int, email: Option[String])
  def findUser(id:Int):Option[User] =
    // If the id argument passed to this method equals one (1),
    // this method will return an Option of type User, which
    // is defined via the case class above.  Otherwise, None
    // will be returned.
    id match { case 1 => Some(User(id, Some("alice@example.com")))
               case _ => None }

  var userEmail:Option[String] = findUser(1).flatMap(_.email)
  println(s"7) userEmail = $userEmail") // PRINTS: 7) userEmail = Some(alice@example.com)

  userEmail = findUser(2).flatMap(_.email)
  println(s"8) userEmail = $userEmail") // PRINTS: 8) userEmail = None
end main
==================================================================


The following program demonstrates how to nest multiple Option values inside
a single "for comprehension" and yield a result.

When all Option values obtained within a "for expression" return
the scala.Some type, then the entire "for expression" will return the
scala.Some type.  This is shown in the first "for expression" below.

When any Option value obtained within a "for expression" returns the
scala.None type, then the entire "for expression" will return the
scala.None type.  This is shown in the second "for expression" below.

Read in-line comments for details.

---------------------------------------------------------------------------------------------------
// NOTICE: This method can return a null value.
def positiveIntToString(number:Int):String =
  if (number >= 0)
    number.toString
  else null
end positiveIntToString

// ***********************************
// main()
@main def main() =
  // When all numbers passed to the positiveIntToString method are positive,
  // as shown here, combinedResult will be assigned the scala.Some value:
  var combinedResult:Option[String] =
  for
    value_1 <- Option(positiveIntToString(1))
    value_2 <- Option(positiveIntToString(2))
    value_3 <- Option(positiveIntToString(3))
    value_4 <- Option(positiveIntToString(4))
  yield value_1.toUpperCase + ", " + value_2.toUpperCase + ", "  + value_3.toUpperCase +  ", "  + value_4.toUpperCase

  println(s"1) combinedResult = $combinedResult") // PRINTS: 1) combinedResult = Some(1, 2, 3, 4)
  var finalResult:String = combinedResult.getOrElse("ERROR: Negative numbers are invalid.")
  println(s"2) finalResult = $finalResult")       // PRINTS: 2) finalResult = 1, 2, 3, 4

  // When any number passed to the positiveIntToString method is negative,
  // as shown here, combinedResult will be assigned the scala.None value:
  combinedResult =
  for
    value_1 <- Option(positiveIntToString(1))
    value_2 <- Option(positiveIntToString(2))
    value_3 <- Option(positiveIntToString(3))
    value_4 <- Option(positiveIntToString(-77))
  yield value_1.toUpperCase + ", " + value_2.toUpperCase + ", "  + value_3.toUpperCase +  ", "  + value_4.toUpperCase

  println(s"3) combinedResult = $combinedResult") // PRINTS: 3) combinedResult = None
  finalResult = combinedResult.getOrElse("ERROR: Negative numbers are invalid.")
  println(s"4) finalResult = $finalResult")       // PRINTS: 4) finalResult = ERROR: Negative numbers are invalid.
end main
---------------------------------------------------------------------------------------------------

The following program demonstrates:
   * Option(54321) and Some(54321) are equivalent expressions.
   * None and Option.empty are equivalent expressions.

@main def main() =
  val number_1:Option[Int] = Option(54321)
  val number_2:Some[Int]   = Some(54321)
  val number_3:Option[Int] = None
  val number_4:Option[Int] = Option.empty

  if (number_1 == number_2)
  then println("number_1 == number_2") // PRINTS: number_1 == number_2
  number_2 match
    case number_1 => println("number_2 == number_1") // PRINTS: number_2 == number_1
    case _        => println("number_2 != number_1") // This line never executes.


  if (number_3 == number_4)
  then println("number_3 == number_4") // PRINTS: number_3 == number_4
  number_4 match
    case number_3 => println("number_4 == number_3") // PRINTS: number_4 == number_3
    case _        => println("number_4 != number_3") // This line never executes.
end main
---------------------------------------------------------------------------------------------------

Using the Scala Option type can prevent null pointer exceptions from occurring by explicitly
representing the presence, or absence, of a value.

* When an Option instance has a value, it is assigned the scala.Some value.
* When an Option instance has no value, it is assigned the scala.None value, instead of null.

An Option class has behavior similar to a Scala List because you can invoke
the following methods on an Option, as you can a List.

* collect()                           * forAll()
* contains()                          * forEach()
* exists()                            * isEmpty()
* filter()                            * map()
* flatMap()                           * toList()
* flatten()                           * zip(), unzip()
* fold(), foldLeft(), foldRight()

But unlike a List (which can store multiple values), an Option val/var can store either
a scala.Some value, or it'll store the scala.None value (in place of a null value).
The reason why an Option has behaviors similar to a List is so the programmer can
traverse through multiple different Option values in one swoop; just as a
"for comprehension" can do with a List.

When all Option values returned by a "for comprehension" have a scala.Some value,
then there are no "exceptions", and normal processing can continue.

When a "for comprehension" returns an Option value of scala.None,
then an "exception" has occurred and your code must deal with it.

---------------------------------------------------------------------------------------------------
@main def main() =
  val combinedLists =
    for
      num <- List(1, 2, 3)
      char <- List('A', 'B')
    yield s"$num-$char"
  combinedLists.foreach(println)
  // PRINTS: 1-A
  //         1-B
  //         2-A
  //         2-B
  //         3-A
  //         3-B
  val combinedOptions =
    for
      num <- Option(1, 2, 3)
      char <- Option('A', 'B')
    yield s"$num-$char"
  combinedOptions.foreach(println) // PRINTS: (1,2,3)-(A,B)
end main
---------------------------------------------------------------------------------------------------

Read the in-line comments in the following program to understand
more Option behavior.

---------------------------------------------------------------------------------------------------
@main def main() =
  // ****************************************************************
  // This section:
  // 1) Assigns the scala.None value to an Option value.
  // 2) Assigns the scala.Some value to an Option value.
  var name:Option[String] = None
  var result:String       = name.getOrElse("Unknown")
  println(result) // PRINTS: Unknown

  name   = Some("Joe")
  result = name.getOrElse("Unknown")
  println(result) // PRINTS: Joe
  // ****************************************************************

  // ****************************************************************
  // This section shows the Option class has many of the same
  // methods that the List class posseses.
  val upperName:Option[String] = name.map(_.toUpperCase)
  println(upperName)      // PRINTS: Some(JOE)
  println(name.isEmpty)   // PRINTS: false
  println(name.isDefined) // PRINTS: true

  val longName:Option[String] = name.filter(_.length > 5)
  println(longName) // PRINTS: None
// ****************************************************************
end main
---------------------------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------
case class User(name: String, age: Int)

def findUser(id: Int): Option[User] =
  // Simulate a database lookup.
  if      (id == 1) Some(User("Alice", 19))
  else if (id == 2) Some(User("Joe",   18))
  else if (id == 3) Some(User("Sally", 17))
  else None
end findUser

def getAge(user: User): Option[Int] =
  if (user.age >= 18) Some(user.age) else None
end getAge

// findUser(0) returns: None (Because no user has an id = 0)
var userAge:Option[Int] =
for
  user <- findUser(0)
  age  <- getAge(user)
yield age

@main def main() =
  println(userAge) // PRINTS:  None

  userAge =
  for
    user <- findUser(1)
    age  <- getAge(user)
  yield age
  println(userAge) // PRINTS: Some(19)

  userAge =
  for
    user <- findUser(2)
    age  <- getAge(user)
  yield age
  println(userAge) // PRINTS: Some(18)

  userAge =
  for
    user <- findUser(3)
    age  <- getAge(user)
  yield age
  println(userAge) // PRINTS: None  (Because age < 18)
end main
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------

