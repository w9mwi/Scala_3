OPTION CLASS
============
A collection class is used to store multiple values.  The Scala List class,
ArrayBuffer class, and Vector are examples of Scala collection classes.
The Scala Option class is also a collection class.  But unlike other collections,
the Option class cannot store multiple elements of data!  The Option class can
hold no more than one element, so it can store no more than a single value.

All Scala collection classes (including the Option class) can be traversed using
a Scala for-comprehension.  Although the Scala Option class can store no more
than one element of data, the Option class is used within Scala for-comprehensions
to automatically detect errors, so the programmer doesn't have to write that code.
Here's how it works...

Assume you have declared three vals of type Option to store three separate values
that have a possibility of being valid or invalid.  When those three Option
classes are traversed via for-comprehension, 




The Option class is used to store values that have the possibility of being invalid,
or non-existent.  For example, if a method call, or a for-comprehension, has the
possibility of returning an invalid/non-existent value, an Option val/var should
be declared used to receive that value.

If an Option class represents a VALID value x, it's stored as Some(x);
where x is the value wrapped in the Some class.

If an Option class represents an INVALID or non-existent value,
its value is set to None.

To sum up, every instance of the scala.Option class will reference
one of the following:

   * scala.Some(x)  (Represents the valid value x.)
   * scala.None     (Represents an invalid or non-existent value.)

==================================================================
The following program demonstrates how to use, and how not use,
the Scala Option and Some classes.

@main def main():Unit =
  // The following line of code demonstrates that a Scala List
  // class can contain multiple elements.  But if you uncomment
  // the next line of code, the program won't compile because
  // an Option class can't contain more than one element!
  val intList:List[Int] = List(123, 456)
  // val wont_Compile:Option[Int] = Option(123, 456)  // WON'T COMPILE!

  // The scala.Some class is used to store valid values.  Therefore,
  // it would make no sense to wrap a null value (or any invalid value)
  // inside the scala.Some class, like this...
  val someNull:Some[Null] = Some(null)  // NEVER do this!!!
  println(s"1) someNull = $someNull") // PRINTS: 1) someNull = Some(null)

  // Instead of wrapping values in the Some class, wrap them in
  // the Option class.  A value wrapped in an Option class always
  // evaluates to a Some value (if it's valid), or a None value
  // (if it's invalid).
  val someOption:Option[Null] = Option(null)
  println(s"2) someOption = $someOption") // PRINTS: 2) someOption = None

  // This demonstrates that wrapping a valid value in the Option class
  // returns that valid value wrapped in the Some class.
  var optionFloat:Option[Float] = Option(-123.987F)
  println(s"3) optionFloat = $optionFloat") // PRINTS: 3) optionFloat = Some(-123.987)

  // This demonstrates that you can assign a Some value to an Option type.
  optionFloat = Some(987.123F)
  println(s"4) optionFloat = $optionFloat") // PRINTS: 4) optionFloat = Some(987.123)
end main

==================================================================

The following code show some examples of how to use the Option
class for error handling.

==================================================================
@main def main():Unit =
  // The following code demonstrates the 3 possible ways
  // to assign a value of type Option[Int] to a val/var.
  // NOTICE: Option(intNumber) = Some(intNumber)
  val intNumber:Int           = 123
  val intOption_1:Option[Int] = Option(intNumber)
  val intOption_2:Option[Int] = Some(intNumber)
  val intOption_3:Option[Int] = None
  println(s"1) intOption_1 = $intOption_1, intOption_2 = $intOption_2, intOption_3 = $intOption_3")
  // PRINTS: 1) intOption_1 = Some(123), intOption_2 = Some(123), intOption_3 = None

  if (intOption_1 == intOption_2) {
    println(s"2) intOption_1 = intOption_2 = $intOption_2")
  } // PRINTS:2) intOption_1 = intOption_2 = Some(123)


  // *************************************************************
  // Option.getOrElse
  // Returns the Option's value if the Option is nonempty;
  // otherwise, return the result of evaluating default.
  var userName_1:Option[String]  = None
  var userName_2:Option[String]  = Some("Joe Blow")
  var userName_3:Option[String]  = Some("Last Choice")
  var stringResult:String = userName_1.getOrElse("J. Doe")
  println(s"3) stringResult = $stringResult") // PRINTS: 3) stringResult = J. Doe

  stringResult = userName_2.getOrElse("J. Doe")
  println(s"4) stringResult = $stringResult") // PRINTS: 4) stringResult = Joe Blow

  // ************************************************************
  // Option.orElse
  // Return the scala.Option class if it's nonempty; otherwise,
  // return the result of evaluating the alternative(s) specified
  // in this call to Option.orElse.
  var optionResult:Option[String] = userName_1.orElse(userName_2).orElse(userName_3)
  println(s"5) optionResult = $optionResult") // PRINTS: 5) optionResult = Some(Joe Blow)

  userName_2 = None // Reset userName_2 to observe that Option.orElse returns a new value.
  optionResult = userName_1.orElse(userName_2).orElse(userName_3)
  println(s"6) optionResult = $optionResult") // PRINTS: 6) optionResult = Some(Last Choice)

  // ***************************************************************
  // Option.flatMap
  // Use Option.flatMap when the function you want to apply returns
  // an Option itself.  This prevents nested Option[Option[T]]
  // results.
  case class User(id: Int, email: Option[String])
  def findUser(id:Int):Option[User] =
    // If the id argument passed to this method equals one (1),
    // this method will return an Option of type User, which
    // is defined via the case class above.  Otherwise, None
    // will be returned.
    id match { case 1 => Some(User(id, Some("alice@example.com")))
               case _ => None }

  var userEmail:Option[String] = findUser(1).flatMap(_.email)
  println(s"7) userEmail = $userEmail") // PRINTS: 7) userEmail = Some(alice@example.com)

  userEmail = findUser(2).flatMap(_.email)
  println(s"8) userEmail = $userEmail") // PRINTS: 8) userEmail = None
end main
==================================================================
