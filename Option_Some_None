OPTION
======
In Scala, an Option data type is a container that can store any data type.
Unlike other containers, an Option can store either one value, or no value
(never multiple values).

When an Option contains a single value, that value is wrapped inside the scala.Some class.
When an Option contains no value, that value becomes the scala.None object (instead of a null).
Therefore, every instance of scala.Option will be one of the following values:

   * scala.Some  (A Scala class that extends the class:  Option[A])
   * scala.None  (A Scala object that extends the class: Option[Nothing])

The following program demonstrates:
   * Option(54321) and Some(54321) are equivalent expressions.
   * None and Option.empty are equivalent expressions.
---------------------------------------------------------------------------------------------------
@main def main() =
  val number_1:Option[Int] = Option(54321)
  val number_2:Some[Int]   = Some(54321)
  val number_3:Option[Int] = None
  val number_4:Option[Int] = Option.empty

  if (number_1 == number_2)
  then println("number_1 == number_2") // PRINTS: number_1 == number_2
  number_2 match
    case number_1 => println("number_2 == number_1") // PRINTS: number_2 == number_1
    case _        => println("number_2 != number_1") // This line never executes.


  if (number_3 == number_4)
  then println("number_3 == number_4") // PRINTS: number_3 == number_4
  number_4 match
    case number_3 => println("number_4 == number_3") // PRINTS: number_4 == number_3
    case _        => println("number_4 != number_3") // This line never executes.
end main
---------------------------------------------------------------------------------------------------

Using the Scala Option type can prevent null pointer exceptions from occurring by explicitly
representing the presence, or absence, of a value.

* When an Option instance has a value, it is assigned the scala.Some value.
* When an Option instance has no value, it is assigned the scala.None value, instead of null.

An Option class has behavior similar to a Scala List because you can invoke
the following methods on an Option, as you can a List.

* collect()                           * forAll()
* contains()                          * forEach()
* exists()                            * isEmpty()
* filter()                            * map()
* flatMap()                           * toList()
* flatten()                           * zip(), unzip()
* fold(), foldLeft(), foldRight()

But unlike a List (which can store multiple values), an Option val/var can store either
a scala.Some value, or it'll store the scala.None value (in place of a null value).
The reason why an Option has behaviors similar to a List is so the programmer can
traverse through multiple different Option values in one swoop; just as a
"for comprehension" can do with a List.

When all Option values returned by a "for comprehension" have a scala.Some value,
then there are no "exceptions", and normal processing can continue.

When a "for comprehension" returns an Option value of scala.None,
then an "exception" has occurred and your code must deal with it.

---------------------------------------------------------------------------------------------------
@main def main() =
  val combinedLists =
  for { num <- List(1, 2, 3)
        char <- List('A', 'B')
      } yield s"$num-$char"
  combinedLists.foreach(println)
  // PRINTS: 1-A
  //         1-B
  //         2-A
  //         2-B
  //         3-A
  //         3-B


  val combinedOptions =
  for {num <- Option(1, 2, 3)
       char <- Option('A', 'B')
      } yield s"$num-$char"
  combinedOptions.foreach(println) // PRINTS: (1,2,3)-(A,B)
end main
---------------------------------------------------------------------------------------------------

Read the in-line comments in the following program to understand
more Option behavior.
---------------------------------------------------------------------------------------------------
@main def main() =
  // ****************************************************************
  // This section:
  // 1) Assigns the scala.None value to an Option value.
  // 2) Assigns the scala.Some value to an Option value.
  var name:Option[String] = None
  var result:String       = name.getOrElse("Unknown")
  println(result) // PRINTS: Unknown

  name   = Some("Joe")
  result = name.getOrElse("Unknown")
  println(result) // PRINTS: Joe
  // ****************************************************************


  // ****************************************************************
  // This section shows the Option class has many of the same
  // methods that the List class posseses.
  val upperName:Option[String] = name.map(_.toUpperCase)
  println(upperName)      // PRINTS: Some(JOE)
  println(name.isEmpty)   // PRINTS: false
  println(name.isDefined) // PRINTS: true

  val longName:Option[String] = name.filter(_.length > 5)
  println(longName) // PRINTS: None
// ****************************************************************
end main
---------------------------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------
case class User(name: String, age: Int)

def findUser(id: Int): Option[User] =
  // Simulate a database lookup.
  if      (id == 1) Some(User("Alice", 19))
  else if (id == 2) Some(User("Joe",   18))
  else if (id == 3) Some(User("Sally", 17))
  else None
end findUser

def getAge(user: User): Option[Int] =
  if (user.age >= 18) Some(user.age) else None
end getAge

// findUser(0) returns: None (Because no user has an id = 0)
var userAge:Option[Int] = for { user <- findUser(0)
                                age  <- getAge(user)
                              } yield age
end userAge

@main def main() =
  println(userAge) // PRINTS:  None

  userAge = for { user <- findUser(1)
                  age  <- getAge(user)
                } yield age
  println(userAge) // PRINTS: Some(19)

  userAge = for { user <- findUser(2)
                  age  <- getAge(user)
                } yield age
  println(userAge) // PRINTS: Some(18)

  userAge = for { user <- findUser(3)
                  age  <- getAge(user)
                } yield age
  println(userAge) // PRINTS: None  (Because age < 18)
end main
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------

