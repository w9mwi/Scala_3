OPTION CLASS
============
A collection class is used to store multiple values.  The Scala List class,
ArrayBuffer class, and Vector are examples of Scala collection classes.
The Scala Option class is also a collection class.  But unlike other collections,
the Option class cannot store multiple elements of data!  The Option class can
hold no more than one element, so it can store no more than a single value.

The Option class is used to store values that have the possibility of being valid or
invalid.  For example, if a for-comprehension has the possibility of returning an
invalid/non-existent value, that value should be declared as type Option.

If an Option class represents a VALID value x, it will be stored in the Option class
as Some(x); where x is a valid value, wrapped in the Some class.

If an Option class represents an INVALID or non-existent value, its value is None.

To sum up, every instance of the scala.Option class will reference
one of the following:

   * scala.Some(x)  (Represents the valid value x wrapped in the Some class.)
   * scala.None     (Represents an invalid or non-existent value.)

QUESTION:
Why should the Option class be used to obtain values that have the possibility
of being invalid?

ANSWER:
Because the Option class is a collection class, it works with for-comprehensions.
(This means you can "loop through" all elements in an Option class with a
for-comprehension, even though the Option class can store only one element.)
Use the Option class's for-comprehension to the value of the Option class
because the for-comprehension transforms valid values into the value Some(x),
and it transforms invalid values into the value None.  This prevents errors
like NullPointerExceptions from being generated.  It also prevents the
programmer from having to manually perform error checks on every value
that might be invalid.

See the two sample programs at the bottom of this web page.  They implement
the Option class to store values that may be invalid.
--> https://github.com/w9mwi/Scala_3/blob/main/For_Comprehensions

==================================================================
The following program demonstrates how to use, and how not use,
the Scala Option and Some classes.

@main def main():Unit =
  // The following line of code demonstrates that a Scala List
  // class can contain multiple elements.  But if you uncomment
  // the next line of code, the program won't compile because
  // an Option class can't contain more than one element!
  val intList:List[Int] = List(123, 456)
  // val wont_Compile:Option[Int] = Option(123, 456)  // WON'T COMPILE!

  // The scala.Some class is used to store valid values.  Therefore,
  // it would make no sense to wrap a null value (or any invalid value)
  // inside the scala.Some class, like this...
  val someNull:Some[Null] = Some(null)  // NEVER do this!!!
  println(s"1) someNull = $someNull") // PRINTS: 1) someNull = Some(null)

  // Instead of wrapping values in the Some class, wrap them in
  // the Option class.  A value wrapped in an Option class always
  // evaluates to a Some value (if it's valid), or a None value
  // (if it's invalid).
  val someOption:Option[Null] = Option(null)
  println(s"2) someOption = $someOption") // PRINTS: 2) someOption = None

  // This demonstrates that wrapping a valid value in the Option class
  // returns that valid value wrapped in the Some class.
  var optionFloat:Option[Float] = Option(-123.987F)
  println(s"3) optionFloat = $optionFloat") // PRINTS: 3) optionFloat = Some(-123.987)

  // This demonstrates that you can assign a Some value to an Option type.
  optionFloat = Some(987.123F)
  println(s"4) optionFloat = $optionFloat") // PRINTS: 4) optionFloat = Some(987.123)
end main

==================================================================

The following code show some examples of how to use the Option
class for error handling.

==================================================================
@main def main():Unit =
  // The following code demonstrates the 3 possible ways
  // to assign a value of type Option[Int] to a val/var.
  // NOTICE: Option(intNumber) = Some(intNumber)
  val intNumber:Int           = 123
  val intOption_1:Option[Int] = Option(intNumber)
  val intOption_2:Option[Int] = Some(intNumber)
  val intOption_3:Option[Int] = None
  println(s"1) intOption_1 = $intOption_1, intOption_2 = $intOption_2, intOption_3 = $intOption_3")
  // PRINTS: 1) intOption_1 = Some(123), intOption_2 = Some(123), intOption_3 = None

  if (intOption_1 == intOption_2) {
    println(s"2) intOption_1 = intOption_2 = $intOption_2")
  } // PRINTS:2) intOption_1 = intOption_2 = Some(123)


  // *************************************************************
  // Option.getOrElse
  // Returns the Option's value if the Option is nonempty;
  // otherwise, return the result of evaluating default.
  var userName_1:Option[String]  = None
  var userName_2:Option[String]  = Some("Joe Blow")
  var userName_3:Option[String]  = Some("Last Choice")
  var stringResult:String = userName_1.getOrElse("J. Doe")
  println(s"3) stringResult = $stringResult") // PRINTS: 3) stringResult = J. Doe

  stringResult = userName_2.getOrElse("J. Doe")
  println(s"4) stringResult = $stringResult") // PRINTS: 4) stringResult = Joe Blow

  // ************************************************************
  // Option.orElse
  // Return the scala.Option class if it's nonempty; otherwise,
  // return the result of evaluating the alternative(s) specified
  // in this call to Option.orElse.
  var optionResult:Option[String] = userName_1.orElse(userName_2).orElse(userName_3)
  println(s"5) optionResult = $optionResult") // PRINTS: 5) optionResult = Some(Joe Blow)

  userName_2 = None // Reset userName_2 to observe that Option.orElse returns a new value.
  optionResult = userName_1.orElse(userName_2).orElse(userName_3)
  println(s"6) optionResult = $optionResult") // PRINTS: 6) optionResult = Some(Last Choice)

  // ***************************************************************
  // Option.flatMap
  // Use Option.flatMap when the function you want to apply returns
  // an Option itself.  This prevents nested Option[Option[T]]
  // results.
  case class User(id: Int, email: Option[String])
  def findUser(id:Int):Option[User] =
    // If the id argument passed to this method equals one (1),
    // this method will return an Option of type User, which
    // is defined via the case class above.  Otherwise, None
    // will be returned.
    id match { case 1 => Some(User(id, Some("alice@example.com")))
               case _ => None }

  var userEmail:Option[String] = findUser(1).flatMap(_.email)
  println(s"7) userEmail = $userEmail") // PRINTS: 7) userEmail = Some(alice@example.com)

  userEmail = findUser(2).flatMap(_.email)
  println(s"8) userEmail = $userEmail") // PRINTS: 8) userEmail = None
end main
==================================================================
