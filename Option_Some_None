OPTION
======
A collection class is used to store multiple values, like the List,
ArrayBuffer, and Vector classes.  Although the Option class is a
collection class, it cannot store multiple values!  The Option class
can store either no value, or a single value.

The Option class is used to store values that have the possibility of
being invalid.  For example, if a for-comprehension, or a method call,
has the possibility of returning an invalid value, a val/var of type
Option should be declared and used to receive that value.

If an Option class represents a VALID value x, it's stored as Some(x);
where x is the value wrapped in the Some class.

If an Option class represents an INVALID or non-existent value,
its value is set to None.

To sum up, every instance of the scala.Option class will reference
one of the following:

   * scala.Some(x)  (Represents the valid value x.)
   * scala.None     (Represents an invalid or non-existent value.)

==================================================================
The following program demonstrates how to use, and how not use,
the Scala Option and Some classes.

@main def main():Unit =
  // The following line of code demonstrates that a Scala List
  // class can contain multiple elements.  But if you uncomment
  // the next line of code, the program won't compile because
  // an Option class can't contain more than one element!
  val intList:List[Int] = List(123, 456)
  // val wont_Compile:Option[Int] = Option(123, 456)  // WON'T COMPILE!

  // The scala.Some class is used to store valid values.  Therefore,
  // it would make no sense to wrap a null value (or any invalid value)
  // inside the scala.Some class, like this...
  val someNull:Some[Null] = Some(null)  // NEVER do this!!!
  println(s"1) someNull = $someNull") // PRINTS: 1) someNull = Some(null)

  // Instead of wrapping values in the Some class, wrap them in
  // the Option class.  A value wrapped in an Option class always
  // evaluates to a Some value (if it's valid), or a None value
  // (if it's invalid).
  val someOption:Option[Null] = Option(null)
  println(s"2) someOption = $someOption") // PRINTS: 2) someOption = None

  // This demonstrates that wrapping a valid value in the Option class
  // returns that valid value wrapped in the Some class.
  var optionFloat:Option[Float] = Option(-123.987F)
  println(s"3) optionFloat = $optionFloat") // PRINTS: 3) optionFloat = Some(-123.987)

  // This demonstrates that you can assign a Some value to an Option type.
  optionFloat = Some(987.123F)
  println(s"4) optionFloat = $optionFloat") // PRINTS: 4) optionFloat = Some(987.123)
end main

==================================================================

The following code show some examples of how to use the Option
class for error handling.

==================================================================
@main def main():Unit =
  // The following code demonstrates the 3 possible ways
  // to assign a value of type Option[Int] to a val/var.
  // NOTICE: Option(intNumber) = Some(intNumber)
  val intNumber:Int           = 123
  val intOption_1:Option[Int] = Option(intNumber)
  val intOption_2:Option[Int] = Some(intNumber)
  val intOption_3:Option[Int] = None
  println(s"1) intOption_1 = $intOption_1, intOption_2 = $intOption_2, intOption_3 = $intOption_3")
  // PRINTS: 1) intOption_1 = Some(123), intOption_2 = Some(123), intOption_3 = None

  if (intOption_1 == intOption_2) {
    println(s"2) intOption_1 = intOption_2 = $intOption_2")
  } // PRINTS:2) intOption_1 = intOption_2 = Some(123)


  // *************************************************************
  // Option.getOrElse
  // Returns the Option's value if the Option is nonempty;
  // otherwise, return the result of evaluating default.
  var userName_1:Option[String]  = None
  var userName_2:Option[String]  = Some("Joe Blow")
  var userName_3:Option[String]  = Some("Last Choice")
  var stringResult:String = userName_1.getOrElse("J. Doe")
  println(s"3) stringResult = $stringResult") // PRINTS: 3) stringResult = J. Doe

  stringResult = userName_2.getOrElse("J. Doe")
  println(s"4) stringResult = $stringResult") // PRINTS: 4) stringResult = Joe Blow

  // ************************************************************
  // Option.orElse
  // Return the scala.Option class if it's nonempty; otherwise,
  // return the result of evaluating the alternative(s) specified
  // in this call to Option.orElse.
  var optionResult:Option[String] = userName_1.orElse(userName_2).orElse(userName_3)
  println(s"5) optionResult = $optionResult") // PRINTS: 5) optionResult = Some(Joe Blow)

  userName_2 = None // Reset userName_2 to observe that Option.orElse returns a new value.
  optionResult = userName_1.orElse(userName_2).orElse(userName_3)
  println(s"6) optionResult = $optionResult") // PRINTS: 6) optionResult = Some(Last Choice)

  // ***************************************************************
  // Option.flatMap
  // Use Option.flatMap when the function you want to apply returns
  // an Option itself.  This prevents nested Option[Option[T]]
  // results.
  case class User(id: Int, email: Option[String])
  def findUser(id:Int):Option[User] =
    // If the id argument passed to this method equals one (1),
    // this method will return an Option of type User, which
    // is defined via the case class above.  Otherwise, None
    // will be returned.
    id match { case 1 => Some(User(id, Some("alice@example.com")))
               case _ => None }

  var userEmail:Option[String] = findUser(1).flatMap(_.email)
  println(s"7) userEmail = $userEmail") // PRINTS: 7) userEmail = Some(alice@example.com)

  userEmail = findUser(2).flatMap(_.email)
  println(s"8) userEmail = $userEmail") // PRINTS: 8) userEmail = None
end main
==================================================================
