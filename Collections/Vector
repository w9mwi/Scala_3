VECTOR
======
The elements of an Array class are mutable.  Elements of the Vector class are
immutable.  So once a Vector is initialized, you can't change any of its elements.
A Vector inherits from the IndexedSeq trait, which means that accessing any of its
elements via an index is fast and efficient.

Use a Vector (instead of an Array) when you want an immutable collection that
can be accessed fast and efficiently via an index.

The following program demonstrates how various ArrayBuffer operators
and ArrayBuffer methods work.

===================================================================================

@main def main() =
  // Initialize a Vector
  var fruits_1:Vector[String] = Vector("apple", "banana", "cherry", "date")
  println(s"1) fruits_1 = $fruits_1")

  // Append elements
  fruits_1 = fruits_1 :+ "elderberry"
  println(s"2) fruits_1 = $fruits_1")

  // Prepend elements
  fruits_1 = "apricot" +: fruits_1
  println(s"3) fruits_1 = $fruits_1")

  // Concatenate Vectors
  var fruits_2:Vector[String] = Vector("fig", "grape")
  fruits_2 = fruits_1 ++ fruits_2
  println(s"4) fruits_2 = $fruits_2")

  // Access elements
  println(s"5) fruits_1(0) = ${fruits_1(0)}")
  println(s"6) fruits_1.last = ${fruits_1.last}")

  // Slice
  fruits_2 = fruits_1.slice(1, 3)
  println(s"7) fruits_1.slice(1, 3) $fruits_2")

  // Take and Drop
  println(s"8) fruits_1.take(2) = ${fruits_1.take(2)}")
  println(s"9) fruits_1.drop(2) = ${fruits_1.drop(2)}")

  // Map transformation
  fruits_2 = fruits_1.map(_.toUpperCase)
  println(s"10) fruits_2 =  = $fruits_2")

  // Filter
  fruits_2 = fruits_1.filter(_.length > 5)
  println(s"11) fruits_2 = $fruits_2")

  // foldLeft and foldRight
  // At this point in the code...
  // fruits_1 = Vector(apricot, apple, banana, cherry, date, elderberry)
  // foldLeft prints the first char of each fruit, from left to right (aabcde)
  // foldRight prints the first char of each fruit, from right to left (edcbaa)
  var fruitString:String = fruits_1.foldLeft("")((acc, fruit) => acc + fruit.charAt(0))
  println(s"12) fruitString = $fruitString")
  fruitString = fruits_1.foldRight("")((fruit, acc) => acc + fruit.charAt(0))
  println(s"13) fruitString = $fruitString")

  // Reduce
  fruitString = fruits_1.reduce((a, b) => if (a.length > b.length) a else b)
  println(s"14) fruitString = $fruitString")

  // Collect
  var fruits_3:Vector[Int] = fruits_1.collect { case f if f.length % 2 == 0 => f.length }
  println(s"15) fruits_3 = $fruits_3")

  // GroupBy
  var fruits_4:Map[Int, Vector[String]] = fruits_1.groupBy(_.length)
  println(s"16) fruits_4 = $fruits_4")

  // Zip
  var fruits_5:Vector[(String, Int)] = fruits_1.zip(Vector(1, 2, 3, 4))
  println(s"17) fruits_5 = $fruits_5")

  // Distinct
  fruits_2 = Vector("apple", "banana", "apple", "cherry", "banana")
  println(s"18) fruits_2 = ${fruits_2.distinct}")

  // Reverse
  println(s"19) fruits_1.reverse ${fruits_1.reverse}")

  // Contains
  println(s"20) fruits_1.contains(banana) = ${fruits_1.contains("banana")}")

  // IndexOf
  println(s"21) fruits_1.indexOf(cherry) = ${fruits_1.indexOf("cherry")}")

  // Head and Tail
  println(s"22) fruits_1.head = ${fruits_1.head},  fruits_1.tail = ${fruits_1.tail}")

  // IsEmpty
  println(s"23) fruits_1.isEmpty = ${fruits_1.isEmpty}")

  // Size
  println(s"24) fruits_1.size = ${fruits_1.size}")
end main
