
Scala List elements should be accesssed by traversing the List from one
element to the next, using methods List.head, List.next, List.tail.
The time it takes to access the nth element of a List via an index
increases as n increases.  Never access List elements via an index,
like this...

  val intList:List[Int] = List(111, 222, 333, 444, 555)
  val mySlice = intList(4)  // Don't access Lists via an index!

Any operations that work with the end of a long List
(appending elements to a long list, etc.) should be
avoided because a List is inefficient at that.  A List
is efficient when you prepend elements to it, or access
it via the List's head and tail.

The following methods are all invoked on the Scala List class.  However, many
of these same-named methods also apply to other Scala collections, in an
analgous way.  Read the in-line comments.

===========================================================================

// *********************************
// BASIC LIST METHODS
// *********************************
@main def main():Unit =
  var intList:List[Int] = List(1, 2, 3, 4, 5)

  // drop METHOD ******************************************
  // Drop the first 3 elements of intList.
  println(s"1) intList.drop(3) = ${intList.drop(3)}")
  // PRINTS: 1) intList.drop(3) = List(4, 5)

  // init METHOD ******************************************
  // Don't confuse this init method with the inits method!
  // Return all elements of intList, except the last element.
  println(s"2) intList.init = ${intList.init}") // init(ial) = All elements except last.
  // PRINTS:2) intList.init = List(1, 2, 3, 4)

  // last METHOD ******************************************
  // Return the last element of intList.
  println(s"3) intList.last = ${intList.last}") // last element only.
  // PRINTS: 3) intList.last = 5


  // patch METHOD - PART 1 OF 2 *************************************
  // EXAMPLE: At index 0, insert List(999), and replace
  //          zero (0) elements from the existing intList.
  println(s"4) intList.patch(0, List(999), 0) = ${intList.patch(0, List(999), 0)}")
  // PRINTS: 4) intList.patch(0, List(999), 0) = List(999, 1, 2, 3, 4, 5)

  // EXAMPLE: At index 2, insert List(999), and replace
  //          one (1) element from the existing intList.
  println(s"5) intList.patch(2, List(999), 1) = ${intList.patch(2, List(999), 1)}")
  // PRINTS: 5) intList.patch(2, List(999), 3) = List(1, 2, 999)

  // EXAMPLE: At index 2, insert List(999), and replace
  //          two (2) elements from the existing intList.
  println(s"6) intList.patch(2, List(999), 2) = ${intList.patch(2, List(999), 2)}")
  // PRINTS: 6) intList.patch(2, List(999), 2) = List(1, 2, 999, 5)
  // *****************************************************************

  // *****************************************************************
  // patch METHOD - PART 2 OF 2
  val originalList = List(10, 20, 30, 40, 50, 60)
  println(s"7) Original List: $originalList")
  // PRINTS: 7) Original List: List(10, 20, 30, 40, 50, 60)

  // --- 1. Replacing a subsequence ---
  // Replace 2 elements starting from index 2 (which are 30, 40) with List(35, 45)
  val replacedList = originalList.patch(2, List(35, 45), 2)
  println(s"8) Replaced Subsequence: $replacedList")
  // PRINTS: 8) Replaced Subsequence: List(10, 20, 35, 45, 50, 60)

  // --- 2. Inserting elements ---
  // Insert List(25) at index 2 without removing any elements (n = 0)
  val insertedList = originalList.patch(2, List(25), 0)
  println(s"9) Inserted Elements: $insertedList")
  // PRINTS: 9) Inserted Elements: List(10, 20, 25, 30, 40, 50, 60)

  // --- 3. Removing elements ---
  // Remove 3 elements starting from index 1 (which are 20, 30, 40) with an empty list
  val removedList = originalList.patch(1, List(), 3) // List() = Seq.empty
  println(s"10) Removed Elements: $removedList")
  // PRINTS: 10) Removed Elements: List(10, 50, 60)

  // --- 4. Simulating an element update ---
  // Replace 1 element at index 0 (which is 10) with 5
  val updatedList = originalList.patch(0, List(5), 1)
  println(s"11) Updated Element: $updatedList")
  // PRINTS: 11) Updated Element: List(5, 20, 30, 40, 50, 60)
  // *****************************************************************

  // slice METHOD ******************************************
  // EXAMPLE: slice(startIdx, n)  - Returns charList from
  //          startIdx = 1 ('b') to index (n-1) = 2 ('c)
  val charList = List('A', 'B', 'C', 'D', 'E')
  println(s"12) charList.slice(1,3) = ${charList.slice(1,3) }")
  // PRINTS: 12) charList.slice(1,3) = List(B, C)

  // splitAt METHOD ******************************************
  // EXAMPLE: Split strList so it returns one List[String] made up
  //          from the elements contained at indices < 3; and another
  //          List[String] made up from all remaining elements.
  val strList:List[String] = List("id", "name", "email",
                                  "1", "Alice", "alice@example.com",
                                  "2", "Bob", "bob@example.com")
  val (header, records) = strList.splitAt(3)
  println(s"13) header = $header,   records = $records")
  // PRINTS: 13) header = List(id, name, email),   records = List(1, Alice, alice@example.com, 2, Bob, bob@example.com)

  // take METHOD ******************************************
  // The List.take method in Scala 3 returns a new List containing
  // the first n elements of the original list.  If the list has
  // fewer than n elements, it returns the entire list.
  println(s"14) intList.take(4) = ${intList.take(4)}")
  // PRINTS: 14) intList.take(4) = List(1, 2, 3, 4)

  // takeRight METHOD ******************************************
  // The List.takeRight method returns a new List containing
  // the first n elements of the original list.  If the list
  // has fewer than n elements, it returns the entire list.
  println(s"15) intList.takeRight(4) = ${intList.takeRight(4)}")
  // PRINTS: 15) intList.takeRight(4) = List(2, 3, 4, 5)
end main

===========================================================================

// *********************************
// BOOLEAN TESTS ON LIST METHODS
// *********************************
@main def main():Unit =
  val intList:List[Int] = List(111, 222, 333, 444, 555)
  val strList:List[String] = List[String]("str1_abc_junk", "str2_abc_stuff", "str3_qrs_things", "str4_xyz_trash")

  // contains METHOD ******************************************
  // Tests whether the List contains a given value as an element.
  println(s"1) intList.contains(666) = ${intList.contains(666)},  intList.contains(555) = ${intList.contains(555)}")
  // PRINTS: 1) intList.contains(666) = false,  intList.contains(555) = true
  println(s"""2) strList.contains(List("str1_abc_junk") = ${strList.contains(List("str1_abc_junk"))}""")
  // PRINTS: 2) strList.contains(List("str1_abc_junk") = false
  println(s"""3) strList.contains("str1_abc_junk") = ${strList.contains("str1_abc_junk")}""")
  // PRINTS: 3) strList.contains("str1_abc_junk") = true

  // dropWhile METHOD
  // NOTE: The following line drops all elements from
  //       strList containing the text "abc_".
  println(s"""4) strList.dropWhile(_.contains("abc_")) = ${strList.dropWhile(_.contains("abc_"))}""")
  // PRINTS: 4) strList.dropWhile(_.contains("abc_")) = List(str3_qrs_things, str4_xyz_trash)

  // endsWith  METHOD ******************************************
  println(s"5) intList.endsWith(List(444)) = ${intList.endsWith(List(444))},  intList.endsWith(List(555)) = ${intList.endsWith(List(555))}")
  // PRINTS: 5) intList.endsWith(List(444)) = false,  intList.endsWith(List(555)) = true

  // isInstanceOf METHOD ******************************************
  // WARNING: The val isStringList below has the value true, which is WRONG!
  //          The val isStringList below should be false because intList
  //          is of type List[Int], not of type List[String].  This error
  //          occurs due to "type erasure" occurring on the Java Virtual
  //          Machine (JVM), which is the runtime environment for Scala.
  //          When Scala code is compiled into JVM bytecode, the generic
  //          type parameters (like [Int] and [String]) are essentially
  //          "erased" at runtime.  So the JVM sees only the raw, non-generic
  //          type, which is List; not List[Int], or List[String], etc.
  val isIntArray:Boolean   = intList.isInstanceOf[Array[Int]]
  val isStringList:Boolean = intList.isInstanceOf[List[String]]
  val isIntList:Boolean    = intList.isInstanceOf[List[Int]]
  println(s"6) isIntArray = $isIntArray,  isStringList = $isStringList,  isIntList = $isIntList")
  // PRINTS: 6) isIntArray = false,  isStringList = true,  isIntList = true

  // asInstanceOf METHOD ******************************************
  // Used to cast one data type to another data type  This
  // code sample casts the type Int to the type Long.
  val intValue:Int   = 1234;
  val longValue:Long = intValue.asInstanceOf[Long]
  if (intValue.isInstanceOf[Int])
    println(s"7) intValue's data type = Int") // PRINTS: 7) intValue's data type = Int
  if (longValue.isInstanceOf[Long])
    println(s"8) longValue's data type = Long") // PRINTS: 8) longValue's data type = Long

  // startsWith METHOD ******************************************
  val strList1:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
  var strList2:List[String] = List("abc", "def")
  println(s"9) strList1.startsWith($strList2) = ${strList1.startsWith(strList2)}")
// PRINTS: 9) strList1.startsWith(List(abc, def)) = true
end main

===========================================================================

@main def main():Unit =
  // *********************************
  // SEARCHING LIST METHODS
  // *********************************

  // find METHOD ******************************************
  val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
  // Return the first element of intList having a value < 3.
  var result:Option[Int] = intList.find(_<6)
  println(s"1) result = $result") // Prints: 1) result = Some(4)
  // Return the first element of intList having a value > 7.
  result = intList.find(_>7)
  println(s"2) result = $result") // Prints: 2) result = Some(9)
  // Return the first element of intList having a value > 10.
  result = intList.find(_>10)
  println(s"3) result = $result") // Prints: 3) result = None

  // indexOf METHOD ******************************************
  val strList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "mno")
  // Return the index of the FIRST occurrence of "mno" in strList.
  var index:Int = strList.indexOf("mno")
  println(s"4) index = $index") // PRINTS: 4) index = 4

  // lastIndexOf METHOD ******************************************
  // Return the index of the LAST occurrence of "mno" in strList.
  index = strList.lastIndexOf("mno")
  println(s"5) index = $index") // PRINTS: 5) index = 5

  // diff METHOD ******************************************
  var strList_1:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
  var strList_2:List[String] = List("pqr", "mno", "jkl", "ghi", "def", "abc")
  var strList_3:List[String] = List("mno", "abc")
  var intList_1: List[Int] = List(111, 222, 333, 444, 222)
  var intList_2: List[Int] = List(111, 222)

  // Return all elements from strList_1 that are not contained in strList_2.
  // (All elements in strList_1 are contained in strList_2 so an empty list
  // is returned.)
  println(s"6) strList_1.diff(strList_2) = ${strList_1.diff(strList_2)}")
  // PRINTS: 6) strList_1.diff(strList_2) = List()

  // Return all elements from strList_1 that are not contained in strList_3.
  println(s"7) strList_1.diff(strList_3) = ${strList_1.diff(strList_3)}")
  // PRINTS: 7) strList_1.diff(strList_3) = List(def, ghi, jkl, pqr)

  // Return all elements from intList_1 that are not contained in intList_2.
  // NOTE: When intList_1 contains more than one element that's in intList_2,
  //       only the first occurrence of that element is removed from the
  //       result.  Therefore, only the first occurrence of 222 in strList_1
  //       is removed from the result, but not subsequent occurrences of 222.
  println(s"8) intList_1.diff(intList_2) = ${intList_1.diff(intList_2)}")
  // PRINTS: 8) intList_1.diff(intList_2) = List(333, 444, 222)

  // mkString METHOD ******************************************
  // See the toArray method below for more examples of mkString.
  println("9) strList.mkString = " + strList.mkString)
  // PRINTS: 9) strList.mkString = abcdefghijklmnomno
  println("10) strList.mkString(\" + \") = " + strList.mkString(" + "))
  // PRINTS: 10) strList.mkString(" + ") = abc + def + ghi + jkl + mno + mno
  println("11) strList.mkString(\"BEGIN\", \"_\", \"END\") = " + strList.mkString("BEGIN", "_", "END"))
  // PRINTS: 11) strList.mkString("BEGIN", "_", "END") = BEGINabc_def_ghi_jkl_mno_mnoEND

  // reverse METHOD ******************************************
  println("12) strList.reverse = " + strList.reverse)
  // PRINTS: 12) strList.reverse = List(pqr, mno, jkl, ghi, def, abc)

  // toArray METHOD ******************************************
  println(s"13) strList.toArray = ${strList.toArray}")
  // PRINTS: 13) strList.toArray = [Ljava.lang.String;@2133c8f8

  println(s"14) strList.toArray = ${strList.toArray.mkString}")
  // PRINTS: 14) strList.toArray = abcdefghijklmnopqr

  // NOTE: The following String argument is passed to mkString():
  //       1) The String separating each element of the result: " | "
  println(s"15) strList.toArray = ${strList.toArray.mkString(" | ")}")
  // PRINTS: 15) strList.toArray = abc | def | ghi | jkl | mno | pqr

  // NOTE: The following 3 String arguments are passed to mkString():
  //       1) The String prepended to the result:               "Array("
  //       2) The String separating each element of the result: ", "
  //       3) The String appended to the result:                ")"
  println(s"16) strList.toArray = ${strList.toArray.mkString("Array(", ", ", ")")}")
  // PRINTS: 16) strList.toArray = Array(abc, def, ghi, jkl, mno, pqr)

  // product METHOD ******************************************
  val floatList:List[Float] = List(123.4F, 456.7F, 78.9F)
  // 123.4 × 456.7 × 78.9 = 4446550.0
  println(s"17) floatList.product = ${floatList.product}")
  // PRINTS: 17) floatList.product = 4446550.0

  // sum METHOD ******************************************
  // 123.4 + 456.7 + 78.9 = 659
  println(s"18) floatList.sum = ${floatList.sum}")
  // PRINTS: 18) floatList.sum = 659.00006
end main

===========================================================================

The following sample code shows how to use these 4 List methods:

  1) List.zip
  2) List.unzip
  3) List.zipAll
  4) List.zipWithIndex

@main def main():Unit =
  type intTuple = (Int, Int)
  var intList_1:List[Int] = List(0, 123, 456, 789)
  var intList_2:List[Int] = List(789, 456, 123, 0)

  // ============================================================
  // Zip together two Lists of the same size, in both directions.
  var zippedList:List[intTuple] = intList_1.zip(intList_2)
  println(s"1) zippedList = $zippedList")
  // PRINTS: 1) zippedList = List((0,789), (123,456), (456,123), (789,0))

  zippedList = intList_2.zip(intList_1)
  println(s"2) zippedList = $zippedList")
  // PRINTS: 2) zippedList = List((789,0), (456,123), (123,456), (0,789))

  // ============================================================
  // When two Lists have different sizes, the zip method returns
  // a List having the same size as the smaller List; therefore,
  // some elements from the larger List won't be included in the
  // zippedList result.
  intList_1 = List(100, 200, 300, 400, 500)
  intList_2 = List(600, 700)
  zippedList = intList_1.zip(intList_2)
  println(s"3) zippedList = $zippedList")
  // PRINTS: 3) zippedList = List((100,600), (200,700))

  zippedList = intList_2.zip(intList_1)
  println(s"4) zippedList = $zippedList")
  // PRINTS: 4) zippedList = List((600,100), (700,200))

  // ============================================================
  // When two Lists have different sizes, the zipAll method
  // returns a List having the same size as the larger List.
  // Since intList_1 is larger than intList_2, the following
  // line of code includes the -2 value for each element returned
  // that exceeds the size of intList_2.
  zippedList = intList_1.zipAll(intList_2, -1, -2)
  println(s"5) zippedList = $zippedList")
  // PRINTS: 5) zippedList = List((100,600), (200,700), (300,-2), (400,-2), (500,-2))

  // Since intList_1 is larger than intList_2, the following
  // line of code includes the -1 value for each element returned
  // that exceeds the size of intList_2.
  zippedList = intList_2.zipAll(intList_1, -1, -2)
  println(s"6) zippedList = $zippedList")
  // PRINTS: 6) zippedList = List((600,100), (700,200), (-1,300), (-1,400), (-1,500))

  // ============================================================
  // The unzip method can be called on any List that has been
  // zipped, which means any List that contains a tuple pair
  // of Lists in each of its elements.  The unzip method returns
  // two Lists in a tuple pair, as shown here.
  println(s"7) zippedList.unzip = ${zippedList.unzip}")
  // PRINTS: 7) unzippedList = (List(600, 700, -1, -1, -1),List(100, 200, 300, 400, 500))

  // The List.zipWithIndex method returns a List of tuples for each element
  // in the List.  The first tuple element contains the value from the List;
  // and the second tuple element contains the index of that List value.
  val strList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
  val strListWithIndex:List[(String,Int)] = strList.zipWithIndex
  println(s"8) strListWithIndex = $strListWithIndex")
  // PRINTS: 8) strListWithIndex = List((abc,0), (def,1), (ghi,2), (jkl,3), (mno,4), (pqr,5))
  println(s"9) strListWithIndex(2)._1 = ${strListWithIndex(2)._1}, strListWithIndex(2)._2 = ${strListWithIndex(2)._2}")
  // PRINTS: 9) strListWithIndex(2)._1 = ghi, strListWithIndex(2)._2 = 2

  val unzipResult:(List[String], List[Int])= strListWithIndex.unzip
  println(s"10) unzipResult = $unzipResult")
  // PRINTS: 10) unzipResult = (List(abc, def, ghi, jkl, mno, pqr),List(0, 1, 2, 3, 4, 5))
end main

===========================================================================

// *********************************
// HIGHER-ORDER METHODS
// *********************************

@main def main():Unit =
  val intList:List[Int] = List(7, 4, 6, 3, 9, 1)
  var count = 0

  // combinations METHOD  ******************************************
  // Generate all possible 1-number combinations
  // using all Int values in intList.
  for (x <- intList.combinations(1))
  {
    count += 1
    println(s"$count) = $x")
    // PRINTS: 1) = List(7)
    //         2) = List(4)
    //         3) = List(6)
    //         4) = List(3)
    //         5) = List(9)
    //         6) = List(1)
  }

  // Generate all possible 2-number combinations
  // using all Int values in intList.
  count = 0
  for (x <- intList.combinations(2)) {
    count += 1
    println(s"$count) = $x ")
    // PRINTS: 1) = List(7, 4)
    //         2) = List(7, 6)
    //         3) = List(7, 3)
    //         4) = List(7, 9)
    //         5) = List(7, 1)
    //         6) = List(4, 6)
    //         7) = List(4, 3)
    //         8) = List(4, 9)
    //         9) = List(4, 1)
    //        10) = List(6, 3)
    //        11) = List(6, 9)
    //        12) = List(6, 1)
    //        13) = List(3, 9)
    //        14) = List(3, 1)
    //        15) = List(9, 1)
  }

  // Generate all possible 3-number combinations
  // using all Int values in intList.
  count = 0
  for (x <- intList.combinations(3))
  {
    count += 1
    println(s"$count) = $x ")
    // PRINTS: 1) = List(7, 4, 6)
    //         2) = List(7, 4, 3)
    //         3) = List(7, 4, 9)
    //         4) = List(7, 4, 1)
    //         5) = List(7, 6, 3)
    //         6) = List(7, 6, 9)
    //         7) = List(7, 6, 1)
    //         8) = List(7, 3, 9)
    //         9) = List(7, 3, 1)
    //        10) = List(7, 9, 1)
    //        11) = List(4, 6, 3)
    //        12) = List(4, 6, 9)
    //        13) = List(4, 6, 1)
    //        14) = List(4, 3, 9)
    //        15) = List(4, 3, 1)
    //        16) = List(4, 9, 1)
    //        17) = List(6, 3, 9)
    //        18) = List(6, 3, 1)
    //        19) = List(6, 9, 1)
    //        20) = List(3, 9, 1)
  }

  // permutations METHOD  ******************************************
  // Generate all possible permutations
  // using all Int elements in intList.
  count = 0
  for (x <- intList.permutations) {
    count += 1
    println(s"$count) $x")
    // PRINTS:
    // 1) List(7, 4, 6, 3, 9, 1)
    // 2) List(7, 4, 6, 3, 1, 9)
    // 3) List(7, 4, 6, 9, 3, 1)
    // 4) List(7, 4, 6, 9, 1, 3)
    // 5) List(7, 4, 6, 1, 3, 9)
    // ...
    // 716) List(1, 9, 3, 7, 6, 4)
    // 717) List(1, 9, 3, 4, 7, 6)
    // 718) List(1, 9, 3, 4, 6, 7)
    // 719) List(1, 9, 3, 6, 7, 4)
    // 720) List(1, 9, 3, 6, 4, 7)
  }
end main

===========================================================================

@main def main():Unit =
  // exists METHOD - PART 1 of 2 ******************************************
  val strList:List[String] = List[String]("str1_abc_junk", "str2_jkl_stuff", "str3_qrs_things", "str4_xyz_trash");
  println(s"""1) strList.exists(_.compareTo("str3_qrs_things") == 0) = ${strList.exists(_.compareTo("str3_qrs_things") == 0)}""")
  // PRINTS: 1) strList.exists(_.compareTo("str3_qrs_things") == 0) = true
  println(s"""2) strList.exists(_.compareTo("str3_qrs_thing") == 0) = ${strList.exists(_.compareTo("str3_qrs_thing") == 0)}""")
  // PRINTS: 2) strList.exists(_.compareTo("str3_qrs_thing") == 0) = false

  // exists METHOD - PART 2 of 2 ******************************************
  val intList:List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7);
  println(s"""3) intList.exists(x => x==7) = ${intList.exists(x => x==7)}""")
  // PRINTS: 3) intList.exists(x => x==7) = true
  println(s"""4) intList.exists(x => x>7) = ${intList.exists(x => x>7)}""")
  // PRINTS: 4) intList.exists(x => x>7) = false

  // filter METHOD ******************************************
  println(s"5) intList.filter(_ >= 6) = ${intList.filter(_ >= 6)}")
  // PRINTS: 5) intList.filter(_ >= 6) = List(6, 7)

  // The two println statements below show these two function calls return identical results:
  // 1) nameList.filter(_.startsWith("R"))
  // 2) nameList.filter(x => x.startsWith("R"))
  val nameList:List[String] = List("TJB", "Rosy", "Randy")
  println(s"""6) nameList.filter(_.startsWith("R")) = ${nameList.filter(_.startsWith("R"))}""")
  // PRINTS: 6) nameList.filter(_.startsWith("R")) = List(Rosy, Randy)
  println(s"""7) nameList.filter(x => x.startsWith("R")) = ${nameList.filter(x => x.startsWith("R"))}""")
  // PRINTS: 7) nameList.filter(x => x.startsWith("R")) = List(Rosy, Randy)

  // map METHOD ******************************************
  // Execute the function passed to the map method on all
  // elements of the collection, and return a new collection
  // containing those calculated values.
  println(s"8) intList.map(x => x*2) = ${intList.map(x => x*2)}")
  // PRINTS: 8) intList.map(x => x*2) = List(2, 4, 6, 8, 10, 12, 14)
  val listOfLists:List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
  println(s"9) listOfLists.flatten.map(_*2) = ${listOfLists.flatten.map(_ * 2)}")
  // PRINTS: 9) listOfLists.flatten.map(_*2) = List(2, 4, 6, 8, 10, 12, 14, 16, 18)
  println(s"10) nameList.map(_.toUpperCase) = ${nameList.map(_.toUpperCase)}")
  // PRINTS: 10) nameList.map(_.toUpperCase) = List(TJB, ROSY, RANDY)

  // flatten METHOD ******************************************
  // The flatten method works only on a collection that contains
  // a collection in each of its elements.  The commented-out
  // line below won't compile because the elements in intList
  // contain Int values, instead of collections.
  // intList.flatten  // WON'T COMPILE!

  // The following 2 lines of code shows that the listOfLists.flatten method
  // returns the same result as the listOfLists.flatMap(x=>x) method.
  println(s"11) listOfLists.flatMap(x=>x*x) = ${listOfLists.flatMap(x=>x)}")
  // PRINTS: 11) listOfLists.flatMap(x=>x*x) = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
  println(s"12) listOfLists.flatten         = ${listOfLists.flatten}")
  // PRINTS: 12) listOfLists.flatten         = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
  // The following line of code invokes the flatten method first, followed by the map method.
  println(s"13) listOfLists.flatten.map(x => x*x) = ${listOfLists.flatten.map(x => x*x)}")
  // PRINTS: 13) listOfLists.flatten.map(x => x*x) = List(1, 4, 9, 16, 25, 36, 49, 64, 81)

  // flatMap METHOD ******************************************
  // The two println statements below show these two function calls return identical results:
  // 1) nameList.map(_.toUpperCase).flatten
  // 2) nameList.flatMap(_.toUpperCase)
  println(s"14) nameList.map(_.toUpperCase).flatten = ${nameList.map(_.toUpperCase).flatten}")
  // PRINTS: 14) nameList.map(_.toUpperCase).flatten = List(T, J, B, R, O, S, Y, R, A, N, D, Y)
  println(s"15) nameList.flatMap(_.toUpperCase) = ${nameList.flatMap(_.toUpperCase)}")
  // PRINTS: 15) nameList.flatMap(_.toUpperCase) = List(T, J, B, R, O, S, Y, R, A, N, D, Y)

  // forall METHOD ******************************************
  // Returns true when all elements in the collection
  // meet the condition passed as its argument.
  println(s"16) intList.forall(_ > 1) = ${intList.forall(_ > 1)}")
  // PRINTS: 16) intList.forall(_ > 1) = false
  println(s"17) intList.forall(_ > 0) = ${intList.forall(_ > 0)}")
  // PRINTS: 17) intList.forall(_ > 0) = true

  // foreach METHOD ******************************************
  // Apply the function passed to foreach to each element in
  // the collection.  The foreach method returns nothing (Unit),
  // so it's used only for its side effects.
  intList.foreach(x => print(2.0F * x + ", "))
  // PRINTS: 2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 14.0,

  // foreach can be used to loop through every element
  // in the collection, like this.
  intList.foreach:
    element => element
      print(s"\nelement = $element") // PRINTS: element = 1
  //         element = 2
  //         element = 3
  //         element = 4
  //         element = 5
  //         element = 6
  //         element = 7

  // grouped METHOD ******************************************
  println(s"\n18) intList.grouped(1).toList = ${intList.grouped(1).toList}")
  // PRINTS: 18) intList.grouped(1).toList = List(List(1), List(2), List(3), List(4), List(5), List(6), List(7))
  println(s"19) intList.grouped(2).toList = ${intList.grouped(2).toList}")
  // PRINTS: 19) intList.grouped(2).toList = List(List(1, 2), List(3, 4), List(5, 6), List(7))
  println(s"20) intList.grouped(3).toList = ${intList.grouped(3).toList}")
  // PRINTS: 20) intList.grouped(3).toList = List(List(1, 2, 3), List(4, 5, 6), List(7))
  println(s"21) intList.grouped(4).toList = ${intList.grouped(4).toList}")
  // PRINTS: 21) intList.grouped(4).toList = List(List(1, 2, 3, 4), List(5, 6, 7))

  // indexWhere METHOD ******************************************
  // Obtain the index of the first value in intList that's greater than 6.
  println(s"22) intList.indexWhere(_ > 6) = ${intList.indexWhere(_ > 6)}")
  // PRINTS: 22) intList.indexWhere(_ > 6) = 6

  // Obtain the index of the first value in intList that's less than 0.
  // No value in intList is < 0, so the value -1 is returned.
  println(s"23) intList.indexWhere(_ < 0) = ${intList.indexWhere(_ < 0)}")
  // PRINTS: 23) intList.indexWhere(_ < 0) = -1

  // Obtain the index of the first value in intList that's less than < 8.
  println(s"24) intList.indexWhere(_ < 8) = ${intList.indexWhere(_ < 8)}")
  // PRINTS: 24) intList.indexWhere(_ < 8) = 0

  // lastIndexWhere METHOD ******************************************
  // The following call to lastIndexWhere(_ > 8) returns -1 because
  // intList contains no value > 8; therefore, no index is associated
  // with a value > 8.
  println(s"25) intList.lastIndexWhere(_ > 8) = ${intList.lastIndexWhere(_ > 8)}")
  // PRINTS: intList.lastIndexWhere(_ > 8) = -1

  // The index of the last value in intList having a value > 0 is 7; therefore,
  // 7 is the value returned by lastIndexWhere(_ > 0).
  println(s"26) intList.lastIndexWhere(_ > 0) = ${intList.lastIndexWhere(_ > 0)}")
  // PRINTS: 26) intList.lastIndexWhere(_ > 0) = 7

  // inits METHOD ******************************************
  // Don't confuse this inits method with the init method!
  // The inits method generates an iterator over all values
  // of an iterable collection.  The following three iterables
  // are all equivalent.
  val iter_1:Iterator[List[Int]] = intList.inits
  val iter_2:Iterator[List[Int]] = List(1,2,3,4,5,6,7).inits
  val iter_3:Iterator[List[Int]] = Iterator(List(1, 2, 3, 4, 5, 6, 7), List(1, 2, 3, 4, 5, 6),
                                            List(1, 2, 3, 4, 5),       List(1, 2, 3, 4),
                                            List(1,2,3),               List(1,2),
                                            List(1),                   Nil)
  // *************************************************
  // The following 3 for loops print identical results
  // because iterators iter_1, iter_2, and iter_3
  // are all equivalent.
  var count:Int = 0
  for (x <- iter_1)
  {
    count += 1
    println("count = " + count + ", " + x) // PRINTS: count = 1, List(1, 2, 3, 4, 5, 6, 7)
                                           //         count = 2, List(1, 2, 3, 4, 5, 6)
                                           //         count = 3, List(1, 2, 3, 4, 5)
                                           //         count = 4, List(1, 2, 3, 4)
                                           //         count = 5, List(1, 2, 3)
                                           //         count = 6, List(1, 2)
                                           //         count = 7, List(1)
                                           //         count = 8, List()
  }
  count = 0
  for (x <- iter_2)
  {
    count += 1
    println("count = " + count + ", " + x)
  }
  count = 0
  for (x <- iter_3)
  {
    count += 1
    println("count = " + count + ", " + x)
  }
end main

===========================================================================

___ fold      - SEE:  https://github.com/w9mwi/Scala/blob/master/Fold_Methods

___ foldLeft  - SEE:  https://github.com/w9mwi/Scala/blob/master/Fold_Methods

___ foldRight - SEE:  https://github.com/w9mwi/Scala/blob/master/Fold_Methods

___ partition - Pass this method a function that operates on a single element of the collection
                and returns a Boolean.  This method returns a tuple with TWO new collections.
                The first collection in the tuple contains only the elements for which the
                function is true.  The second collection in the tuple contains only the elements
                for which the function is false.
                EXAMPLE:
                val myList:List[Float] = List(43.7F, 567.89F, 144.8F, 77.7F, 17.7F)
                val result:(List[Float], List[Float]) = myList.partition(_ > 77.0F)
                println(result) // Prints: (List(567.89, 144.8, 77.7),List(43.7, 17.7))

___ reduce - The reduce, reduceLeft, and reduceRight methods always
             result in a single element being returned.
             Example:
             val myList:List[Int] = List(1, 2, 3, 4)
             println(myList.reduce(_ max _))         // PRINTS: 4
             println(myList.reduce((x, y) => x + y)) // PRINTS: 10
             println(myList.reduce((x, y) => x - y)) // PRINTS: -8
___ reduceLeft - See reduceRight.
___ reduceRight - EXAMPLE of reduceLeft and reduceRight:
    val myList:List[Int] = List(1, 2, 3, 4)
    var result:Int = myList.reduceLeft(_ + _) // result = ((1 + 2) + 3) + 4 = 10
    println("result = " + result) // Prints: 10

    result = myList.reduceRight(_ + _) // result = 1 + (2 + (3 + 4)) = 10
    println("result = " + result) // Prints: 10

    result = myList.reduceLeft(_ - _) // result = ((1 - 2) - 3) - 4 = -8
    println("result = " + result) // Prints: -8

    result = myList.reduceRight(_ - _) // result = 1 - (2 - (3 - 4)) = -2
    println("result = " + result) // Prints: -2

    result = myList.reduceLeft(_ * _) // result = ((1 * 2) * 3) * 4 = 24
    println("result = " + result) // Prints: 24

    result = myList.reduceRight(_ * _) // result = 1 * (2 * (3 * 4)) = 24
    println("result = " + result) // Prints: 24
___ sliding - Provides an iterator that gives the effect of sliding a window of a specified size across the sequence.
              EXAMPLE:
              val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
              intList.sliding(3).foreach(println)
              var count = 0
              for (x <- intList.sliding(3))
              {
                count += 1
                // Print the same intList.sliding(3) as the above call to foreach.
                println("count = " + count + ", " + x)
              }
___ tails - Gives an iterator that runs through sublists, starting with the full list, and ending
            with an empty list--removing one element from the left (removing the head) for each step,
            thus returning the tail.
            EXAMPLE:
            val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
            intList.tails.foreach(println)
            var count = 0
            for (x <- intList.tails)
            {
              count += 1
              // Print the same intList.tails as the above call to foreach.
              println("count = " + count + ", " + x)
            }
___ takeWhile - Also see the dropWhile method, which is the inverse of this takeWhile method.
                Pass this method a function that operates on a single element of the collection
                and returns a Boolean.  This method returns a new collection of all elements
                for which that function is true beginning with the first element.  As soon
                as an element is found for where the function returns false, nothing more
                is returned.  That's why the fourth println below prints the empty List (List()),
                because the function returns false for the first element in myList.

                val myList:List[Float] = List(43.7F, 17.7F, 77.7F, 567.89F, 144.8F)
                println("myList                       = " + myList)
                println("myList.takeWhile(_ == 43.7F) = " + myList.takeWhile(_ == 43.7F))
                println("myList.takeWhile(_ > 43.6F)  = " + myList.takeWhile(_ > 43.6F))
                println("myList.takeWhile(_ > 43.7F)  = " + myList.takeWhile(_ > 43.7F))
                println("myList.takeWhile(_ > 17.6F)  = " + myList.takeWhile(_ > 17.6F))
              // PRINTS THE FOLLOWING:
              // myList                       = List(43.7, 17.7, 77.7, 567.89, 144.8)
              // myList.takeWhile(_ == 43.7F) = List(43.7)
              // myList.takeWhile(_ > 43.6F)  = List(43.7)
              // myList.takeWhile(_ > 43.7F)  = List()
              // myList.takeWhile(_ > 17.6F)  = List(43.7, 17.7, 77.7, 567.89, 144.8)
