
A Scala List elements should be accesssed almost exclusively by traversing
the List from one element to the next.  The time it takes to access the
nth element of a List via an index increases as n increases.  You should
never access List elements via an index like this...

  val intList:List[Int] = List(111, 222, 333, 444, 555)
  val mySlice = intList(4)  // Don't access Lists via an index like this.

Any operations that work with the end of a long List
(appending elements to a long list, etc.) should be
avoided because a List is inefficient at that.  A List
is efficient when you prepend elements to it, or access
it via the List's head and tail.

The following methods are all invoked on the Scala List class.  However, many
of these same-named methods also apply to other Scala collections, in an
analgous way.  Read the in-line comments.

===========================================================================
// *********************************
// BASIC LIST METHODS
// *********************************
@main def main():Unit =
  var intList:List[Int] = List(1, 2, 3, 4, 5)

  // drop METHOD ******************************************
  // Drop the first 3 elements of intList.
  println(s"1) intList.drop(3) = ${intList.drop(3)}")
  // PRINTS: 1) intList.drop(3) = List(4, 5)

  // init METHOD ******************************************
  // Return all elements of intList, except the last element.
  println(s"2) intList.init = ${intList.init}") // init(ial) = All elements except last.
  // PRINTS:2) intList.init = List(1, 2, 3, 4)

  // last METHOD ******************************************
  // Return the last element of intList.
  println(s"3) intList.last = ${intList.last}") // last element only.
  // PRINTS: 3) intList.last = 5


  // patch METHOD - PART 1 OF 2 *************************************
  // EXAMPLE: At index 0, insert List(999), and replace
  //          zero (0) elements from the existing intList.
  println(s"4) intList.patch(0, List(999), 0) = ${intList.patch(0, List(999), 0)}")
  // PRINTS: 4) intList.patch(0, List(999), 0) = List(999, 1, 2, 3, 4, 5)

  // EXAMPLE: At index 2, insert List(999), and replace
  //          one (1) element from the existing intList.
  println(s"5) intList.patch(2, List(999), 1) = ${intList.patch(2, List(999), 1)}")
  // PRINTS: 5) intList.patch(2, List(999), 3) = List(1, 2, 999)

  // EXAMPLE: At index 2, insert List(999), and replace
  //          two (2) elements from the existing intList.
  println(s"6) intList.patch(2, List(999), 2) = ${intList.patch(2, List(999), 2)}")
  // PRINTS: 6) intList.patch(2, List(999), 2) = List(1, 2, 999, 5)
  // *****************************************************************

  // *****************************************************************
  // patch METHOD - PART 2 OF 2
  val originalList = List(10, 20, 30, 40, 50, 60)
  println(s"Original List: $originalList")

  // --- 1. Replacing a subsequence ---
  // Replace 2 elements starting from index 2 (which are 30, 40) with List(35, 45)
  val replacedList = originalList.patch(2, List(35, 45), 2)
  println(s"Replaced Subsequence: $replacedList")
  // PRINTS: Replaced Subsequence: List(10, 20, 35, 45, 50, 60)

  // --- 2. Inserting elements ---
  // Insert List(25) at index 2 without removing any elements (n = 0)
  val insertedList = originalList.patch(2, List(25), 0)
  println(s"Inserted Elements: $insertedList")
  // PRINTS: Inserted Elements: List(10, 20, 25, 30, 40, 50, 60)

  // --- 3. Removing elements ---
  // Remove 3 elements starting from index 1 (which are 20, 30, 40) with an empty list
  val removedList = originalList.patch(1, List(), 3) // List() = Seq.empty
  println(s"Removed Elements: $removedList")
  // PRINTS: Removed Elements: List(10, 50, 60)

  // --- 4. Simulating an element update ---
  // Replace 1 element at index 0 (which is 10) with 5
  val updatedList = originalList.patch(0, List(5), 1)
  println(s"Updated Element: $updatedList")
  // PRINTS: Updated Element: List(5, 20, 30, 40, 50, 60)
  // *****************************************************************

  // slice METHOD ******************************************
  // EXAMPLE: slice(startIdx, n)  - Returns charList from
  //          startIdx = 1 ('b') to index (n-1) = 2 ('c)
  println(s"6) charList.slice(1,3) = ${charList.slice(1,3) }")
  // PRINTS: 6) charList.slice(1,3) = List(b, c)

  // splitAt METHOD ******************************************
  // EXAMPLE: Split strList so it returns one List[String] made up
  //          from the elements contained at indices < 3; and another
  //          List[String] made up from all remaining elements.
  val strList:List[String] = List("id", "name", "email",
                                  "1", "Alice", "alice@example.com",
                                  "2", "Bob", "bob@example.com")
  val (header, records) = strList.splitAt(3)
  println(s"7) header = $header,   records = $records")
  // PRINTS: 7) header = List(id, name, email),   records = List(1, Alice, alice@example.com, 2, Bob, bob@example.com)

  // take METHOD ******************************************
  // The List.take method in Scala 3 returns a new List containing
  // the first n elements of the original list.  If the list has
  // fewer than n elements, it returns the entire list.
  val intList:List[Int] = List(111, 222, 333, 444, 555, 666)
  println(s"8) intList.take(4) = ${intList.take(4)}")
  // PRINTS: 8) intList.take(4) = List(111, 222, 333, 444)

  // takeRight METHOD ******************************************
  // The List.takeRight method returns a new List containing
  // the first n elements of the original list.  If the list
  // has fewer than n elements, it returns the entire list.
  println(s"8) intList.takeRight(4) = ${intList.takeRight(4)}")
  // PRINTS: 8) intList.takeRight(4) = List(333, 444, 555, 666)

end main
===========================================================================
// *********************************
// BOOLEAN TESTS ON LIST METHODS
// *********************************
@main def main():Unit =
  val intList:List[Int] = List(111, 222, 333, 444, 555)

  // contains METHOD ******************************************
  println(s"9) intList.contains(666) = ${intList.contains(666)},  intList.contains(555) = ${intList.contains(555)}")
  // PRINTS: 9) intList.contains(666) = false,  intList.contains(555) = true

  // endsWith  METHOD ******************************************
  println(s"10) intList.endsWith(List(444)) = ${intList.endsWith(List(444))},  intList.endsWith(List(555)) = ${intList.endsWith(List(555))}")

  // isInstanceOf METHOD ******************************************
  // WARNING: The val isStringList below has the value true, which is WRONG!
  //          The val isStringList below should be false because intList
  //          is of type List[Int], not of type List[String].  This error
  //          occurs due to "type erasure" occurring on the Java Virtual
  //          Machine (JVM), which is the runtime environment for Scala.
  //          When Scala code is compiled into JVM bytecode, the generic
  //          type parameters (like [Int] and [String]) are essentially
  //          "erased" at runtime.  So the JVM sees only the raw, non-generic
  //          type, which is List; not List[Int], or List[String], etc.
  val isIntArray:Boolean   = intList.isInstanceOf[Array[Int]]
  val isStringList:Boolean = intList.isInstanceOf[List[String]]
  val isIntList:Boolean    = intList.isInstanceOf[List[Int]]
  println(s"11) isIntArray = $isIntArray,  isStringList = $isStringList,  isIntList = $isIntList")
  // PRINTS: 11) isIntArray = false,  isStringList = true,  isIntList = true

  // asInstanceOf METHOD ******************************************
  // Used to cast one data type to another data type  This
  // code sample casts the type Int to the type Long.
  val intValue:Int   = 1234;
  val longValue:Long = intValue.asInstanceOf[Long]
  if (intValue.isInstanceOf[Int])
    println(s"12) intValue's data type = Int") // PRINTS: 12) intValue's data type = Int
  if (longValue.isInstanceOf[Long])
    println(s"13) longValue's data type = Long") // PRINTS: 13) longValue's data type = Long

  // startsWith METHOD ******************************************
  val strList1:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
  var strList2:List[String] = List("abc", "def")
  println(s"14) strList1.startsWith($strList2) = ${strList1.startsWith(strList2)}")
  // PRINTS: 14) strList1.startsWith(List(abc, def)) = true
end main

===========================================================================

@main def main():Unit =
  // *********************************
  // SEARCHING LIST METHODS
  // *********************************

  // find METHOD ******************************************
  val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
  // Return the first element of intList having a value < 3.
  var result:Option[Int] = intList.find(_<6)
  println(s"1) result = $result") // Prints: 1) result = Some(4)
  // Return the first element of intList having a value > 7.
  result = intList.find(_>7)
  println(s"2) result = $result") // Prints: 2) result = Some(9)
  // Return the first element of intList having a value > 10.
  result = intList.find(_>10)
  println(s"3) result = $result") // Prints: 3) result = None

  // indexOf METHOD ******************************************
  val strList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "mno")
  // Return the index of the FIRST occurrence of "mno" in strList.
  var index:Int = strList.indexOf("mno")
  println(s"4) index = $index") // PRINTS: 4) index = 4

  // lastIndexOf METHOD ******************************************
  // Return the index of the LAST occurrence of "mno" in strList.
  index = strList.lastIndexOf("mno")
  println(s"5) index = $index") // PRINTS: 5) index = 5

  // diff METHOD ******************************************
  var strList_1:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
  var strList_2:List[String] = List("pqr", "mno", "jkl", "ghi", "def", "abc")
  var strList_3:List[String] = List("mno", "abc")
  var intList_1: List[Int] = List(111, 222, 333, 444, 222)
  var intList_2: List[Int] = List(111, 222)

  // Return all elements from strList_1 that are not contained in strList_2.
  // (All elements in strList_1 are contained in strList_2 so an empty list
  // is returned.)
  println(s"6) strList_1.diff(strList_2) = ${strList_1.diff(strList_2)}")
  // PRINTS: 6) strList_1.diff(strList_2) = List()

  // Return all elements from strList_1 that are not contained in strList_3.
  println(s"7) strList_1.diff(strList_3) = ${strList_1.diff(strList_3)}")
  // PRINTS: 7) strList_1.diff(strList_3) = List(def, ghi, jkl, pqr)

  // Return all elements from intList_1 that are not contained in intList_2.
  // NOTE: When intList_1 contains more than one element that's in intList_2,
  //       only the first occurrence of that element is removed from the
  //       result.  Therefore, only the first occurrence of 222 in strList_1
  //       is removed from the result, but not subsequent occurrences of 222.
  println(s"8) intList_1.diff(intList_2) = ${intList_1.diff(intList_2)}")
  // PRINTS: 8) intList_1.diff(intList_2) = List(333, 444, 222)

  // mkString METHOD ******************************************
  // See the toArray method below for more examples of mkString.
  println("9) strList.mkString = " + strList.mkString)
  // PRINTS: 9) strList.mkString = abcdefghijklmnomno
  println("10) strList.mkString(\" + \") = " + strList.mkString(" + "))
  // PRINTS: 10) strList.mkString(" + ") = abc + def + ghi + jkl + mno + mno
  println("11) strList.mkString(\"BEGIN\", \"_\", \"END\") = " + strList.mkString("BEGIN", "_", "END"))
  // PRINTS: 11) strList.mkString("BEGIN", "_", "END") = BEGINabc_def_ghi_jkl_mno_mnoEND

  // reverse METHOD ******************************************
  println("12) strList.reverse = " + strList.reverse)
  // PRINTS: 12) strList.reverse = List(pqr, mno, jkl, ghi, def, abc)

  // toArray METHOD ******************************************
  println(s"13) strList.toArray = ${strList.toArray}")
  // PRINTS: 13) strList.toArray = [Ljava.lang.String;@2133c8f8

  println(s"14) strList.toArray = ${strList.toArray.mkString}")
  // PRINTS: 14) strList.toArray = abcdefghijklmnopqr

  println(s"15) strList.toArray = ${strList.toArray.mkString(", ")}")
  // PRINTS: 15) strList.toArray = abc, def, ghi, jkl, mno, pqr

  // NOTE: The following String argument is passed to mkString():
  //       1) The String separating each element of the result: " | "
  println(s"16) strList.toArray = ${strList.toArray.mkString(" | ")}")
  // PRINTS: 16) strList.toArray = abc | def | ghi | jkl | mno | pqr

  // NOTE: The following 3 String arguments are passed to mkString():
  //       1) The String that's prepended to the result:        "Array("
  //       2) The String separating each element of the result: ", "
  //       3) The String that's appended to the result:        ")"
  println(s"17) strList.toArray = ${strList.toArray.mkString("Array(", ", ", ")")}")
  // PRINTS: 17) strList.toArray = Array(abc, def, ghi, jkl, mno, pqr)
end main

===========================================================================

===========================================================================


SEARCHING:
==========

___ toList  - EXAMPLE:
              val myArray:Array[String] = Array("abc", "def", "ghi", "jkl", "mno", "pqr")
              val myList:List[String]   = myArray.toList
              println(myList) // PRINTS: List(abc, def, ghi, jkl, mno, pqr)
___ toArray - EXAMPLE:
              val myList:List[String]   = List("abc", "def", "ghi", "jkl", "mno", "pqr")
              val myArray:Array[String] = myList.toArray
              myArray.foreach(println)
              // PRINTS THE FOLLOWING 6 LINES:
              abc
              def
              ghi
              jkl
              mno
              pqr
___ zip - EXAMPLE:
          val myList1:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
          val myList2:List[String] = List("stu", "vwx", "yz")
          println(myList1.zip(myList2)) // Prints:  List((abc,stu), (def,vwx), (ghi,yz))
___ zipWithIndex - When the zipWithIndex() function is called on a List, it returns a List of tuples.
                   Where the first tuple of the returned List contains the first element of the List
                   and the index of that first element, which will be 0 (zero).  Followed by the
                   second element of the List and the index of that second element, which will be
                   1 (one).  Etc.
                   EXAMPLE:
                   val myList:List[String]                = List("abc", "def", "ghi", "jkl", "mno", "pqr")
                   val myListWithIndex:List[(String,Int)] = myList.zipWithIndex
                   println("myListWithIndex = " + myListWithIndex)
                   println("myListWithIndex(2)._1 = " + myListWithIndex(2)._1 + ",  myListWithIndex(2)._2 = " + myListWithIndex(2)._2)
                   PRINTS THE FOLLOWING 2 LINES:
                   myListWithIndex = List((abc,0), (def,1), (ghi,2), (jkl,3), (mno,4), (pqr,5))
                   myListWithIndex(2)._1 = ghi,  myListWithIndex(2)._2 = 2
___ product - EXAMPLE:
              val myList:List[Float] = List(123.4F, 456.7F, 78.9F)
              println("myList.product = " + myList.product) // Prints: myList.product = 4446550.0
___ sum - EXAMPLE:
          val myList:List[Float] = List(123.4F, 456.7F, 789.1F)
          println("myList.sum = " + myList.sum) // Prints: myList.sum = 1369.2


HIGHER-ORDER METHODS, ETC.
==========================
Among this group of higher-order functions, there are specifically
TWO (2) of these functions that are widely used and very popular.
They are the filter() function and the map() function.  You should
make it a point to understand those two functions very well.

___ count - EXAMPLE:
            val myList:List[Float] = List(123.4F, 456.7F, 78.9F)
            println("myList.count = " + myList.count(_ > 100.0F)) // Prints: myList.count = 2
___ dropWhile - Also see the takeWhile method, which is the inverse of this dropWhile method.
                EXAMPLE:
                val strList:List[String] = List[String]("str1_abc_junk", "str2_abc_stuff", "str3_qrs_things", "str4_xyz_trash")
                val result:List[String] = strList.dropWhile(_.contains("abc"))
                result.foreach(println) // prints: str3_qrs_things  str4_xyz_trash
___ combinations - Also see the permutations function.
                   EXAMPLE:
                   val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
                   intList.combinations(3).foreach(println)
                   var count = 0
                   for (x <- intList.combinations(3))
                   {
                     count += 1
                     // Print the same intList.combinations(3) as the above call to foreach.
                     println("count = " + count + ", " + x)
                   }
___ exists - The exists method returns true if at least one element in the collection meets the condition.
             The forall method returns true if ALL elements in the collection meet the condition.
             EXAMPLE 1:
             val strList:List[String] = List[String]("str1_abc_junk", "str2_jkl_stuff", "str3_qrs_things", "str4_xyz_trash");
             val result:Boolean = strList.exists(_.compareTo("str3_qrs_things") == 0)
             println(result) // result = true
             EXAMPLE 2:
             val intList:List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7);
             val result:Boolean = intList.exists(x => x==7)
             println(result) // result = true
___ filter - NOTE: The difference between the filter() and map() functions are as follows:
                   The function passed to filter() returns a Boolean and gets applied to every
                   element in the List.  If the Boolean returned by that function is true,
                   then that element of the List gets returned by filter(), which constructs
                   a new List that IS A SUBSET of the original List--thus the name filter.

                   The map() function gets passed a function which gets applied to every element
                   in the List.  That function then returns a value for every element in the List
                   that is the same type contained in the List.  So List.map() returns a List
                   containing the same number of elements as the List that it's applied to.
                   
             EXAMPLE:
             val intList:List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7)
             val result_1:List[Int] = intList.filter(_ > 6)
             println(result_1) // PRINTS: List(7)

             // The following code shows TWO (2) ways of obtaining identical results by
             // calling the filter() function.  Both println() statements below print:
             // RMN
             // Randy_Reject
             val nameList:List[String] = List("TJB", "RMN", "Randy_Reject")
             var result_2:List[String] = nameList.filter(_.startsWith("R"))
             result_2.foreach(println) // PRINTS: RMN Randy_Reject
             result_2 = nameList.filter(x => x.startsWith("R"))
             result_2.foreach(println) // PRINTS: RMN Randy_Reject
___ filterNot - The opposite of the filter method.
___ flatMap - Also see --> https://github.com/w9mwi/Scala/blob/master/flatMap()_and_flatten()
              The flatMap() method is essentially a combination of the List.map method() run first,
              followed by the List.flatten() method run second.  The flatMap() method returns a List.

              TO UNDERSTAND EXACTLY HOW List.flatMap WORKS, UNDERSTAND THIS CODE...

              object Demo
              {
                def main(args: Array[String]):Unit =
                {
                  val list_1:List[Int] = List(1,2,3,4,5)
                  println("A) " + list_1)               // PRINTS: A) List(1, 2, 3, 4, 5)
                  println("B) " + list_1.map(i=>i*2))   // PRINTS: B) List(2, 4, 6, 8, 10)
                  println("C) " + list_1.flatMap(func)) // PRINTS: C) List(0, 1, 2, 1, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6)

                  // This is what happens when list_1.flatMap(func) is called:
                  // 1) flatMap first calls the map function on every element in list_1.
                  //    So the map function generates this result:
                  //    List(List(0, 1, 2), List(1, 2, 3), List(2, 3, 4), List(3, 4, 5), List(4, 5, 6))
                  //
                  // 2) After flatMap calls the map function, it then calls the flatten function
                  //    on the results of the map function.  So flatten transforms...
                  //    THIS:       List(List(0, 1, 2), List(1, 2, 3), List(2, 3, 4), List(3, 4, 5), List(4, 5, 6))
                  //    INTO THIS:  List(0, 1, 2, 1, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6)
                }

                def func(intNumber:Int):List[Int] = List(intNumber - 1, intNumber, intNumber + 1)
              }


              MORE EXAMPLES of using the flatMap() method...

              val fish:List[String]               = List[String]("alewife", "bass", "perch", "northern", "walleye")
              val waterBirds:List[String]         = List[String]("eagle", "duck", "goose")
              val waterAnimals:List[List[String]] = List[List[String]](fish, waterBirds)
              println("A) fish                             = " + fish)
              println("B) waterBirds                       = " + waterBirds)
              println("C) waterAnimals                     = " + waterAnimals)
              println("D) waterAnimals.map(x => x)         = " + waterAnimals.map(x => x)) // NOTE: map(x => x) changes nothing.
              println("E) waterAnimals.flatten             = " + waterAnimals.flatten)
              println("F) waterAnimals.map(x => x).flatten = " + waterAnimals.map(x => x).flatten)
              println("G) waterAnimals.flatMap(x => x)     = " + waterAnimals.flatMap(x => x))
              //  PRINTS THE FOLLOWING 7 LINES...
              //  A) fish                             = List(alewife, bass, perch, northern, walleye)
              //  B) waterBirds                       = List(eagle, duck, goose)
              //  C) waterAnimals                     = List(List(alewife, bass, perch, northern, walleye), List(eagle, duck, goose))
              //  D) waterAnimals.map(x => x)         = List(List(alewife, bass, perch, northern, walleye), List(eagle, duck, goose))
              //  E) waterAnimals.flatten             = List(alewife, bass, perch, northern, walleye, eagle, duck, goose)
              //  F) waterAnimals.map(x => x).flatten = List(alewife, bass, perch, northern, walleye, eagle, duck, goose)
              //  G) waterAnimals.flatMap(x => x)     = List(alewife, bass, perch, northern, walleye, eagle, duck, goose)

___ flatten - The flatten() method works ONLY on Scala collections that contain collections.
              Read the following sample code for examples.

            object Demo
            {
              def main(args:Array[String]): Unit = {
            
                // The flatten() method does NOT work on the following
                // intArray because it contains Int values, which are
                // NOT collections.
                val intArray:Array[Int] = Array(123, 456, 789)
                // intArray.flatten  // WON'T COMPILE!
                // *************************************************
            
                println("EXAMPLE 1)")
                // Here we DON'T call the flatten() method yet.
                // We print strArray only to show its contents.
                val strArray:Array[String] = Array("ABC", "XYZ")
                for (x <- strArray)  println(x) // PRINTS: ABC
                                                //         XYZ
                // *************************************************
            
                println("EXAMPLE 2)")
                // This result may be unexpected.  The flatten() method
                // WORKS on strArray because an Array[String] type in
                // Scala is built with an Array[Char] collection!
                val charArray:Array[Char] = strArray.flatten
                for (x <- charArray)  print(x)  // PRINTS: ABCXYZ
            
                // *************************************************
                // Here we flatten a List, where each of its elements
                // contains a Set.
                println("\nEXAMPLE 3)")
                val myList:List[Set[Int]] = List(Set(1, 2, 3), Set(9, 8, 7))
                println(myList.flatten) // PRINTS: List(1, 2, 3, 9, 8, 7)
                // *************************************************
            
                println("EXAMPLE 4)")
                // Here's one more example that's more complex.
                // REMEMBER: The flatten() method works ONLY on a
                //           collection that contains a collection.
                val vasc:Vector[Array[Set[Char]]] = Vector(Array(Set('A','B','C'), Set('D','E'), Set('F')),
                                                           Array(Set('X', 'Y', 'Z')))
                val vsc:Vector[Set[Char]] = vasc.flatten
                for (x <- vsc)  print(x + " ")  // PRINTS: Set(A, B, C) Set(D, E) Set(F) Set(X, Y, Z)
            
                println("\nEXAMPLE 5)")
                val vs:Vector[Char] = vsc.flatten
                for (x <- vs)  print(x + " ")  // PRINTS: A B C D E F X Y Z
              }
            }
             

___ fold      - SEE:  https://github.com/w9mwi/Scala/blob/master/Fold_Methods

___ foldLeft  - SEE:  https://github.com/w9mwi/Scala/blob/master/Fold_Methods

___ foldRight - SEE:  https://github.com/w9mwi/Scala/blob/master/Fold_Methods

___ forall - The forall method returns true if ALL elements in the collection meet the condition.
             The exists method returns true if at least one element in the collection meets the condition.
             EXAMPLE:
             val myList:List[Float] = List(123.4F, 456.7F, 78.9F)
             println("myList.forall = " + myList.forall(_ > 100.0F)) // Prints: myList.forall = false
             println("myList.forall = " + myList.forall(_ > 50.0F))  // Prints: myList.forall = true
___ foreach - This method gets passed a function that operates on all elements in the collection,
              and returns nothing.  This method is called only for its side effects.
              EXAMPLE:
              val myList:List[Float] = List(12.1F, 34.2F, 56.3F, 78.4F)
              myList.foreach(x => println(2.0F * x)) // Param passed to foreach is a literal function.
              PRINTS THE FOLLOWING 4 LINES:
              24.2
              68.4
              112.6
              156.8
___ grouped - Runs through the sequence, grouping items into groups of the specified size.
              EXAMPLE:
              val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
              intList.grouped(2).foreach(println) // PRINTS: List(7, 4)
                                                  //         List(6, 3)
              var count = 0                       //         List(9, 1)
              for (x <- intList.grouped(2))
              {
                 count += 1
                 // Print the same intList.grouped(2) as the above call to foreach.
                 println("count = " + count + ", " + x) // PRINTS: count = 1, List(7, 4)
              }                                         //         count = 2, List(6, 3)
                                                        //         count = 3, List(9, 1)

___ indexWhere - Pass this method a function that operates on a single element of the collection.
                 Returns the index of the FIRST element for which the function is true.  Returns
                 -1 if the function is NOT true for any of the elements.
                 EXAMPLE:
                 val myList:List[Float] = List(12.1F, 34.2F, 56.3F, 78.4F)
                 val result:Int = myList.indexWhere(_ > 50.0F)
                 println(result) // Prints: 2
___ inits - Provides an iterator going from the full sequence to an empty one, removing elements from the end.
                                                                 // The below println statement PRINTS:
            val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)  // count = 1, List(7, 4, 6, 3, 9, 1)
            var count = 0                                        // count = 2, List(7, 4, 6, 3, 9)
            for (x <- intList.inits)                             // count = 3, List(7, 4, 6, 3)
            {                                                    // count = 4, List(7, 4, 6)
              count += 1                                         // count = 5, List(7, 4)
              println("count = " + count + ", " + x)             // count = 6, List(7)
            }                                                    // count = 7, List()
___ lastIndexWhere - Pass this method a function that operates on a single element of the collection
                     and returns a Boolean.  This method returns the index of the LAST element for
                     which the function is true.  Returns -1 if the function is NOT true for any
                     of the elements.
                     EXAMPLE:
                     val myList:List[Float] = List(12.1F, 34.2F, 56.3F, 78.4F)
                     val result:Int = myList.lastIndexWhere(_ > 50.0F)
                     println(result) // Prints: 3
___ map - NOTE: The difference between the filter() and map() functions are as follows:
                The function passed to filter() returns a Boolean and gets applied to every
                element in the List.  If the Boolean returned by that function is true,
                then that element of the List gets returned by filter(), which constructs
                a new List that IS A SUBSET of the original List--thus the name filter.

                The map() function gets passed a function which gets applied to every element
                in the List.  That function then returns a value for every element in the List
                that is the same type contained in the List.  So List.map() returns a List
                containing the same number of elements as the List it gets applied to.
          EXAMPLE:
          val intList:List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7);
          val result:List[Int] = intList.map(_*2)
          println(result) //  prints: List(2, 4, 6, 8, 10, 12, 14)
___ partition - Pass this method a function that operates on a single element of the collection
                and returns a Boolean.  This method returns a tuple with TWO new collections.
                The first collection in the tuple contains only the elements for which the
                function is true.  The second collection in the tuple contains only the elements
                for which the function is false.
                EXAMPLE:
                val myList:List[Float] = List(43.7F, 567.89F, 144.8F, 77.7F, 17.7F)
                val result:(List[Float], List[Float]) = myList.partition(_ > 77.0F)
                println(result) // Prints: (List(567.89, 144.8, 77.7),List(43.7, 17.7))
___ permutations - Also see the combinations function.
                   EXAMPLE:
                   val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
                   intList.permutations.foreach(println)
                   var count = 0
                   for (x <- intList.permutations)
                   {
                     count += 1
                     // Print the same intList.permutations as the above call to foreach.
                     println("count = " + count + ", " + x)
                   }
___ reduce - The reduce, reduceLeft, and reduceRight methods always
             result in a single element being returned.
             Example:
             val myList:List[Int] = List(1, 2, 3, 4)
             println(myList.reduce(_ max _))         // PRINTS: 4
             println(myList.reduce((x, y) => x + y)) // PRINTS: 10
             println(myList.reduce((x, y) => x - y)) // PRINTS: -8
___ reduceLeft - See reduceRight.
___ reduceRight - EXAMPLE of reduceLeft and reduceRight:
    val myList:List[Int] = List(1, 2, 3, 4)
    var result:Int = myList.reduceLeft(_ + _) // result = ((1 + 2) + 3) + 4 = 10
    println("result = " + result) // Prints: 10

    result = myList.reduceRight(_ + _) // result = 1 + (2 + (3 + 4)) = 10
    println("result = " + result) // Prints: 10

    result = myList.reduceLeft(_ - _) // result = ((1 - 2) - 3) - 4 = -8
    println("result = " + result) // Prints: -8

    result = myList.reduceRight(_ - _) // result = 1 - (2 - (3 - 4)) = -2
    println("result = " + result) // Prints: -2

    result = myList.reduceLeft(_ * _) // result = ((1 * 2) * 3) * 4 = 24
    println("result = " + result) // Prints: 24

    result = myList.reduceRight(_ * _) // result = 1 * (2 * (3 * 4)) = 24
    println("result = " + result) // Prints: 24
___ sliding - Provides an iterator that gives the effect of sliding a window of a specified size across the sequence.
              EXAMPLE:
              val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
              intList.sliding(3).foreach(println)
              var count = 0
              for (x <- intList.sliding(3))
              {
                count += 1
                // Print the same intList.sliding(3) as the above call to foreach.
                println("count = " + count + ", " + x)
              }
___ tails - Gives an iterator that runs through sublists, starting with the full list, and ending
            with an empty list--removing one element from the left (removing the head) for each step,
            thus returning the tail.
            EXAMPLE:
            val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
            intList.tails.foreach(println)
            var count = 0
            for (x <- intList.tails)
            {
              count += 1
              // Print the same intList.tails as the above call to foreach.
              println("count = " + count + ", " + x)
            }
___ takeWhile - Also see the dropWhile method, which is the inverse of this takeWhile method.
                Pass this method a function that operates on a single element of the collection
                and returns a Boolean.  This method returns a new collection of all elements
                for which that function is true beginning with the first element.  As soon
                as an element is found for where the function returns false, nothing more
                is returned.  That's why the fourth println below prints the empty List (List()),
                because the function returns false for the first element in myList.

                val myList:List[Float] = List(43.7F, 17.7F, 77.7F, 567.89F, 144.8F)
                println("myList                       = " + myList)
                println("myList.takeWhile(_ == 43.7F) = " + myList.takeWhile(_ == 43.7F))
                println("myList.takeWhile(_ > 43.6F)  = " + myList.takeWhile(_ > 43.6F))
                println("myList.takeWhile(_ > 43.7F)  = " + myList.takeWhile(_ > 43.7F))
                println("myList.takeWhile(_ > 17.6F)  = " + myList.takeWhile(_ > 17.6F))
              // PRINTS THE FOLLOWING:
              // myList                       = List(43.7, 17.7, 77.7, 567.89, 144.8)
              // myList.takeWhile(_ == 43.7F) = List(43.7)
              // myList.takeWhile(_ > 43.6F)  = List(43.7)
              // myList.takeWhile(_ > 43.7F)  = List()
              // myList.takeWhile(_ > 17.6F)  = List(43.7, 17.7, 77.7, 567.89, 144.8)
