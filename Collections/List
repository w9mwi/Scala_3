LIST
====
A Scala List is immutable so it can't be altered/changed/updated after it's created.
If you want to alter/change/update a Scala List, you need to create a new List.
The following program demonstrates how to do that.

An empty List in Scala is designated by the keyword "Nil"; which is equivalent to: List()
In functional programming, Scala Lists are sometimes constructed recursively using the
"cons" operator (::), as shown in an example further below.  Nil serves as the
terminating condition for recursive operations on Scala Lists.

The List class inherits from the LinearSeq trait; NOT from the IndexedSeq trait.  This means
that accessing a List element via an index can take a long time because all elements in the
List (up to the index value) must be traversed.  You should avoid accessing elements of a
List via an index value, like this...

   myList(99)

A Scala List is a linked list which consists of a head and a tail.  A List's head
consists of only its first element; its tail consists of all remaining elements.
When a Scala List contains only a single element its head references that single
element; its tail references an empty List.  EXAMPLE:

   var intList: List[Int] = 123 :: Nil // Nil designates an empty List and is equivalent to: List()
   println(s"intList.head = ${intList.head}") // PRINTS: intList.head = 123
   println(s"intList.tail = ${intList.tail}") // PRINTS: intList.tail = List()
   intList = List(987)
   println(s"intList.head = ${intList.head}") // PRINTS: intList.head = 987
   println(s"intList.tail = ${intList.tail}") // PRINTS: intList.tail = List()

=============================================================================
@main def main():Unit =
  var intList:List[Int] = List(-666, 2, 3)
  println(s"1) intList = $intList") // PRINTS: 1) intList = List(-666, 2, 3)

  // To UPDATE ONE ELEMENT OF A LIST, call the List.updated() method.
  // The updated() method returns a new List.
  intList = intList.updated(0, 1) // 0 = the List index, 1 = the value
  println(s"2) intList = $intList") // PRINTS: 2) intList = List(1, 2, 3)

  // To PREPEND ONE ELEMENT TO A LIST, use the :: operator, or the +: operator.
  // The :: operator is called the "cons" operator; short for the word "construct."
  // The +: operator is known as the "list prepend operator."
  // Both these operators return a new List.
  intList = 0 :: intList
  println(s"3) intList = $intList") // PRINTS: 3) intList = List(0, 1, 2, 3)
  intList = -1 +: intList
  println(s"4) intList = $intList") // PRINTS: 4) intList = List(-1, 0, 1, 2, 3)

  // To APPEND ONE ELEMENT to a List, use the :+ operator.
  // The :+ operator is known as the "list append operator."
  // This returns a new List.
  intList = intList :+ 4
  println(s"5) intList = $intList") // PRINTS: 5) intList = List(-1, 0, 1, 2, 3, 4)

  // To CONCAT A LIST to another List, use the ::: operator.  The ::: operator
  // is known as the "list concatenation operator."  This returns a new List.
  intList = List(-4, -3, -2) ::: intList ::: List(5, 6, 7)
  println(s"6) intList = $intList") // PRINTS: 6) intList = List(-4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7)
  
  // THIS LINE WON'T COMPILE  -->  intList = intList :: List(8, 9)
  // The above commented-out line won't compile because the cons operator (::)
  // requires the first operand to be a value, not a List.  To make the above
  // line compile, change the cons operator (::) to the list contact operator
  // (:::) as shown in the following line of code.
  intList = intList ::: List(8, 9)
  println(s"7) intList == $intList") // PRINTS: 7) intList == List(-4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

  // An EMPTY LIST in Scala is designated by the keyword "Nil"; which is equivalent to: List()
  intList = Nil
  println(s"8) intList == $intList") // PRINTS: 8) intList == List()
  intList = List()
  println(s"9) intList == $intList") // PRINTS: 9) intList == List()

  // Nil can be used in PATTERN MATCHING, like this...
  intList match
    case head :: tail => println(s"10) intList is NOT empty.")
    case Nil          => println(s"10) intList IS empty.") // PRINTS: 10) intList IS empty.

  // When constructing a List using only "cons" operators (::), the last element
  // in the List must be an empty List; designated by either List() or Nil.
  intList = -9 :: -8 :: -7 :: List()
  println(s"11) intList = $intList") // PRINTS: 11) intList = List(-9, -8, -7)
  intList = 7 :: 8 :: 9 :: Nil
  println(s"12) intList = $intList") // PRINTS: 12) intList = List(7, 8, 9)
end main
=============================================================================

@main def main():Unit =
  val myList: List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7);

  println("operateOnList_1() result = " + operateOnList_1(myList, _ + _))
  println("operateOnList_2() result = " + operateOnList_2(myList, _ + _))

  /**
   * THIS IS A RECURSIVE FUNCTION!
   * This function is identical in behavior to
   * the operateOnList_2() function below.
   */
  def operateOnList_1(list:List[Int], func:(Int, Int) => Int):Int = {
    if (list.tail.isEmpty)
      list.head
    else
      func(list.head, operateOnList_1(list.tail, func))
  }

  /**
   * THIS IS A RECURSIVE FUNCTION!
   * This function is identical in behavior to the
   * operateOnList_1() function above.
   */
  def operateOnList_2(list:List[Int], func:(Int, Int) => Int):Int = {
    list match {
      case head::Nil  => head  // This line executes when there's only one element in the List.
      case head::tail => func(head, operateOnList_2(tail, func))
      // NOTE: In this example, the following line never executes
      //       because the first two lines of this match statement
      //       match all possible scenarios.
      case _ => 0
    }
  }
end main



===============================================================
===============================================================
===============================================================
The following methods are all invoked on the List class, but
most of them can be invoked on other Scala collections.


BASIC METHODS:
=============
___ drop - Return all elements except the first n elements, where n is the Int parameter passed.  EXAMPLE:
           val myList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
           val newList = myList.drop(1)
           println("newList = " + newList) // Prints:  newList = List(def, ghi, jkl, mno, pqr)
___ init - Returns all elements except the last.  EXAMPLE:
           val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
           val newList:List[String] = myList.init
           println("newList = " + newList) // Prints:  newList = List(abc, def, ghi, jkl, mno)
___ last - Returns the last element.  EXAMPLE:
           val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
           val newList:String = myList.last
           println("newList = " + newList) // Prints:  newList = List(pqr)
___ patch - Calling the patch() method on a List returns a List where 1 or more elements of the List
            is removed from the List, and replaced by a GenSeq.  EXAMPLE:
            val list:List[Int]  = List(1, 2, 3, 4, 5)
            // Replace 2 elements beginning at index 0 with Nil...
            val list_2 = list.patch(0, Nil, 2) // list_2 = List(3, 4, 5)
            // Replace 1 element beginning at index 2 with Nil...
            val list_3 = list.patch(2, Nil, 1) // list_3 = List(1, 2, 4, 5)
___ slice - The slice() function is available in classes other than List, such as Array, String, etc.
            For String class, you could use the substring() function instead.
            EXAMPLE:
            val letters:List[Char] = List('a','b','c','d','e')
            // Return elements of the letters List from index 1 UNTIL index 3.
            val result:List[Char] = letters.slice(1,3)
            println("result = " + result) // PRINTS: result = List(b, c)
___ split - EXAMPLE:
            object Demo
            {
               def main(args: Array[String]): Unit =
               {
                  val myString:String =
                  "Each word in this String is separated by a blank-space character, which is considered " +
                  "the delimiter char.  This String of words is converted below to an Array[String] data type.  " +
                  "Where each element in this Array will contain a single word in this String.  " +
                  "No blank-space chars (the delimiter char.) will appear in the elements of this Array[String] " +
                  "because the split() method called below removes all space chars.  When this " +
                  "String prints, it will also print the Array index, which begins at zero."

                  println("myString.length = " + myString.length)
                  // The '+' in the following line means split on >= 1 of consecutive space chars.
                  // The '*' char would be used to split on >= 0 consecutive space chars.
                  var arrayString:Array[String] = myString.split(" +")
                  var count:Int = 0
                  for (tempString <- arrayString)
                  {
                     println(count + ") " + tempString)
                     count += 1
                  }

                  // The next line of code shows how to use 's' char as the delimiter, so the printed
                  // Array elements will NOT contain the lowercase 's' char.  The '+' in the following
                  // line means split on >= 1 of consecutive 's' chars.  The '*' char would be used
                  // in place of '+' to split on >= 0 consecutive 's' chars.
                  arrayString = myString.split("s+")
                  arrayString.foreach(println)
               }
            }

___ splitAt - EXAMPLE:
              // Split a single List into two separate Lists at List index 4...
              type StringListTuple        = (List[String], List[String])
              val myList:List[String]     = List("abc", "def", "ghi", "jkl", "mno", "pqr")
              val newList:StringListTuple = myList.splitAt(4) // newList is a tuple type.
              println("newList._1 = " + newList._1) // PRINTS: newList._1 = List(abc, def, ghi, jkl)
              println("newList._2 = " + newList._2) // PRINTS: newList._2 = List(mno, pqr)
              println("newList = " + newList)       // PRINTS: newList = (List(abc, def, ghi, jkl),List(mno, pqr))
___ take - EXAMPLE:
           // Return the first 4 elements of myList...
           val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
           val newList:List[String] = myList.take(4)
           println("newList = " + newList) // PRINTS: newList = List(abc, def, ghi, jkl)
___ takeRight - EXAMPLE:
                // Return the last 4 elements of myList...
                val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
                val newList:List[String] = myList.takeRight(4)
                println("newList = " + newList) // PRINTS: newList = List(ghi, jkl, mno, pqr)

BOOLEAN TESTS:
==============
___ contains - EXAMPLE:
               val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
               val result:Boolean = myList.contains("pqr")
               println("result = " + result) // Prints: result = true
___ endsWith - EXAMPLE:
               val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
               val result:Boolean = myList.endsWith(List("pqr"))
               println("result = " + result) // Prints: result = true
___ isEmpty - EXAMPLE:
              val myList1:List[String] = List()
              val myList2:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
              val result1:Boolean = myList1.isEmpty
              val result2:Boolean = myList2.isEmpty
              println("result1 = " + result1 + ",  result2 = " + result2) // PRINTS: result1 = true,  result2 = false
___ asInstanceOf[] - Used to cast one class/type to another class/type.  See code example for isInstanceOf[]
                     (directly below) to see how asInstanceOf[] is used.
___ isInstanceOf[] - The following code shows how to use isInstanceOf[] to determine the data type of some value.
                     NOTE: To determine a data value's class/type, you can also use Scala's "match" statement,
                           which may be preferable to using isInstanceOf[].
                     val array:Array[Char] = Array('1', '2', '3', '4')
                     val list_2:List[Any]  = List("one two three four", 12, 12.34F, 12.34D, array)
                     val myArray:Any   = list_2(4) // Obtains the 5th element of list_2, which is of type: Array[Char]
                     val isCharArray   = myArray.isInstanceOf[Array[Char]]
                     val isIntArray    = myArray.isInstanceOf[Array[Int]]
                     val isStringArray = myArray.isInstanceOf[Array[String]]
                     // The following line PRINTS:  isCharArray = true, isIntArray = false, isStringArray = false
                     println("isCharArray = " + isCharArray + ", isIntArray = " + isIntArray + ", isStringArray = " + isStringArray)

                     // The following code shows how to cast an Int to a Long using asInstanceOf[]...
                     val intValue:Int = 1234;
                     val castIntToLong:Long = intValue.asInstanceOf[Long]
                     println("castIntToLong = " + castIntToLong) // PRINTS: castIntToLong = 1234
                     // The following line PRINTS: castIntToLong.isInstanceOf[Long] = true
                     println("castIntToLong.isInstanceOf[Long] = " + castIntToLong.isInstanceOf[Long])

___ nonEmpty - The opposite of the isEmpty method.
___ startsWith - EXAMPLE:
                 val myList1:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
                 val myList2:List[String] = List("abc", "def")
                 val result:Boolean = myList1.startsWith(myList2)
                 println("result = " + result) // PRINTS: result = true


SEARCHING:
==========
___ find - EXAMPLE:
           Finds the FIRST ELEMENT of the sequence satisfying a predicate, if one exists.
           val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
           var result:Option[Int] = intList.find(_<4)
           println(result) // Prints: Some(3)
           result = intList.find(_>10)
           println(result) // PRINTS: None
___ indexOf - EXAMPLE:
              val myList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "mno")
              val result:Int = myList.indexOf("mno")
              println("result = " + result) // PRINTS: result = 4
___ lastIndexOf - EXAMPLE:
                  val myList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "mno") // NOTE: There are 2 "mno" strings.
                  val result:Int = myList.lastIndexOf("mno")
                  println("result = " + result) // PRINTS: result = 5
___ diff - Returns the DIFFERENCE between 2 Lists.  EXAMPLE:
           val myList1:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
           val myList2:List[String] = List("pqr", "mno", "jkl", "ghi", "def", "abc")
           val myList3:List[String] = List("mno", "abc")
           // result1 = every element in myList1 that does NOT exist in myList2
           val result1:List[String] = myList1.diff(myList2)
           // result2 = every element in myList1 that does NOT exist in myList3
           val result2:List[String] = myList1.diff(myList3)
           println("result1 = " + result1 + ", result2 = " + result2)
           // PRINTS: result1 = List(), result2 = List(def, ghi, jkl, pqr)
___ mkString EXAMPLE:
             val myList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
             println("myList                               = " + myList)
             println("myList.mkString                      = " + myList.mkString)
             println("myList.mkString(\" + \")               = " + myList.mkString(" + "))
             println("myList.mkString(\"BEGIN\", \"_\", \"END\") = " + myList.mkString("BEGIN", "_", "END"))
             // PRINTS THE FOLLOWING 4 LINES:
             myList                               = List(abc, def, ghi, jkl, mno, pqr)
             myList.mkString                      = abcdefghijklmnopqr
             myList.mkString(" + ")               = abc + def + ghi + jkl + mno + pqr
             myList.mkString("BEGIN", "_", "END") = BEGINabc_def_ghi_jkl_mno_pqrEND
___ reverse - EXAMPLE:
              val myList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
              println("myList.reverse = " + myList.reverse) // Prints:  myList.reverse = List(pqr, mno, jkl, ghi, def, abc)
___ toList  - EXAMPLE:
              val myArray:Array[String] = Array("abc", "def", "ghi", "jkl", "mno", "pqr")
              val myList:List[String]   = myArray.toList
              println(myList) // PRINTS: List(abc, def, ghi, jkl, mno, pqr)
___ toArray - EXAMPLE:
              val myList:List[String]   = List("abc", "def", "ghi", "jkl", "mno", "pqr")
              val myArray:Array[String] = myList.toArray
              myArray.foreach(println)
              // PRINTS THE FOLLOWING 6 LINES:
              abc
              def
              ghi
              jkl
              mno
              pqr
___ zip - EXAMPLE:
          val myList1:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
          val myList2:List[String] = List("stu", "vwx", "yz")
          println(myList1.zip(myList2)) // Prints:  List((abc,stu), (def,vwx), (ghi,yz))
___ zipWithIndex - When the zipWithIndex() function is called on a List, it returns a List of tuples.
                   Where the first tuple of the returned List contains the first element of the List
                   and the index of that first element, which will be 0 (zero).  Followed by the
                   second element of the List and the index of that second element, which will be
                   1 (one).  Etc.
                   EXAMPLE:
                   val myList:List[String]                = List("abc", "def", "ghi", "jkl", "mno", "pqr")
                   val myListWithIndex:List[(String,Int)] = myList.zipWithIndex
                   println("myListWithIndex = " + myListWithIndex)
                   println("myListWithIndex(2)._1 = " + myListWithIndex(2)._1 + ",  myListWithIndex(2)._2 = " + myListWithIndex(2)._2)
                   PRINTS THE FOLLOWING 2 LINES:
                   myListWithIndex = List((abc,0), (def,1), (ghi,2), (jkl,3), (mno,4), (pqr,5))
                   myListWithIndex(2)._1 = ghi,  myListWithIndex(2)._2 = 2
___ product - EXAMPLE:
              val myList:List[Float] = List(123.4F, 456.7F, 78.9F)
              println("myList.product = " + myList.product) // Prints: myList.product = 4446550.0
___ sum - EXAMPLE:
          val myList:List[Float] = List(123.4F, 456.7F, 789.1F)
          println("myList.sum = " + myList.sum) // Prints: myList.sum = 1369.2


HIGHER-ORDER METHODS, ETC.
==========================
Among this group of higher-order functions, there are specifically
TWO (2) of these functions that are widely used and very popular.
They are the filter() function and the map() function.  You should
make it a point to understand those two functions very well.

___ count - EXAMPLE:
            val myList:List[Float] = List(123.4F, 456.7F, 78.9F)
            println("myList.count = " + myList.count(_ > 100.0F)) // Prints: myList.count = 2
___ dropWhile - Also see the takeWhile method, which is the inverse of this dropWhile method.
                EXAMPLE:
                val strList:List[String] = List[String]("str1_abc_junk", "str2_abc_stuff", "str3_qrs_things", "str4_xyz_trash")
                val result:List[String] = strList.dropWhile(_.contains("abc"))
                result.foreach(println) // prints: str3_qrs_things  str4_xyz_trash
___ combinations - Also see the permutations function.
                   EXAMPLE:
                   val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
                   intList.combinations(3).foreach(println)
                   var count = 0
                   for (x <- intList.combinations(3))
                   {
                     count += 1
                     // Print the same intList.combinations(3) as the above call to foreach.
                     println("count = " + count + ", " + x)
                   }
___ exists - The exists method returns true if at least one element in the collection meets the condition.
             The forall method returns true if ALL elements in the collection meet the condition.
             EXAMPLE 1:
             val strList:List[String] = List[String]("str1_abc_junk", "str2_jkl_stuff", "str3_qrs_things", "str4_xyz_trash");
             val result:Boolean = strList.exists(_.compareTo("str3_qrs_things") == 0)
             println(result) // result = true
             EXAMPLE 2:
             val intList:List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7);
             val result:Boolean = intList.exists(x => x==7)
             println(result) // result = true
___ filter - NOTE: The difference between the filter() and map() functions are as follows:
                   The function passed to filter() returns a Boolean and gets applied to every
                   element in the List.  If the Boolean returned by that function is true,
                   then that element of the List gets returned by filter(), which constructs
                   a new List that IS A SUBSET of the original List--thus the name filter.

                   The map() function gets passed a function which gets applied to every element
                   in the List.  That function then returns a value for every element in the List
                   that is the same type contained in the List.  So List.map() returns a List
                   containing the same number of elements as the List that it's applied to.
                   
             EXAMPLE:
             val intList:List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7)
             val result_1:List[Int] = intList.filter(_ > 6)
             println(result_1) // PRINTS: List(7)

             // The following code shows TWO (2) ways of obtaining identical results by
             // calling the filter() function.  Both println() statements below print:
             // RMN
             // Randy_Reject
             val nameList:List[String] = List("TJB", "RMN", "Randy_Reject")
             var result_2:List[String] = nameList.filter(_.startsWith("R"))
             result_2.foreach(println) // PRINTS: RMN Randy_Reject
             result_2 = nameList.filter(x => x.startsWith("R"))
             result_2.foreach(println) // PRINTS: RMN Randy_Reject
___ filterNot - The opposite of the filter method.
___ flatMap - Also see --> https://github.com/w9mwi/Scala/blob/master/flatMap()_and_flatten()
              The flatMap() method is essentially a combination of the List.map method() run first,
              followed by the List.flatten() method run second.  The flatMap() method returns a List.

              TO UNDERSTAND EXACTLY HOW List.flatMap WORKS, UNDERSTAND THIS CODE...

              object Demo
              {
                def main(args: Array[String]):Unit =
                {
                  val list_1:List[Int] = List(1,2,3,4,5)
                  println("A) " + list_1)               // PRINTS: A) List(1, 2, 3, 4, 5)
                  println("B) " + list_1.map(i=>i*2))   // PRINTS: B) List(2, 4, 6, 8, 10)
                  println("C) " + list_1.flatMap(func)) // PRINTS: C) List(0, 1, 2, 1, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6)

                  // This is what happens when list_1.flatMap(func) is called:
                  // 1) flatMap first calls the map function on every element in list_1.
                  //    So the map function generates this result:
                  //    List(List(0, 1, 2), List(1, 2, 3), List(2, 3, 4), List(3, 4, 5), List(4, 5, 6))
                  //
                  // 2) After flatMap calls the map function, it then calls the flatten function
                  //    on the results of the map function.  So flatten transforms...
                  //    THIS:       List(List(0, 1, 2), List(1, 2, 3), List(2, 3, 4), List(3, 4, 5), List(4, 5, 6))
                  //    INTO THIS:  List(0, 1, 2, 1, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6)
                }

                def func(intNumber:Int):List[Int] = List(intNumber - 1, intNumber, intNumber + 1)
              }


              MORE EXAMPLES of using the flatMap() method...

              val fish:List[String]               = List[String]("alewife", "bass", "perch", "northern", "walleye")
              val waterBirds:List[String]         = List[String]("eagle", "duck", "goose")
              val waterAnimals:List[List[String]] = List[List[String]](fish, waterBirds)
              println("A) fish                             = " + fish)
              println("B) waterBirds                       = " + waterBirds)
              println("C) waterAnimals                     = " + waterAnimals)
              println("D) waterAnimals.map(x => x)         = " + waterAnimals.map(x => x)) // NOTE: map(x => x) changes nothing.
              println("E) waterAnimals.flatten             = " + waterAnimals.flatten)
              println("F) waterAnimals.map(x => x).flatten = " + waterAnimals.map(x => x).flatten)
              println("G) waterAnimals.flatMap(x => x)     = " + waterAnimals.flatMap(x => x))
              //  PRINTS THE FOLLOWING 7 LINES...
              //  A) fish                             = List(alewife, bass, perch, northern, walleye)
              //  B) waterBirds                       = List(eagle, duck, goose)
              //  C) waterAnimals                     = List(List(alewife, bass, perch, northern, walleye), List(eagle, duck, goose))
              //  D) waterAnimals.map(x => x)         = List(List(alewife, bass, perch, northern, walleye), List(eagle, duck, goose))
              //  E) waterAnimals.flatten             = List(alewife, bass, perch, northern, walleye, eagle, duck, goose)
              //  F) waterAnimals.map(x => x).flatten = List(alewife, bass, perch, northern, walleye, eagle, duck, goose)
              //  G) waterAnimals.flatMap(x => x)     = List(alewife, bass, perch, northern, walleye, eagle, duck, goose)

___ flatten - The flatten() method works ONLY on Scala collections that contain collections.
              Read the following sample code for examples.

            object Demo
            {
              def main(args:Array[String]): Unit = {
            
                // The flatten() method does NOT work on the following
                // intArray because it contains Int values, which are
                // NOT collections.
                val intArray:Array[Int] = Array(123, 456, 789)
                // intArray.flatten  // WON'T COMPILE!
                // *************************************************
            
                println("EXAMPLE 1)")
                // Here we DON'T call the flatten() method yet.
                // We print strArray only to show its contents.
                val strArray:Array[String] = Array("ABC", "XYZ")
                for (x <- strArray)  println(x) // PRINTS: ABC
                                                //         XYZ
                // *************************************************
            
                println("EXAMPLE 2)")
                // This result may be unexpected.  The flatten() method
                // WORKS on strArray because an Array[String] type in
                // Scala is built with an Array[Char] collection!
                val charArray:Array[Char] = strArray.flatten
                for (x <- charArray)  print(x)  // PRINTS: ABCXYZ
            
                // *************************************************
                // Here we flatten a List, where each of its elements
                // contains a Set.
                println("\nEXAMPLE 3)")
                val myList:List[Set[Int]] = List(Set(1, 2, 3), Set(9, 8, 7))
                println(myList.flatten) // PRINTS: List(1, 2, 3, 9, 8, 7)
                // *************************************************
            
                println("EXAMPLE 4)")
                // Here's one more example that's more complex.
                // REMEMBER: The flatten() method works ONLY on a
                //           collection that contains a collection.
                val vasc:Vector[Array[Set[Char]]] = Vector(Array(Set('A','B','C'), Set('D','E'), Set('F')),
                                                           Array(Set('X', 'Y', 'Z')))
                val vsc:Vector[Set[Char]] = vasc.flatten
                for (x <- vsc)  print(x + " ")  // PRINTS: Set(A, B, C) Set(D, E) Set(F) Set(X, Y, Z)
            
                println("\nEXAMPLE 5)")
                val vs:Vector[Char] = vsc.flatten
                for (x <- vs)  print(x + " ")  // PRINTS: A B C D E F X Y Z
              }
            }
             

___ fold      - SEE:  https://github.com/w9mwi/Scala/blob/master/Fold_Methods

___ foldLeft  - SEE:  https://github.com/w9mwi/Scala/blob/master/Fold_Methods

___ foldRight - SEE:  https://github.com/w9mwi/Scala/blob/master/Fold_Methods

___ forall - The forall method returns true if ALL elements in the collection meet the condition.
             The exists method returns true if at least one element in the collection meets the condition.
             EXAMPLE:
             val myList:List[Float] = List(123.4F, 456.7F, 78.9F)
             println("myList.forall = " + myList.forall(_ > 100.0F)) // Prints: myList.forall = false
             println("myList.forall = " + myList.forall(_ > 50.0F))  // Prints: myList.forall = true
___ foreach - This method gets passed a function that operates on all elements in the collection,
              and returns nothing.  This method is called only for its side effects.
              EXAMPLE:
              val myList:List[Float] = List(12.1F, 34.2F, 56.3F, 78.4F)
              myList.foreach(x => println(2.0F * x)) // Param passed to foreach is a literal function.
              PRINTS THE FOLLOWING 4 LINES:
              24.2
              68.4
              112.6
              156.8
___ grouped - Runs through the sequence, grouping items into groups of the specified size.
              EXAMPLE:
              val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
              intList.grouped(2).foreach(println) // PRINTS: List(7, 4)
                                                  //         List(6, 3)
              var count = 0                       //         List(9, 1)
              for (x <- intList.grouped(2))
              {
                 count += 1
                 // Print the same intList.grouped(2) as the above call to foreach.
                 println("count = " + count + ", " + x) // PRINTS: count = 1, List(7, 4)
              }                                         //         count = 2, List(6, 3)
                                                        //         count = 3, List(9, 1)

___ indexWhere - Pass this method a function that operates on a single element of the collection.
                 Returns the index of the FIRST element for which the function is true.  Returns
                 -1 if the function is NOT true for any of the elements.
                 EXAMPLE:
                 val myList:List[Float] = List(12.1F, 34.2F, 56.3F, 78.4F)
                 val result:Int = myList.indexWhere(_ > 50.0F)
                 println(result) // Prints: 2
___ inits - Provides an iterator going from the full sequence to an empty one, removing elements from the end.
                                                                 // The below println statement PRINTS:
            val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)  // count = 1, List(7, 4, 6, 3, 9, 1)
            var count = 0                                        // count = 2, List(7, 4, 6, 3, 9)
            for (x <- intList.inits)                             // count = 3, List(7, 4, 6, 3)
            {                                                    // count = 4, List(7, 4, 6)
              count += 1                                         // count = 5, List(7, 4)
              println("count = " + count + ", " + x)             // count = 6, List(7)
            }                                                    // count = 7, List()
___ lastIndexWhere - Pass this method a function that operates on a single element of the collection
                     and returns a Boolean.  This method returns the index of the LAST element for
                     which the function is true.  Returns -1 if the function is NOT true for any
                     of the elements.
                     EXAMPLE:
                     val myList:List[Float] = List(12.1F, 34.2F, 56.3F, 78.4F)
                     val result:Int = myList.lastIndexWhere(_ > 50.0F)
                     println(result) // Prints: 3
___ map - NOTE: The difference between the filter() and map() functions are as follows:
                The function passed to filter() returns a Boolean and gets applied to every
                element in the List.  If the Boolean returned by that function is true,
                then that element of the List gets returned by filter(), which constructs
                a new List that IS A SUBSET of the original List--thus the name filter.

                The map() function gets passed a function which gets applied to every element
                in the List.  That function then returns a value for every element in the List
                that is the same type contained in the List.  So List.map() returns a List
                containing the same number of elements as the List it gets applied to.
          EXAMPLE:
          val intList:List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7);
          val result:List[Int] = intList.map(_*2)
          println(result) //  prints: List(2, 4, 6, 8, 10, 12, 14)
___ partition - Pass this method a function that operates on a single element of the collection
                and returns a Boolean.  This method returns a tuple with TWO new collections.
                The first collection in the tuple contains only the elements for which the
                function is true.  The second collection in the tuple contains only the elements
                for which the function is false.
                EXAMPLE:
                val myList:List[Float] = List(43.7F, 567.89F, 144.8F, 77.7F, 17.7F)
                val result:(List[Float], List[Float]) = myList.partition(_ > 77.0F)
                println(result) // Prints: (List(567.89, 144.8, 77.7),List(43.7, 17.7))
___ permutations - Also see the combinations function.
                   EXAMPLE:
                   val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
                   intList.permutations.foreach(println)
                   var count = 0
                   for (x <- intList.permutations)
                   {
                     count += 1
                     // Print the same intList.permutations as the above call to foreach.
                     println("count = " + count + ", " + x)
                   }
___ reduce - The reduce, reduceLeft, and reduceRight methods always
             result in a single element being returned.
             Example:
             val myList:List[Int] = List(1, 2, 3, 4)
             println(myList.reduce(_ max _))         // PRINTS: 4
             println(myList.reduce((x, y) => x + y)) // PRINTS: 10
             println(myList.reduce((x, y) => x - y)) // PRINTS: -8
___ reduceLeft - See reduceRight.
___ reduceRight - EXAMPLE of reduceLeft and reduceRight:
    val myList:List[Int] = List(1, 2, 3, 4)
    var result:Int = myList.reduceLeft(_ + _) // result = ((1 + 2) + 3) + 4 = 10
    println("result = " + result) // Prints: 10

    result = myList.reduceRight(_ + _) // result = 1 + (2 + (3 + 4)) = 10
    println("result = " + result) // Prints: 10

    result = myList.reduceLeft(_ - _) // result = ((1 - 2) - 3) - 4 = -8
    println("result = " + result) // Prints: -8

    result = myList.reduceRight(_ - _) // result = 1 - (2 - (3 - 4)) = -2
    println("result = " + result) // Prints: -2

    result = myList.reduceLeft(_ * _) // result = ((1 * 2) * 3) * 4 = 24
    println("result = " + result) // Prints: 24

    result = myList.reduceRight(_ * _) // result = 1 * (2 * (3 * 4)) = 24
    println("result = " + result) // Prints: 24
___ sliding - Provides an iterator that gives the effect of sliding a window of a specified size across the sequence.
              EXAMPLE:
              val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
              intList.sliding(3).foreach(println)
              var count = 0
              for (x <- intList.sliding(3))
              {
                count += 1
                // Print the same intList.sliding(3) as the above call to foreach.
                println("count = " + count + ", " + x)
              }
___ tails - Gives an iterator that runs through sublists, starting with the full list, and ending
            with an empty list--removing one element from the left (removing the head) for each step,
            thus returning the tail.
            EXAMPLE:
            val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
            intList.tails.foreach(println)
            var count = 0
            for (x <- intList.tails)
            {
              count += 1
              // Print the same intList.tails as the above call to foreach.
              println("count = " + count + ", " + x)
            }
___ takeWhile - Also see the dropWhile method, which is the inverse of this takeWhile method.
                Pass this method a function that operates on a single element of the collection
                and returns a Boolean.  This method returns a new collection of all elements
                for which that function is true beginning with the first element.  As soon
                as an element is found for where the function returns false, nothing more
                is returned.  That's why the fourth println below prints the empty List (List()),
                because the function returns false for the first element in myList.

                val myList:List[Float] = List(43.7F, 17.7F, 77.7F, 567.89F, 144.8F)
                println("myList                       = " + myList)
                println("myList.takeWhile(_ == 43.7F) = " + myList.takeWhile(_ == 43.7F))
                println("myList.takeWhile(_ > 43.6F)  = " + myList.takeWhile(_ > 43.6F))
                println("myList.takeWhile(_ > 43.7F)  = " + myList.takeWhile(_ > 43.7F))
                println("myList.takeWhile(_ > 17.6F)  = " + myList.takeWhile(_ > 17.6F))
              // PRINTS THE FOLLOWING:
              // myList                       = List(43.7, 17.7, 77.7, 567.89, 144.8)
              // myList.takeWhile(_ == 43.7F) = List(43.7)
              // myList.takeWhile(_ > 43.6F)  = List(43.7)
              // myList.takeWhile(_ > 43.7F)  = List()
              // myList.takeWhile(_ > 17.6F)  = List(43.7, 17.7, 77.7, 567.89, 144.8)
