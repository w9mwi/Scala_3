LIST
====
A Scala List is immutable so it can't be altered/changed/updated after it's created.
If you want to alter/change/update a Scala List, you need to create a new List.
The following program demonstrates how to do that.

An empty List in Scala is designated by the keyword "Nil"; which is equivalent to: List()
In functional programming, Scala Lists are sometimes constructed recursively using the
"cons" operator (::), as shown in an example further below.  Nil serves as the
terminating condition for recursive operations on Scala Lists.

The List class inherits from the LinearSeq trait; NOT from the IndexedSeq trait.  This means
that accessing a List element via an index can take a long time because all elements in the
List (up to the index value) must be traversed.  You should avoid accessing elements of a
List via an index value, like this...

   myList(99)

A Scala List is a linked list which consists of a head and a tail.  A List's head
consists of only its first element; its tail consists of all remaining elements.
When a Scala List contains only a single element its head references that single
element; its tail references an empty List.  EXAMPLE:

   var intList: List[Int] = 123 :: Nil // Nil designates an empty List and is equivalent to: List()
   println(s"intList.head = ${intList.head}") // PRINTS: intList.head = 123
   println(s"intList.tail = ${intList.tail}") // PRINTS: intList.tail = List()
   intList = List(987)
   println(s"intList.head = ${intList.head}") // PRINTS: intList.head = 987
   println(s"intList.tail = ${intList.tail}") // PRINTS: intList.tail = List()

=============================================================================
@main def main():Unit =
  var intList:List[Int] = List(-666, 2, 3)
  println(s"1) intList = $intList") // PRINTS: 1) intList = List(-666, 2, 3)

  // To UPDATE ONE ELEMENT OF A LIST, call the List.updated() method.
  // The updated() method returns a new List.
  intList = intList.updated(0, 1) // 0 = the List index, 1 = the value
  println(s"2) intList = $intList") // PRINTS: 2) intList = List(1, 2, 3)

  // To PREPEND ONE ELEMENT TO A LIST, use the :: operator, or the +: operator.
  // The :: operator is called the "cons" operator; short for the word "construct."
  // The +: operator is known as the "list prepend operator."
  // Both these operators return a new List.
  intList = 0 :: intList
  println(s"3) intList = $intList") // PRINTS: 3) intList = List(0, 1, 2, 3)
  intList = -1 +: intList
  println(s"4) intList = $intList") // PRINTS: 4) intList = List(-1, 0, 1, 2, 3)

  // To APPEND ONE ELEMENT to a List, use the :+ operator.
  // The :+ operator is known as the "list append operator."
  // This returns a new List.
  intList = intList :+ 4
  println(s"5) intList = $intList") // PRINTS: 5) intList = List(-1, 0, 1, 2, 3, 4)

  // To CONCAT A LIST to another List, use the ::: operator.  The ::: operator
  // is known as the "list concatenation operator."  This returns a new List.
  intList = List(-4, -3, -2) ::: intList ::: List(5, 6, 7)
  println(s"6) intList = $intList") // PRINTS: 6) intList = List(-4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7)
  
  // THIS LINE WON'T COMPILE  -->  intList = intList :: List(8, 9)
  // The above commented-out line won't compile because the cons operator (::)
  // requires the first operand to be a value, not a List.  To make the above
  // line compile, change the cons operator (::) to the list contact operator
  // (:::) as shown in the following line of code.
  intList = intList ::: List(8, 9)
  println(s"7) intList == $intList") // PRINTS: 7) intList == List(-4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

  // An EMPTY LIST in Scala is designated by the keyword "Nil"; which is equivalent to: List()
  intList = Nil
  println(s"8) intList == $intList") // PRINTS: 8) intList == List()
  intList = List()
  println(s"9) intList == $intList") // PRINTS: 9) intList == List()

  // Nil can be used in PATTERN MATCHING, like this...
  intList match
    case head :: tail => println(s"10) intList is NOT empty.")
    case Nil          => println(s"10) intList IS empty.") // PRINTS: 10) intList IS empty.

  // When constructing a List using only "cons" operators (::), the last element
  // in the List must be an empty List; designated by either List() or Nil.
  intList = -9 :: -8 :: -7 :: List()
  println(s"11) intList = $intList") // PRINTS: 11) intList = List(-9, -8, -7)
  intList = 7 :: 8 :: 9 :: Nil
  println(s"12) intList = $intList") // PRINTS: 12) intList = List(7, 8, 9)
end main
=============================================================================

@main def main():Unit =
  val myList: List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7);

  println("operateOnList_1() result = " + operateOnList_1(myList, _ + _))
  println("operateOnList_2() result = " + operateOnList_2(myList, _ + _))

  /**
   * THIS IS A RECURSIVE FUNCTION!
   * This function is identical in behavior to
   * the operateOnList_2() function below.
   */
  def operateOnList_1(list:List[Int], func:(Int, Int) => Int):Int = {
    if (list.tail.isEmpty)
      list.head
    else
      func(list.head, operateOnList_1(list.tail, func))
  }

  /**
   * THIS IS A RECURSIVE FUNCTION!
   * This function is identical in behavior to the
   * operateOnList_1() function above.
   */
  def operateOnList_2(list:List[Int], func:(Int, Int) => Int):Int = {
    list match {
      case head::Nil  => head  // This line executes when there's only one element in the List.
      case head::tail => func(head, operateOnList_2(tail, func))
      // NOTE: In this example, the following line never executes
      //       because the first two lines of this match statement
      //       match all possible scenarios.
      case _ => 0
    }
  }
end main

