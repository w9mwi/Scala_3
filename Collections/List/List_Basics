LIST BASICS
============

A Scala List is immutable so it can't be changed after it's created.
To "change" the contents of a List actually involves creating an
entirely new List that contains the changes.  The following program
demonstrates how that's done.

The List class inherits from the LinearSeq trait; NOT from the IndexedSeq trait.
This means that accessing a List element via an index can take a long time
because all elements in the List (up to the index value) must be traversed.

Although the following code works, you should avoid accessing elements
of a List via an index value, like this...

   myList(99)

The following sample code demonstrates these List basics:

  * An empty List.
  * Three different ways to construct an equivalent List.
  * A List's head.
  * A List's tail.

@main def main():Unit =
  var intList:List[Int] = List() // List() is an empty List.
  println(s"1) intList = $intList,  intList.isEmpty = ${intList.isEmpty}")
  // PRINTS: 1) intList = List(),  intList.isEmpty = true

  intList = Nil // Nil is also an empty List.
  println(s"2) intList = $intList,  intList.isEmpty = ${intList.isEmpty}")
  // PRINTS: 2) intList = List(),  intList.isEmpty = true

  // The following 3 ways of building a List are all equivalent.
  intList = 111 +: 222 +: 333 +: Nil
  println(s"3) intList = $intList") // PRINTS: 3) intList = List(111, 222, 333)
  intList = 111 +: 222 +: 333 +: List()
  println(s"4) intList = $intList") // PRINTS: 4) intList = List(111, 222, 333)
  intList = List(111, 222, 333)
  println(s"5) intList = $intList") // PRINTS: 5) intList = List(111, 222, 333)

  // The head of a List consists of only its first element.
  // The tail of a List consists all its elements except the head.
  println(s"6) intList.head = ${intList.head},  intList.tail = ${intList.tail}")
  // PRINTS: 6) intList.head = 111,  intList.tail = List(222, 333)

  // The last element of a List is always an empty List, even
  // though it doesn't appear when you print the List's contents.
  // However, when you reference the tail of 1-element List,
  // you'll see the List's tail is an empty List.
  intList = List(123)
  println(s"7) intList = $intList,  intList.head = ${intList.head},  intList.tail = ${intList.tail}")
  // PRINTS: 7) intList = List(123),  intList.head = 123,  intList.tail = List()
end main

=============================================================================

@main def main():Unit =
  var intList:List[Int] = List(-666, 2, 3)
  println(s"1) intList = $intList") // PRINTS: 1) intList = List(-666, 2, 3)

  // To UPDATE ONE ELEMENT OF A LIST, call the List.updated() method.
  // The updated() method returns a new List.
  intList = intList.updated(0, 1) // 0 = the List index, 1 = the value
  println(s"2) intList = $intList") // PRINTS: 2) intList = List(1, 2, 3)

  // To PREPEND ONE ELEMENT TO A LIST, use the :: operator, or the +: operator.
  // The :: operator is called the "cons" operator; short for the word "construct."
  // The +: operator is known as the "list prepend operator."
  // Both these operators return a new List.
  intList = 0 :: intList
  println(s"3) intList = $intList") // PRINTS: 3) intList = List(0, 1, 2, 3)
  intList = -1 +: intList
  println(s"4) intList = $intList") // PRINTS: 4) intList = List(-1, 0, 1, 2, 3)

  // To APPEND ONE ELEMENT to a List, use the :+ operator.
  // The :+ operator is known as the "list append operator."
  // This returns a new List.
  intList = intList :+ 4
  println(s"5) intList = $intList") // PRINTS: 5) intList = List(-1, 0, 1, 2, 3, 4)

  // To CONCAT A LIST to another List, use the ::: operator.  The ::: operator
  // is known as the "list concatenation operator."  This returns a new List.
  intList = List(-4, -3, -2) ::: intList ::: List(5, 6, 7)
  println(s"6) intList = $intList") // PRINTS: 6) intList = List(-4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7)
  
  // THIS LINE WON'T COMPILE  -->  intList = intList :: List(8, 9)
  // The above commented-out line won't compile because the cons operator (::)
  // requires the first operand to be a value, not a List.  To make the above
  // line compile, change the cons operator (::) to the list contact operator
  // (:::) as shown in the following line of code.
  intList = intList ::: List(8, 9)
  println(s"7) intList == $intList") // PRINTS: 7) intList == List(-4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

  // An EMPTY LIST in Scala is designated by the keyword "Nil"; which is equivalent to: List()
  intList = Nil
  println(s"8) intList == $intList") // PRINTS: 8) intList == List()
  intList = List()
  println(s"9) intList == $intList") // PRINTS: 9) intList == List()

  // Nil can be used in PATTERN MATCHING, like this...
  intList match
    case head :: tail => println(s"10) intList is NOT empty.")
    case Nil          => println(s"10) intList IS empty.") // PRINTS: 10) intList IS empty.

  // When constructing a List using only "cons" operators (::), the last element
  // in the List must be an empty List; designated by either List() or Nil.
  intList = -9 :: -8 :: -7 :: List()
  println(s"11) intList = $intList") // PRINTS: 11) intList = List(-9, -8, -7)
  intList = 7 :: 8 :: 9 :: Nil
  println(s"12) intList = $intList") // PRINTS: 12) intList = List(7, 8, 9)
end main
=============================================================================

@main def main():Unit =
  val myList: List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7);

  println("operateOnList_1() result = " + operateOnList_1(myList, _ + _))
  println("operateOnList_2() result = " + operateOnList_2(myList, _ + _))

  /**
   * THIS IS A RECURSIVE FUNCTION!
   * This function is identical in behavior to
   * the operateOnList_2() function below.
   */
  def operateOnList_1(list:List[Int], func:(Int, Int) => Int):Int = {
    if (list.tail.isEmpty)
      list.head
    else
      func(list.head, operateOnList_1(list.tail, func))
  }

  /**
   * THIS IS A RECURSIVE FUNCTION!
   * This function is identical in behavior to the
   * operateOnList_1() function above.
   */
  def operateOnList_2(list:List[Int], func:(Int, Int) => Int):Int = {
    list match {
      case head::Nil  => head  // This line executes when there's only one element in the List.
      case head::tail => func(head, operateOnList_2(tail, func))
      // NOTE: In this example, the following line never executes
      //       because the first two lines of this match statement
      //       match all possible scenarios.
      case _ => 0
    }
  }
end main
