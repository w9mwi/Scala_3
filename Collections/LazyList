Before reading this LazyList section you should understand
how a regular Scala List works by reading this section:

https://github.com/w9mwi/Scala_3/blob/main/Collections/List

Like a regular Scala List, a LazyList is also immutable.

A Scala LazyList generates/computes its elements not when it's constructed/built,
but only when one or more of its elements is referenced at runtime.  (See the
following code sample to see this demonstrated.)  This allows for efficient
handling of large or even infinite sequences.  This "lazy evaluation" is the
primary reason for using a LazyList.

The #:: operator is used to prepend a single element to an existing LazyList,
and is demonstrated in the following program.

===================================================================================
@main def main() =
  // *******************************************************************
  // This section demonstrates that a LazyList doesn't get computed when
  // it's constructed, as the following two println statements reveal.
  // NOTICE:  The Scala keyword "Nil" cannot be used with a LazyList.
  //          Instead, LazyList.empty is used, as shown here...
  val lazyList_1:LazyList[Int] = 1 #:: 2 #:: 3 #:: LazyList.empty
  println(s"lazyList_1 = $lazyList_1") // PRINTS: lazyList_1 = LazyList(<not computed>)

  val lazyList_2:LazyList[Int] = -1 #:: 0 #:: lazyList_1
  println(s"lazyList_2 = $lazyList_2") // PRINTS: lazyList_2 = LazyList(<not computed>)

  // *******************************************************************
  // This section demonstrates the contents of lazyList_2 are generated
  // (computed) only when its elements are referenced, as the following
  // two println statements reveal.
  for (x <- lazyList_2) print(s"x = $x, ") // PRINTS: x = -1, x = 0, x = 1, x = 2, x = 3,

  println(s"\nlazyList_2 = $lazyList_2") // PRINTS: lazyList_2 = LazyList(-1, 0, 1, 2, 3)
===================================================================================

The following program uses a LazyList and the recursive fib() method
to compute fibonacci numbers.

===================================================================================
/**********************************************************
* This fib() method is RECURSIVE
**********************************************************/
def fib(a: BigInt, b: BigInt): LazyList[BigInt] =
  a #:: fib(b, a + b)
end fib

/***********************************************************
* This fibonacci() method calls the RECURSIVE fib() method.
***********************************************************/
def fibonacci: LazyList[BigInt] = fib(0, 1)
end fibonacci

@main def main() =
  // The following call to take(11) constructs a LazyList of 11 elements.
  // The number passed to the take() method is what forces the recursive
  // fib() method to terminate, as it reaches the last element of the LazyList.
  val lazyListResult: LazyList[BigInt] = fibonacci.take(11)

  // At this point lazyListResult won't show the result because
  // it doesn't get generated/computed until one or more of its
  // elements are accessed.
  println(s"lazyListResult = $lazyListResult,  lazyListResult.size = ${lazyListResult.size}")
  // PRINTS: lazyListResult = LazyList(<not computed>),  lazyListResult.size = 11

  for (x <- lazyListResult) print(s"x = $x, ")
  // PRINTS: x = 0, x = 1, x = 1, x = 2, x = 3, x = 5, x = 8, x = 13, x = 21, x = 34, x = 55,

  // Convert the LazyList to a regular List.
  val listResult: List[BigInt] = lazyListResult.toList
  println(s"\nlistResult = $listResult")
  // PRINTS: listResult = List(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55)
end main
===================================================================================
