LAZY EVALUATION
===============
Lazy evaluation means that the code associated with a lazy declaration
isn't executed when it's declared; it's executed only when the declared
val is referenced the first time.

To declare a val as 'lazy', you must prepend the Scala "lazy" keyword
to its declaration, as shown in the code sample below.

NOTE:  Only a Scala val (not a var) can be declared as 'lazy'.

       // The following line WON'T COMPILE because a var can't be declared as lazy.
       lazy var number:Int = 111

       // The following line WILL COMPILE because a val can be declared as lazy.
       lazy val number:Int = 111

When a val/var is declared without the 'lazy' keyword, the declaration is executed
immediately.  This is known as "EAGER EVALUATION" or "STRICT EVALUATION", which
applies to the vast majority of val/var declarations.

=======================================================================
@main def main():Unit =
  // The following line of code won't execute upon its declaration
  // because number_1 is a "lazy" declaration.
  lazy val number_1:Int = { println("This line prints SECOND."); 111 }

  // The following line of code will execute upon its declaration
  // because number_2 is a regular (not lazy) declaration.
  val number_2:Int = { println("This line prints FIRST."); 222 }

  // A lazy declaration executes only when it's referenced the
  // first time.  The following line of code contains the first
  // reference to number_1, which forces the code associated
  // with the number_1 declaration to be executed.
  println(s"number_1 = $number_1")  // PRINTS: This line prints SECOND.
                                    //         number_1 = 111

  // The following line of code demonstrates the println statement
  // contained within the declarations of number_1 and number_2 will
  // no longer execute; because a declaration is executed only one
  // time, whether the declaration is lazy or not.
  println(s"number_1 = $number_1,  number_2 = $number_2")
  // PRINTS: number_1 = 111,  number_2 = 222
end main
=======================================================================

LazyList
========
Scala contains a LazyList class that differs from the regular List class.
The reason to use a LazyList (instead of a regular List) has to do with
memory and performance issues.  A LazyList stores only the computed
elements of the list in memory, instead of storing all elements of the
list in memory.

The following three declarations demonstrate two different forms of lazy
evaluation.  The first form of lazy evaluation occurs by prepending the
'lazy' keyword to the "val intlist" declaration.  The second form of lazy
evaluation occurs when using a LazyList.

1)  lazy val intList:List[Int] = List(1, 2, 3)

    The val intList is declared 'lazy', which means means intList gets initialized
    not when it's declared, but only the first time intList is referenced.  Since
    intList points to a regular List (not a LazyList), there is no lazy evaluation
    performed on the List.

2)  val intlist:LazyList[Int] = LazyList(1, 2, 3)

    The val intList is not declared 'lazy', so intList gets initialized upon its
    declaration.  The elements of a LazyList are always 'lazy', so LazyList
    allocates memory for each element only the first time that element is
    referenced; instead of allocating memory for all its elements as a List does.

3)  lazy val intList:LazyList[Int] = LazyList(1, 2, 3)

    The val intList is declared 'lazy', which means means intList gets initialized
    not when it's declared, but only the first time intList is referenced.  The
    elements of a LazyList are always 'lazy', so LazyList allocates memory for
    each element only the first time that element is referenced; instead of
    allocating memory for all its elements as a List does.

NOTE: When declaring a LazyList, you should always prepend the 'lazy'
      keyword to the val, as shown in example 3) above.

The reason for using a LazyList instead of a List has to do with memory
and performance issues.  A LazyList allocates memory for each of its
elements only when the element is referenced; instead of allocating
memory for all its elements upon its declaration, as a List does.

NOTE: The following code sample uses the #:: operator, which prepends
      a single element to an existing LazyList.

=======================================================================
import scala.collection.immutable.LazyList

@main def main():Unit =
  // The following line of code defines and calculates a Fibonacci
  // sequence from 0 to the value passed to the fibs.take() method
  // in the println() below.  This is how it works:
  // 1) The first two numbers of a Fibonnacci sequence are always
  //    0 and 1 because Fibonnacci(0) = 0, Fibonnacci(1) = 1.
  //    Therefore, the val fibs gets initialized to this:
  //    BigInt(0) #:: BigInt(1) #:: fibs
  //    (The size of fibs isn't specified, which is what we want.)
  // 2) When fibs.zip(fibs.tail) is invoked, the zip function returns
  //    a LazyList with each of its elements containing a BigInt
  //    tuple, like this:
  //   (0,1)
  //   (1,1)
  //   (1,2)
  //   (2,3)
  //   ...
  // 3) For each BigInt tuple element in fibs, the map() function
  //    is invoked, returning the sum of the tuple in a single
  //    element of LazyList.  That's how each element of fibs
  //    gets constructed.
  //
  // MORE NOTES REGARDING THE FOLLOWING LINE OF CODE
  // 1) The val fibs appears on BOTH SIDES of the equals sign (=).
  //    The lazy keyword is what permits that behavior.  This
  //    line of code won't compile if you remove the keyword lazy.
  // 3) The #:: operator prepends a single element to an existing LazyList.
  // 4) The 'case' keyword appears in the following line, but removing
  //    it doesn't change behavior, so it's not required.
  lazy val fibs:LazyList[BigInt] =
    BigInt(0) #:: BigInt(1) #:: fibs.zip(fibs.tail).map { case (a, b) => a + b }
  println(fibs.take(10).toList) // PRINTS:  List(0, 1, 1, 2, 3, 5, 8, 13, 21, 34)

  // The following 2 lines of code obtain the same result as
  // the above 2 lines of code.  Here, the fibonacci numbers
  // are obtained via the RECURSIVE fibonacci method below.
  lazy val fibs2:LazyList[BigInt] = fibonacci(0, 1).take(10)
  println(fibs2.toList) // PRINTS:  List(0, 1, 1, 2, 3, 5, 8, 13, 21, 34)

  /**********************************************************
  * This fibonacci() method is RECURSIVE.
  **********************************************************/
  def fibonacci(a: BigInt, b: BigInt): LazyList[BigInt] =
    a #:: fibonacci(b, a + b)
  end fibonacci
end main
=======================================================================

The following code sample shows how to generate a list of
prime numbers using a LazyList.  Where, as usual, the size
of the LazyList is undefined until it's executed.

@main def main():Unit =
  // isPrime determines if the Int value passed to it is a prime number.
  def isPrime(n: Int): Boolean = (2 to Math.sqrt(n).toInt).forall(n % _ != 0)

  // The following LazyList represents all prime numbers.
  val primes: LazyList[Int] = LazyList.from(2).filter(isPrime)

  // Take the first 10 prime numbers.
  val firstTenPrimes = primes.take(10).toList
  println(s"firstTenPrime =  $firstTenPrimes")
  // PRINTS:  firstTenPrime =  List(2, 3, 5, 7, 11, 13, 17, 19, 23, 29)
end main
=======================================================================
