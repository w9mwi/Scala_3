LAZY EVALUATION
===============
When you declare a val or var, you can prepend the Scala "lazy" keyword
to the declaration, as is demonstrated in the following code sample.

Lazy evaluation means that the code associated with a lazy declaration
isn't executed when it's declared; it's executed only when the declared
val or var is referenced the first time.  Read in-line comments in the
code sample below to understand how this works.

@main def main():Unit =
  // The following line of code won't execute upon its declaration
  // because number_1 is a "lazy" declaration.
  lazy val number_1:Int = { println("This line prints SECOND."); 111 }

  // The following line of code will execute upon its declaration
  // because number_2 is a regular (not lazy) declaration.
  val number_2:Int = { println("This line prints FIRST."); 222 }

  // A lazy declaration executes only when it's referenced the
  // first time.  The following line of code contains the first
  // reference to number_1, which forces the code associated
  // with the number_1 declaration to be executed.
  println(s"number_1 = $number_1")  // PRINTS: This line prints SECOND.
                                    //         number_1 = 111

  // The following line of code demonstrates the println statement
  // contained within the declaration of number_1 and number_2 will
  // no longer execute because declarations are executed only one
  // time, whether it's lazy or not.
  println(s"number_1 = $number_1,  number_2 = $number_2")
  // PRINTS: number_1 = 111,  number_2 = 222
end main
=======================================================================


LAZY LIST
=========
A LazyList generates/computes its elements not when it's declared/constructed,
but only when one or more of its elements is referenced at runtime.  (The following
code sample demonstrates this.)  This allows for efficient handling of large, or even
infinite, sequences.  This is the primary reason for using a LazyList instead of
a regular List.

The #:: operator is used to prepend a single element to an existing LazyList,
and is demonstrated in the following program.

===================================================================================
@main def main() =
  // *******************************************************************
  // This section demonstrates that a LazyList doesn't get computed when
  // it's constructed, as the following two println statements reveal.
  // NOTICE:  The Scala keyword "Nil" cannot be used with a LazyList.
  //          Instead, LazyList.empty is used, as shown here...
  val lazyList_1:LazyList[Int] = 1 #:: 2 #:: 3 #:: LazyList.empty
  println(s"lazyList_1 = $lazyList_1") // PRINTS: lazyList_1 = LazyList(<not computed>)

  val lazyList_2:LazyList[Int] = -1 #:: 0 #:: lazyList_1
  println(s"lazyList_2 = $lazyList_2") // PRINTS: lazyList_2 = LazyList(<not computed>)

  // *******************************************************************
  // This section demonstrates the contents of lazyList_2 are generated
  // (computed) only when its elements are referenced, as the following
  // two println statements reveal.
  for (x <- lazyList_2) print(s"x = $x, ") // PRINTS: x = -1, x = 0, x = 1, x = 2, x = 3,

  println(s"\nlazyList_2 = $lazyList_2") // PRINTS: lazyList_2 = LazyList(-1, 0, 1, 2, 3)
===================================================================================

The following program uses a LazyList and the recursive fibonacci() method
to compute fibonacci numbers.

===================================================================================
/**********************************************************
* This fibonacci() method is RECURSIVE
**********************************************************/
def fibonacci(a: BigInt, b: BigInt): LazyList[BigInt] =
  a #:: fibonacci(b, a + b)
end fibonacci

@main def main() =
  // The following call to take(11) constructs a LazyList of 11 elements.
  // The number passed to the take() method is what forces the recursive
  // fibonacci() method to terminate when it reaches the last element
  // of the LazyList.
  val fibonacciLazyList: LazyList[BigInt] = fibonacci(0, 1).take(11)

  // At this point fibonacciLazyList won't show the result because
  // that result doesn't get generated/computed until at least one
  // element of the LazyList is accessed.
  println(s"fibonacciLazyList = $fibonacciLazyList,  fibonacciLazyList.size = ${fibonacciLazyList.size}")
  // PRINTS: fibonacciLazyList = LazyList(<not computed>),  fibonacciLazyList.size = 11

  // Here we finally access elements of fibonacciLazyList;
  // which triggers the result to be generated/computed.
  for (x <- fibonacciLazyList) print(s"x = $x, ")
  // PRINTS: x = 0, x = 1, x = 1, x = 2, x = 3, x = 5, x = 8, x = 13, x = 21, x = 34, x = 55,

  // Convert the LazyList to a regular List.
  val listResult: List[BigInt] = fibonacciLazyList.toList
  println(s"\nlistResult = $listResult")
  // PRINTS: listResult = List(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55)
end main
===================================================================================
