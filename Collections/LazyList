LAZY EVALUATION
===============
Lazy evaluation means that the code associated with a lazy declaration
isn't executed when it's declared; it's executed only when the declared
val is referenced the first time.

When a val/var is declared without the 'lazy' keyword, the declaration
is executed immediately.  This is known as "EAGER EVALUATION", which
applies to the vast majority of declarations.

To declare a val as 'lazy', you must prepend the Scala "lazy" keyword
to its declaration, as shown in the code sample below.

NOTE:  Only a Scala val (not a var) can be declared as 'lazy'.

       // The following line WON'T COMPILE because a var can't be declared as lazy.
       lazy var number:Int = 111

       // The following line WILL COMPILE because a val can be declared as lazy.
       lazy val number:Int = 111

=======================================================================
@main def main():Unit =
  // The following line of code won't execute upon its declaration
  // because number_1 is a "lazy" declaration.
  lazy val number_1:Int = { println("This line prints SECOND."); 111 }

  // The following line of code will execute upon its declaration
  // because number_2 is a regular (not lazy) declaration.
  val number_2:Int = { println("This line prints FIRST."); 222 }

  // A lazy declaration executes only when it's referenced the
  // first time.  The following line of code contains the first
  // reference to number_1, which forces the code associated
  // with the number_1 declaration to be executed.
  println(s"number_1 = $number_1")  // PRINTS: This line prints SECOND.
                                    //         number_1 = 111

  // The following line of code demonstrates the println statement
  // contained within the declarations of number_1 and number_2 will
  // no longer execute; because a declaration is executed only one
  // time, whether the declaration is lazy or not.
  println(s"number_1 = $number_1,  number_2 = $number_2")
  // PRINTS: number_1 = 111,  number_2 = 222
end main
=======================================================================

LazyList
========
Scala contains a LazyList class that differs from the regular List class.
The reason to use a LazyList (instead of a regular List) has to do with
memory and performance issues.  A LazyList can store only the computed
parts (the results) of the list in memory, instead of storing all elements
of the list in memory.

The following three List declarations are "lazy", but their "lazy" behavior
differs as explained below.

1)  lazy val intlist:List[Int] = List(1, 2, 3)

    The val intList is declared 'lazy'.  This means intList gets initialized
    not when it's declared, but only the first time intList is referenced.
    Since intList points to a regular List (not a LazyList), all elements of
    List are computed and stored in memory the first time intList is referenced.

2)  val intlist:LazyList[Int] = LazyList(1, 2, 3)

    The val intList is not declared 'lazy', so intList gets initialized upon
    its declaration.  The elements of a LazyList are always 'lazy', so each
    element of LazyList is computed only the first time the element referenced.

3)  lazy val intlist:LazyList[Int] = LazyList(1, 2, 3)

    The val intList is declared 'lazy'.  This means intList gets initialized
    not when it's declared, but only the first time intList is referenced.
    The elements of a LazyList are always 'lazy', so each element of LazyList
    is computed only the first time the element referenced.

NOTE: When using a LazyList, you should always declare the val to which
      the LazyList gets assigned as lazy; as shown in example 3) above.

The reason for using a lazy declaration (instead of a regular declaration)
has to do with memory and performance issues.  A lazy declaration will
store only the computed parts (the results) of a val, or a collection,
in memory; instead of allocating all memory space when it's declared.

The most common use for a lazy declaration is to represent a sequence
that's extremely large, or theoretically infinite.  Since the collection's
elements are only computed when requested, you can define an infinite
series and then take only a finite portion of the collection to work with.
The following code sample demonstrates using a LazyList for this purpose.

=======================================================================
import scala.collection.immutable.LazyList

import scala.collection.immutable.LazyList

@main def main():Unit =
  // Define an infinite Fibonacci sequence, and assign it to lazy val fibs.
  //
  // NOTICE:  The lazy val "fibs" appears on BOTH SIDES of the equals sign (=).
  //          The following line of code WON'T COMPILE if you remove the
  //          keyword "lazy".  Only when the val "fibs" is declared "lazy"
  //          can "fibs" appear on both sides of the equals sign (=).
  lazy val fibs:LazyList[BigInt] =
    BigInt(0) #:: BigInt(1) #:: fibs.zip(fibs.tail).map { case (a, b) => a + b }

  // Take the first 10 elements of fibs for evaluation...
  var tenFibs = fibs.take(10).toList
  println(tenFibs) // PRINTS:  List(0, 1, 1, 2, 3, 5, 8, 13, 21, 34)
end main
=======================================================================


LAZY LIST
=========
A LazyList generates/computes its elements not when it's declared/constructed,
but only when one or more of its elements is referenced at runtime.  (The following
code sample demonstrates this.)  This allows for efficient handling of large, or even
infinite, sequences.  This is the primary reason for using a LazyList instead of
a regular List.

The #:: operator is used to prepend a single element to an existing LazyList,
and is demonstrated in the following program.

===================================================================================
@main def main() =
  // *******************************************************************
  // This section demonstrates that a LazyList doesn't get computed when
  // it's constructed, as the following two println statements reveal.
  // NOTICE:  The Scala keyword "Nil" cannot be used with a LazyList.
  //          Instead, LazyList.empty is used, as shown here...
  val lazyList_1:LazyList[Int] = 1 #:: 2 #:: 3 #:: LazyList.empty
  println(s"lazyList_1 = $lazyList_1") // PRINTS: lazyList_1 = LazyList(<not computed>)

  val lazyList_2:LazyList[Int] = -1 #:: 0 #:: lazyList_1
  println(s"lazyList_2 = $lazyList_2") // PRINTS: lazyList_2 = LazyList(<not computed>)

  // *******************************************************************
  // This section demonstrates the contents of lazyList_2 are generated
  // (computed) only when its elements are referenced, as the following
  // two println statements reveal.
  for (x <- lazyList_2) print(s"x = $x, ") // PRINTS: x = -1, x = 0, x = 1, x = 2, x = 3,

  println(s"\nlazyList_2 = $lazyList_2") // PRINTS: lazyList_2 = LazyList(-1, 0, 1, 2, 3)
===================================================================================

The following program uses a LazyList and the recursive fibonacci() method
to compute fibonacci numbers.

===================================================================================
/**********************************************************
* This fibonacci() method is RECURSIVE
**********************************************************/
def fibonacci(a: BigInt, b: BigInt): LazyList[BigInt] =
  a #:: fibonacci(b, a + b)
end fibonacci

@main def main() =
  // The following call to take(11) constructs a LazyList of 11 elements.
  // The number passed to the take() method is what forces the recursive
  // fibonacci() method to terminate when it reaches the last element
  // of the LazyList.
  val fibonacciLazyList: LazyList[BigInt] = fibonacci(0, 1).take(11)

  // At this point fibonacciLazyList won't show the result because
  // that result doesn't get generated/computed until at least one
  // element of the LazyList is accessed.
  println(s"fibonacciLazyList = $fibonacciLazyList,  fibonacciLazyList.size = ${fibonacciLazyList.size}")
  // PRINTS: fibonacciLazyList = LazyList(<not computed>),  fibonacciLazyList.size = 11

  // Here we finally access elements of fibonacciLazyList;
  // which triggers the result to be generated/computed.
  for (x <- fibonacciLazyList) print(s"x = $x, ")
  // PRINTS: x = 0, x = 1, x = 1, x = 2, x = 3, x = 5, x = 8, x = 13, x = 21, x = 34, x = 55,

  // Convert the LazyList to a regular List.
  val listResult: List[BigInt] = fibonacciLazyList.toList
  println(s"\nlistResult = $listResult")
  // PRINTS: listResult = List(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55)
end main
===================================================================================
