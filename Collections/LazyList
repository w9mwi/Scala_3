LAZY EVALUATION
===============
Lazy evaluation means that the code associated with a lazy declaration
isn't executed when it's declared; it's executed only when the declared
val is referenced the first time.

To declare a val as 'lazy', you must prepend the Scala "lazy" keyword
to its declaration, as shown in the code sample below.

NOTE:  Only a Scala val (not a var) can be declared as 'lazy'.

       // The following line WON'T COMPILE because a var can't be declared as lazy.
       lazy var number_1:Int =  111

       // The following line WILL COMPILE because a val can be declared as lazy.
       lazy var number_1:Int =  111

=======================================================================
@main def main():Unit =
  // The following line of code won't execute upon its declaration
  // because number_1 is a "lazy" declaration.
  lazy val number_1:Int = { println("This line prints SECOND."); 111 }

  // The following line of code will execute upon its declaration
  // because number_2 is a regular (not lazy) declaration.
  val number_2:Int = { println("This line prints FIRST."); 222 }

  // A lazy declaration executes only when it's referenced the
  // first time.  The following line of code contains the first
  // reference to number_1, which forces the code associated
  // with the number_1 declaration to be executed.
  println(s"number_1 = $number_1")  // PRINTS: This line prints SECOND.
                                    //         number_1 = 111

  // The following line of code demonstrates the println statement
  // contained within the declarations of number_1 and number_2 will
  // no longer execute; because a declaration is executed only one
  // time, whether the declaration is lazy or not.
  println(s"number_1 = $number_1,  number_2 = $number_2")
  // PRINTS: number_1 = 111,  number_2 = 222
end main
=======================================================================

LazyList
========
Recall, the reason for using a lazy declaration instead of a regular
declaration has to do with memory and performance issues.  A lazy
declaration has the capability to store only the computed parts (the
results) of the collection in memory, instead of storing all elements
of the collection in memory, most of which could be empty.

A Scala lazy List can be declared using the "lazy" keyword, or by
declaring a LazyList, which is a Scala class.  For example...

lazy val intList_1:List[Int] = List(1, 2, 3)
val intList_2:LazyList[Int]  = LazyList(1, 2, 3)

intList_1 and intList_2 both represent a "lazy" List because their
declarations are not executed until the lists are referenced.  Either
declaration can be used.  The difference between the two declarations
is related to performance (memory usage and execution speed), which
isn't covered here.  Generally, if you want to use a "lazy" List, use
Scala's LazyList class instead of declaring a regular List as "lazy."

The reason for using a lazy declaration instead of a regular declaration
has to do with memory and performance issues.  A lazy declaration has
the capability to store only the computed parts (the results) of the
collection in memory, instead of the entire collection all its
elements, most of which could be empty.

The most common use for a lazy declaration is to represent a sequence
that is theoretically infinite, or finite but extremely large.  Since
the collection's elements are only computed when requested, you can
define an infinite series and then take only a finite portion of the
collection to work with.  The following code sample demonstrates using
a LazyList for this purpose.

import scala.collection.immutable.LazyList
@main def main():Unit =
  // Define an infinite Fibonacci sequence, assigning it to the val fibs.
  // Notice the val fibs appears on both sides of the equals sign (=).
  lazy val fibs:LazyList[BigInt] =
    BigInt(0) #:: BigInt(1) #:: fibs.zip(fibs.tail).map { case (a, b) => a + b }

  // Take the first 10 elements of fibs for evaluation...
  var tenFibs = fibs.take(10).toList
  println(tenFibs) // PRINTS:  List(0, 1, 1, 2, 3, 5, 8, 13, 21, 34)
end main
=======================================================================


LAZY LIST
=========
A LazyList generates/computes its elements not when it's declared/constructed,
but only when one or more of its elements is referenced at runtime.  (The following
code sample demonstrates this.)  This allows for efficient handling of large, or even
infinite, sequences.  This is the primary reason for using a LazyList instead of
a regular List.

The #:: operator is used to prepend a single element to an existing LazyList,
and is demonstrated in the following program.

===================================================================================
@main def main() =
  // *******************************************************************
  // This section demonstrates that a LazyList doesn't get computed when
  // it's constructed, as the following two println statements reveal.
  // NOTICE:  The Scala keyword "Nil" cannot be used with a LazyList.
  //          Instead, LazyList.empty is used, as shown here...
  val lazyList_1:LazyList[Int] = 1 #:: 2 #:: 3 #:: LazyList.empty
  println(s"lazyList_1 = $lazyList_1") // PRINTS: lazyList_1 = LazyList(<not computed>)

  val lazyList_2:LazyList[Int] = -1 #:: 0 #:: lazyList_1
  println(s"lazyList_2 = $lazyList_2") // PRINTS: lazyList_2 = LazyList(<not computed>)

  // *******************************************************************
  // This section demonstrates the contents of lazyList_2 are generated
  // (computed) only when its elements are referenced, as the following
  // two println statements reveal.
  for (x <- lazyList_2) print(s"x = $x, ") // PRINTS: x = -1, x = 0, x = 1, x = 2, x = 3,

  println(s"\nlazyList_2 = $lazyList_2") // PRINTS: lazyList_2 = LazyList(-1, 0, 1, 2, 3)
===================================================================================

The following program uses a LazyList and the recursive fibonacci() method
to compute fibonacci numbers.

===================================================================================
/**********************************************************
* This fibonacci() method is RECURSIVE
**********************************************************/
def fibonacci(a: BigInt, b: BigInt): LazyList[BigInt] =
  a #:: fibonacci(b, a + b)
end fibonacci

@main def main() =
  // The following call to take(11) constructs a LazyList of 11 elements.
  // The number passed to the take() method is what forces the recursive
  // fibonacci() method to terminate when it reaches the last element
  // of the LazyList.
  val fibonacciLazyList: LazyList[BigInt] = fibonacci(0, 1).take(11)

  // At this point fibonacciLazyList won't show the result because
  // that result doesn't get generated/computed until at least one
  // element of the LazyList is accessed.
  println(s"fibonacciLazyList = $fibonacciLazyList,  fibonacciLazyList.size = ${fibonacciLazyList.size}")
  // PRINTS: fibonacciLazyList = LazyList(<not computed>),  fibonacciLazyList.size = 11

  // Here we finally access elements of fibonacciLazyList;
  // which triggers the result to be generated/computed.
  for (x <- fibonacciLazyList) print(s"x = $x, ")
  // PRINTS: x = 0, x = 1, x = 1, x = 2, x = 3, x = 5, x = 8, x = 13, x = 21, x = 34, x = 55,

  // Convert the LazyList to a regular List.
  val listResult: List[BigInt] = fibonacciLazyList.toList
  println(s"\nlistResult = $listResult")
  // PRINTS: listResult = List(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55)
end main
===================================================================================
