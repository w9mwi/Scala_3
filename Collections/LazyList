LAZY EVALUATION
===============
Lazy evaluation means that the code associated with a lazy declaration
isn't executed when it's declared; it's executed only when the declared
val is referenced the first time.

To declare a val as 'lazy', you must prepend the Scala "lazy" keyword
to its declaration, as shown in the code sample below.

NOTE:  Only a Scala val (not a var) can be declared as 'lazy'.

       // The following line WON'T COMPILE because a var can't be declared as lazy.
       lazy var number:Int = 111

       // The following line WILL COMPILE because a val can be declared as lazy.
       lazy val number:Int = 111

When a val/var is declared without the 'lazy' keyword, the declaration is executed
immediately.  This is known as "EAGER EVALUATION" or "STRICT EVALUATION", which
applies to the vast majority of val/var declarations.

=======================================================================
@main def main():Unit =
  // The following line of code won't execute upon its declaration
  // because number_1 is a "lazy" declaration.
  lazy val number_1:Int = { println("This line prints SECOND."); 111 }

  // The following line of code will execute upon its declaration
  // because number_2 is a regular (not lazy) declaration.
  val number_2:Int = { println("This line prints FIRST."); 222 }

  // A lazy declaration executes only when it's referenced the
  // first time.  The following line of code contains the first
  // reference to number_1, which forces the code associated
  // with the number_1 declaration to be executed.
  println(s"number_1 = $number_1")  // PRINTS: This line prints SECOND.
                                    //         number_1 = 111

  // The following line of code demonstrates the println statement
  // contained within the declarations of number_1 and number_2 will
  // no longer execute; because a declaration is executed only one
  // time, whether the declaration is lazy or not.
  println(s"number_1 = $number_1,  number_2 = $number_2")
  // PRINTS: number_1 = 111,  number_2 = 222
end main
=======================================================================

LazyList
========
Scala contains a LazyList class that differs from the regular List class.
The reason to use a LazyList (instead of a regular List) has to do with
memory and performance issues.  A LazyList stores only the computed
elements of the list in memory, instead of storing all elements of the
list in memory.

The following three declarations demonstrate two different forms of lazy
evaluation.  The first form of lazy evaluation occurs by prepending the
'lazy' keyword to the "val intlist" declaration.  The second form of lazy
evaluation occurs when using a LazyList.

1)  lazy val intList:List[Int] = List(1, 2, 3)

    The val intList is declared 'lazy', which means means intList gets initialized
    not when it's declared, but only the first time intList is referenced.  Since
    intList points to a regular List (not a LazyList), there is no lazy evaluation
    performed on the List.

2)  val intlist:LazyList[Int] = LazyList(1, 2, 3)

    The val intList is not declared 'lazy', so intList gets initialized upon its
    declaration.  The elements of a LazyList are always 'lazy', so LazyList
    allocates memory for each element only the first time that element is
    referenced; instead of allocating memory for all its elements as a List does.

3)  lazy val intList:LazyList[Int] = LazyList(1, 2, 3)

    The val intList is declared 'lazy', which means means intList gets initialized
    not when it's declared, but only the first time intList is referenced.  The
    elements of a LazyList are always 'lazy', so LazyList allocates memory for
    each element only the first time that element is referenced; instead of
    allocating memory for all its elements as a List does.

NOTE: When declaring a LazyList, you should always prepend the 'lazy'
      keyword to the val, as shown in example 3) above.

The reason for using a LazyList instead of a List has to do with memory
and performance issues.  A LazyList allocates memory for each of its
elements only when the element is referenced; instead of allocating
memory for all its elements upon its declaration, as a List does.

NOTE: The following code sample uses the #:: operator, which prepends
      a single element to an existing LazyList.

=======================================================================
import scala.collection.immutable.LazyList

@main def main():Unit =
  // NOTES REGARDING THE FOLLOWING LINE OF CODE:
  // 1) It define an infinite Fibonacci sequence, and assigns
  //    it to the lazy val fibs.
  // 2) "fibs" appears on BOTH SIDES of the equals sign (=).
  //    The "lazy" keyword is what permits that behavior.
  //    That line of code won't compile if you remove the keyword lazy.
  // 3) The #:: operator prepends a single element to an existing LazyList.
  // 4) Removing the keyword case doesn't change behavior, so it's not required.
  lazy val fibs:LazyList[BigInt] =
    BigInt(0) #:: BigInt(1) #:: fibs.zip(fibs.tail).map { case (a, b) => a + b }
  println(fibs.take(10).toList) // PRINTS:  List(0, 1, 1, 2, 3, 5, 8, 13, 21, 34)

  // The following 2 lines of code obtain the same result as
  // the above 2 lines of code.  Here, the fibonacci numbers
  // are obtained via the RECURSIVE fibonacci method below.
  lazy val fibs2:LazyList[BigInt] = fibonacci(0, 1).take(10)
  println(fibs2.toList) // PRINTS:  List(0, 1, 1, 2, 3, 5, 8, 13, 21, 34)

  /**********************************************************
  * This fibonacci() method is RECURSIVE.
  **********************************************************/
  def fibonacci(a: BigInt, b: BigInt): LazyList[BigInt] =
    a #:: fibonacci(b, a + b)
  end fibonacci
end main
=======================================================================
