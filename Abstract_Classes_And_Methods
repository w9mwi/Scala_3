ABSTRACT METHODS AND MEMBERS
============================
An abstract method is a method that's defined, but contains no body
of executable code, which means it's not implemented.  An abstract
member is a val/var that's declared, but not initialized.  Abstract
methods and members can exist only in an abstract class, or in a trait.

Methods that contain a body of executable code are called concrete methods.
Members (vals/vars) that are initialized to some value are called concrete members.

Concrete methods and members can exist inside a regular class,
inside an abstract class, inside a trait, and inside of the
main() method.


ABSTRACT CLASS
==============
A Scala class can be written as an abstract class when the "abstract" keyword
precedes the "class" keyword, and it contains at least one method that's not
implemented, or at least one member that's not initialized.  The following
program shows an example of this.


abstract class Animal:
  def ageInYears:Int // ageInYears is an abstract method.
  val bodyTemp:Int   // bodyTemp is an abstract member.

// The following IrishSetter class inherits from the Animal class by
// implementing the "extends" keyword.  This class wouldn't compile
// if it didn't initialize bodyTemp to some value, or if it didn't
// implement the ageInYears method.
class IrishSetter(name: String) extends Animal:
  val bodyTemp = 93
  def ageInYears = 12
  // Every class has a default toString() method.  Here we override that
  // method with our own toString definition so it prints relevant info.
  override def toString = s"This Irish Setter is named $name; it's $ageInYears years old."

/******************
 * main()
 *****************/
@main def main():Unit =
  val dog = IrishSetter("Big Red")
  println(s"dog = $dog")
  // PRINTS:  dog = This Irish Setter is named Big Red; it's 12 years old.


Notice the numberOfLegs() method isn't implemented because it contains no body
of executable code, which is what makes it an abstract method.  The bodyTemp
member (which is a val) is declared but not initialized, which is what makes
it an abstract member.

Unlike a regular Scala class, an abstract class can't be instantiated.  An
abstract class can only be used by a regular class that inherits from it,
which is known as a superclass.


become can An abstract class is a Scala class  is written, and the "class" keyword An abstract class is defined when the "abstract" keyword precedes the "class" keyword.
An abstract class should be written only when both of these 3 conditions are met:

1) The class contains method(s) and/or member(s) that will be referenced by classes
   inheriting from it.
2) At least one of the class's methods/members will be implemented differently
   among the classes that inherit from it.

EXAMPLE:  Assume both class B and class C inherit from class A, and both class B and
          class C require a method having an identical name and argument signature,
          such as "run(Int, Int)".  However, class B and class C must implement
          their "run(Int, Int)" methods differently.

          To make this work, class A must be an abstract class, and class A must define
          a "run(Int, Int)" method that doesn't contain a body of executable code.
          Then, both class B and class C also need to define their own "run(Int, Int)"
          methods that do contain a body of executable code that implements the
          desired behavior.

The "protected" keyword is used
If methods contained in a base class should be invoked by the base class, or classes
that inherit from it,

   

When an abstract class is defined, it should contain only methods that don't apply to every class inheriting
from it should be defined, but left empty so they contain no body.





You want to write code where some part of what it does is not fully
              specified until it is used.  When a class is defined as abstract
              (using the "abstract" key word), it means that at least one of its
              members or methods must be overridden in a subclass.  When you want
              a class member or method that CAN'T be overridden in a subclass,
              use the "final" keyword.  You can also define an entire class using
              the "final" key word, which means that no subclass can modify it.
              The most common example of why you'd want to define a class as
              "final" is when you want that class to be immutable--so no subclass
              can modify it.
