This web page covers the Scala object, where "object" is a keyword.

Both a Scala class and Scala object are used to represent some "thing",
or some "entity".  When there can exist more than one of these things
(i.e., people, houses, automobiles), a Scala class is used.

A Scala object is often used as a "companion object."  A "companion
object" is an object that has an idential name to its "companion
class", and is located in the same file.

A Scala object accepts no arguments and can't be instantiated.  This is
because a Scala object represents a "singleton", which means it can
represent only one of something.  A Scala object is "lazy", which means
it gets created the first time it's referenced.  An object can extend
a class or a trait, but a class cannot extend an object.

A Scala object should be used...

1) To store constant values in a val.  So every instance of the companion
   class will reference the same value.

2) To store methods that will work with all instances of the companion class.

Remember, the Scala object should reside in the same file as its companion class.

Placing members and methods in a class's companion object (instead of in the
class itself) saves memory (and also time) because only one instance of the
value or method will get created--instead of creating a new member/method
every time the class is instantiated.

IMPORTANT: A companion class can access the private members of its companion object.
           A companion object can access the private members of its companion class.
           If you write your own apply() or unapply() methods for a regular class,
           those methods should reside in a companion object.  The apply() method 
           s used to as "factory method" to construct new instances of the object's
           companion class.  The unapply() method is used to deconstruct the object's
           companion class, so that class can be used with the "match" keyword for
           pattern matching.

All of the following topics are related to the Scala object,
and have a dedicated section below.

* Object
* Case Object



COMPANION OBJECT
================


The following program demonstrates a companion object.  The method named print()
is used to print the "name" and "age" values contained in the Person class.
Instead of defining that method in the Print class, the print() method is placed 
n the Person companion object.

NOTE: In the following program there is also a print() method in the Person class
      class, which invokes the print() method in the companion object.  Therefore,
      a new print() method actually does get created for every instance of a Person
      class.  However, the Person class print() method invokes the print() method
      in the Print object.  In this example there's not much savings in execution
      time or memory space because the print() method in the Person object contains
      only one line of code.  However, if the print() method in the Person object
     contained multiple lines of code, the savings in of memory could be substantial.

@main def main() =
  case class Person(name: String, age: Int):
    // The following print() method calls the print() method
    // located in the companion Person object.
    def print = Person.print(name, age)

  // This is the companion object to the Person class.
  object Person:
    def print(name: String, age: Int): Unit =
      println(s"name = $name, age = $age")

    def printPersonViaArgument(person: Person): Unit =
      println(s"name = ${person.name}, age = ${person.age}")

  val person = Person("Jack", 17)

  // The print() method defined in the class Person is
  // invoked via an instance of the Person class...
  person.print // PRINTS: name = Jack, age = 17

  // The printPersonViaArgument() method defined
  // in the Person object is invoked directly...
  Person.printPersonViaArgument(person.copy("Jane", 29)) // PRINTS: name = Jane, age = 29
