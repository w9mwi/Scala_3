This web page covers the Scala object, where "object" is a keyword.
A Scala object is often used as a "companion object" to a regular
Scala class that has an identical name.  A Scala object accepts no
arguments and can't be instantiated.  This is because a Scala object
represents a "singleton", which means it can represent only one of
something.  A Scala object should be used...

* To store constant values.  that is, vals that never change, and apply
  to all instances of its companion class.

* To store methods that can be invoked from all instances of the companion class.

Placing members and methods in a class's companion object (instead of in the
class itself) saves memory (and also time) because only on instance of the
value or method will get created.  Instead of creating a new member/method
every time the object's companion class is instantiated.




All of the following topics are related to the Scala object,
and have a dedicated section below.

* Object
* Case Object



Both a Scala class and a Scala object are used to represent some "thing",
or some "entity".  When there can exist more than one of these things
(i.e., people, houses, automobiles), a Scala class must be used.

When only one of something can exist (i.e., planet Earth, Empire
State Building), a Scala object should be used.  In other words,
a Scala object should always represent a singleton.

A Scala object cannot contain arguments and cannot be instantiated.
Once you define an object, it's available for use without having
to instantiate it.  A Scala object is "lazy", which means it gets
created the first time it's referenced.  An object can extend
a class or a trait, but a class cannot extend an object.

COMPANION OBJECT
================
When both a Scala object and a Scala class (or case class) have identical
names, and they're both contained in the same file, the object is called
a "companion object" to the class.  Conversely, the class is called a
"companion class" to the object.

A companion object should be used to contain methods and values that arenâ€™t
specific to the instance of the companion class.  In other words, values that
never change, and methods that work on all instances of a class, should be
placed in a companion object.  Doing so will prevent duplicate copies getting
created every time a new instance of the class is generated.  This will save
both memory and execution time, because only one instance of these methods and
values get created when they reside in a companion object.

IMPORTANT: A companion class can access the private members of its companion object.
           A companion object can access the private members of its companion class.
           apply() and unapply() methods should reside in a companion object.  Where
           the apply() method is used to as "factory method" to construct new
           instances of the object's companion class.  And the unapply() method is
           used to deconstruct the object's companion class, so that class can be
           used with the "match" keyword for pattern matching.

The following program demonstrates a companion object.  The method named print()
is used to print the "name" and "age" values contained in the Person class.
Instead of defining that method in the Print class, the print() method is placed 
n the Person companion object.

NOTE: In the following program there is also a print() method in the Person class
      class, which invokes the print() method in the companion object.  Therefore,
      a new print() method actually does get created for every instance of a Person
      class.  However, the Person class print() method invokes the print() method
      in the Print object.  In this example there's not much savings in execution
      time or memory space because the print() method in the Person object contains
      only one line of code.  However, if the print() method in the Person object
     contained multiple lines of code, the savings in of memory could be substantial.

@main def main() =
  case class Person(name: String, age: Int):
    // The following print() method calls the print() method
    // located in the companion Person object.
    def print = Person.print(name, age)

  // This is the companion object to the Person class.
  object Person:
    def print(name: String, age: Int): Unit =
      println(s"name = $name, age = $age")

    def printPersonViaArgument(person: Person): Unit =
      println(s"name = ${person.name}, age = ${person.age}")

  val person = Person("Jack", 17)

  // The print() method defined in the class Person is
  // invoked via an instance of the Person class...
  person.print // PRINTS: name = Jack, age = 17

  // The printPersonViaArgument() method defined
  // in the Person object is invoked directly...
  Person.printPersonViaArgument(person.copy("Jane", 29)) // PRINTS: name = Jane, age = 29
