This web page covers the following topics, all of which are related to
Scala methods and functions.  Each of these topics contains its own
section; each section (further below) is designated with a heading of
the same name.

* DIFFERENCE BETWEEN A METHOD AND A FUNCTION
* METHODS
* FUNCTIONS
* ETA EXPANSION
* ANONYMOUS FUNCTIONS
* NULLARY FUNCTIONS
* PARTIAL FUNCTIONS
* FUNCTIONS BUILT WITH ONLY CASE STATEMENTS


DIFFERENCE BETWEEN A METHOD AND A FUNCTION
==========================================
The words "method" and "function" are often used interchangeably as if
a method and a function are identical.  Generally, it doesn't matter
which terminology is used because it's usually not relevant.  However,
in Scala there are some important differences between a method and
a function that should be understood.

A method is always written using the "def" keyword.  The "def" keyword
is never used to write a function.  A function can only exist when it's
assigned to a val/var.  This makes it possible for multiple vals/vars to
store an identical function.  A method can never be assigned to a val/var.
A method can exist only in one place, where it's defined.

IMPORTANT:  Methods/Functions can accept any argument that resolves to a
            valid data type.  This includes the following:

               * Anything that is (or could be) stored in a val/var, including a function.
               * Literal values (including tuples), such as:
                 (-1.23, false), true,  'Z',  "Joe",  -987.654F,  Array(-123.4, 567.8)
               * An expression that resovles to a value, such as:
                 if (myInt > 3) then true else false  (Resolves to either true or false.)

            All functions have some data type.  (Function data types are explained in
            the FUNCTIONS section below.)  Therefore, methods/functions can accept
            arguments that reference a function.

            A method doesn't have a data type!  Therefore, a method can never be passed
            as an argument a method/function.

Interestingly, Scala allows you to pass a method as an argument to a method/function!
This appears to break the rule that says it's not allowed.  When you pass a method as
an argument to a method/function, the Scala compiler automatically transforms that
argument into a function, which is transparent to the programmer.  This is why you
don't need to distinguish methods from functions most of the time; because the
compiler often resolves those differences for you.

Transforming a method into a function is known as performing an "eta expansion" on
the method.  When you pass a method as an argument to a method/function, the Scala
compiler performs the "eta expansion" automatically.  However, the programmer can
perform an "eta expansion" on a method manually.  This allows you to transform
a method into a function, and then assign that function to a val/var.  This topic
is covered in more detail in the sections below.


METHODS
=======
Before reading this section read the above section titled:
DIFFERENCE BETWEEN A METHOD AND A FUNCTION

A Scala method is always written using the "def" keyword.

IMPORTANT: The "def" keyword can also be used to define an abstract value
           (a val/var that's declared, but not initialized), or to define
           an abstract method (a method that's declared, but has no body
           of executable code).  Abstract vals/vars, and abstract methods
           are used only in Scala traits and in Scala abstract classes.

In Scala 2 a method must be defined inside another construct, such as...

* abstract class
* class
* case class
* object
* case object
* trait

In Scala 3 a method can also be defined outside any of those constructs,
as a stand-alone method.  These methods are known as "top-level"
definitions because they're not nested within another definition.
In other words, methods in Scala 3 can be defined almost anywhere.

In Scala 3 the last line of a method definition can include the Scala 3
soft keyword "end" followed by the method name.  Adding this text to
the end of a method in Scala 3 is optional, but makes it easier to
see exactly where a method definition ends.

Below is a Scala 3 program that defines two stand-alone methods, and uses
the Scala 3 soft keyword "end" to designate the end of both methods.

------------------------------------------------------------------------------
def printName(name: String) =
  println(s"name is: $name")
end printName // This line is optional in Scala 3.
/*********************************************************
 * main()
 ********************************************************/
@main def main() =
  printName("Sally") // PRINTS: name is: Sally

  def squareMethod(number: Float): Float =
    number * number
  end squareMethod // This line is optional in Scala 3.

  println(s"squareMethod(123.456F) = ${squareMethod(123.456F)}")
  // PRINTS: squareMethod(123.456F) = 15241.384
------------------------------------------------------------------------------

Scala methods that contain no arguments can be written these 2 ways:

1) with empty parenthesis, like this:  def writeToFile():Unit = ...

   You should use empty parenthises when the method has side effects,
   like printing text to the screen, manipulating a file, etc.

2) with no parenthesis, like this:  def calculateDistance:Double = ...

   You should use no parenthises when the method has no side effects;
   like when it only calculates and returns a result.

This is just a suggestion/convention; it's not enforced.  Even if you
adhere to this convention, it doesn't mean other programmers will do
the same.  Don't assume that code you didn't write follows this convention.

Each argument in a method definition must declare its data type; i.e.,
Int, Boolean, List[Sting], etc.  For example, the squareMethod() below
declares its argument "number" as type Float.

  def squareMethod(number: Float): Float =
    number * number
  end squareMethod // This line is optional in Scala 3.

In Scala, you can define a method argument to accept another method.
When you define a method to accept another method as one of its arguments,
you must declare that argument as a "function data type".  A "function data
type" is always written using the rocket symbol (=>).  The following program
shows the processNumber() method has an argument named myFunction.  The
myFunction argument is declared to be of this type:

Int=>Int

The rocket symbol (=>) designates the argument is a function.
The left-side Int designates the function accepts one Int argument.
The right-side Int designates the function returns an Int value.

The following program demonstrates passing the function named "addTen"
as an argument to the processNumber() method.

------------------------------------------------------------------------------
@main def main() =
  def addTen(number: Int): Int =
    number + 10
  end addTen

  def processNumber(number:Int, myFunction:Int=>Int):Int =
    myFunction(number)
  end processNumber

  val result:Int = processNumber(123, addTen)
  println(s"processNumber(123, addTen) = $result") // PRINTS: processNumber(123, addTen) = 133
------------------------------------------------------------------------------

======================================================================
FUNCTIONS
=========
Before reading this section read the above section titled:
DIFFERENCE BETWEEN A METHOD AND A FUNCTION

======================================================================
ETA EXPANSION
=============
Before reading this section read the above section titled:
DIFFERENCE BETWEEN A METHOD AND A FUNCTION

The following program shows how to do the following:

1) Write a function, assign it to a val, and pass it to a method.

2) Write a method and pass it to another method.  When the method gets
   passed to the other method, it gets transformed into a function via
   an "eta expansion".

Read the in-line comments for details

------------------------------------------------------------------------------
/**************************************
* myMethod()
**************************************/
def myMethod(intArg:Int,
             functionArg:((Double, Double) => Double),
             methodArg:((Double, Double) => Double),
             booleanArg:Boolean,
             floatArrayArg:Array[Float]):String =
  s"intArg = $intArg\n" +
  // To invoke functionArg and methodArg, we call their apply() method.
  s"functionArg.apply(123.456, 654.321) = ${functionArg.apply(123.456D, 654.321D)}\n" +
  s"methodArg.apply(123.456D, 654.321D) = ${methodArg.apply(123.456D, 654.321D)}\n" +
  s"floatArrayArg = ${floatArrayArg.mkString(" ")}\n" +
  s"booleanArg = $booleanArg"

/**************************************
* addMethod()
**************************************/
def addMethod(x:Double, y:Double):Double = x + y

/**************************************
* main()
 **************************************/
@main def main() =
  val myInt: Int = 3

  // **************************************************************************
  // Here we demonstrate how to write a FUNCTION (NOT A METHOD), named
  // addFunction, assign it to a val, then pass it as an argument to
  // the method named myMethod(), which then invokes the function.
  //
  // The addFunction written here accepts 2 arguments (x and y) of type Double,
  // adds those 2 arguments, and returns a type Double.
  val addFunction:((Double, Double) => Double) =
    (x, y) => x + y
  // **************************************************************************

  val result:String = myMethod(myInt,  // Pass a val to myMethod.
                               // addFunction is already a function, so it gets passed to myMethod() unaltered.
                               addFunction, // Pass a function to myMethod.
                               // addMethod is a method, so it must be transformed into a function via an
                               // "eta expansion" before it's passed to myMethod.  Adding the underscore
                               // char (_) here performs the "eta expansion."  The underscore char (_)
                               // works in Scala 2 and Scala 3, but is no longer required in Scala 3.
                               addMethod _, // Pass an eta-expanded method to myMethod.
                               if (myInt > 3) then true else false, // This line resolves to a single Boolean value.
                               Array(9.87F, 6.54F, -3.21F))         // Pass a literal value to myMethod.
  
   println(s"$result") // PRINTS: intArg = 3
                       //         functionAdd.apply(123.456, 654.321) = 777.777
                       //         methodArg.apply(123.456D, 654.321D) = 777.777
                       //         floatArrayArg = 9.87 6.54 -3.21
                       //         booleanArg = false
------------------------------------------------------------------------------

def add10(x: Int): Int = x + 10

@main def main() =
  println("main() called.")
  val intList = List(1,2,3)
  val myFunction:(Int => Int) = add10
  var intListResult = intList.map(myFunction)
  println(s"intListResult = $intListResult") // PRINTS: intListResult = List(11, 12, 13)


======================================================================

======================================================================

======================================================================
PARTIAL FUNCTIONS
=================

IMPORTANT:  Don't confuse partial functions with partially-applied functions.
            Partial functions aren't related to partially-applied functions;
            the two are completely different.  Partially-applied functions
            are curried functions, which are covered in the "Currying" section.

A Scala partial function is a function that returns values for only a specific set of
values passed to its argument.  Because mathematics doesn't allow division by zero,
it could make sense to write a partial function to perform mathematical division;
where the partial function would return nothing when division by zero is attempted.

IMPORTANT: In Scala, partial functions are unary functions.  A unary function is
           a function that accepts only a single argument.  Therefore, you must
           always pass a single argument to invoke a partial function.  Partial
           functions in Scala implement this trait:

           PartialFunction[A, B]  // Where A is the argument type, and B the returned result type.

Because the PartialFunction trait is a value type, you can't define a partial function
using the "def" keyword.  As the "def" keyword in Scala is used to define methods,
not values.

The following program is self-explanatory.  Read in-line comments for details.
------------------------------------------------------------------------------

// As stated above, a partial function is always assigned to a val/var,
// and is never written using the "def" keyword.
val doubleOddNumbers: PartialFunction[Int, Int] =
  // NOTE: You can replace "number" below with any
  //       valid naming option you want.
  case number if (number % 2 == 1) => number * 2
end doubleOddNumbers

@main def main() =
  var intNumber: Int = 0 // Assign an EVEN number to intNumber.
  // The isDefinedAt() method is automatically generated by the
  // compiler for a partial function, and is used to determine
  // if the doubleOddNumbers() method should be invoked.
  if (doubleOddNumbers.isDefinedAt(intNumber))
  then // The following 2 lines DON'T execute.
     intNumber = doubleOddNumbers(intNumber)
     println(s"intResult = $intNumber")

  intNumber = 1 // Assign an ODD number to intNumber.
  if (doubleOddNumbers.isDefinedAt(intNumber))
  then // The following 2 lines DO execute.
    intNumber = doubleOddNumbers(intNumber)
    println(s"intResult = $intNumber") // PRINTS: intResult = 2

  // Some methods accept a partial function as an argument.
  // The collect() method below is like a "filter + map"
  // because it uses a PartialFunction to select elements
  // to which the function is applied.
  val intList:List[Int] = List(1, 2, 3).collect(doubleOddNumbers)
  println(s"intList = $intList") // PRINTS: intList = List(2, 6)

------------------------------------------------------------------------------

See the following web pages for more info. on partial functions.
https://docs.scala-lang.org/scala3/book/fun-partial-functions.html
https://www.scala-lang.org/files/archive/api/3.3.1/scala/PartialFunction.html#



======================================================================
======================================================================
======================================================================
======================================================================

