This web page covers the following topics, all of which are related to
Scala methods and functions.  Each of these topics contains its own
section; each section is designated with a heading of the same name.

* DIFFERENCE BETWEEN A METHOD AND A FUNCTION
* METHODS
* FUNCTIONS
* ETA EXPANSION
* ANONYMOUS FUNCTIONS
* NULLARY FUNCTIONS
* PARTIAL FUNCTIONS
* FUNCTIONS BUILT WITH ONLY CASE STATEMENTS


DIFFERENCE BETWEEN A METHOD AND A FUNCTION
==========================================
The words "method" and "function" are often used interchangeably as if
a method and a function are identical.  Generally, it doesn't matter
which terminology you use because it's often not relevant if some
code qualifies as a function or a method.  However, in Scala there are
some important differences between a method and a function that you
should understand.

A method is always written using the "def" keyword.  The "def" keyword
is never used to write a function. A function is always assigned to a
val/var, so mutiple copies of the function can exist.  A method can never
be assigned to a val/var.  A method exists only where it's defined.

A method can't be passed as an argument to another method or function.
Only functions can be passed as an argument to another function or
method.  Interestingly, Scala does allow you to pass a method as an
argument to another method/function!  This appears to break the rule
that says it's not allowed.  However, when you pass a method as an argument
to another method/function, the Scala compiler automatically transforms
the method into a function in the background, which is transparent to the
programmer.  Transforming a method into a function is accomplished by
performing an "eta expansion" on the method.

Although an "eta expansion" is done automatically by the compiler when
passing a method as an argument to another method/function, the programmer
can manually perform an "eta expansion" on a method, transforming it into
a function.  This allows you to assign your transformed method (which
becomes a function) to a val/var.  This is topic is covered in more detail
in the sections below.


METHODS
=======
A Scala method is always written using the "def" keyword.

IMPORTANT: The "def" keyword can also be used to define an abstract value
           (a val/var that's declared, but not initialized), or to define
           an abstract method (a method that's declared, but has no body
           of executable code).  Abstract vals/vars, and abstract methods
           are used only in Scala traits and in Scala abstract classes.

In Scala 2 a method must be defined inside another construct, such as...

* abstract class
* class
* case class
* object
* case object
* trait

In Scala 3 a method can also be defined outside any of those constructs,
as a stand-alone method.  These methods are known as "top-level"
definitions because they're not nested within another definition.
In other words, methods in Scala 3 can be defined almost anywhere.

In Scala 3 the last line of a method definition can include the Scala 3
soft keyword "end" followed by the method name.  Adding this text to
the end of a method in Scala 3 is optional, but makes it easier to
see exactly where a method definition ends.

Below is a Scala 3 program that defines two stand-alone methods, and uses
the Scala 3 soft keyword "end" to designate the end of both methods.

------------------------------------------------------------------------------
def printName(name: String) =
  println(s"name is: $name")
end printName // This line is optional in Scala 3.
/*********************************************************
 * main()
 ********************************************************/
@main def main() =
  printName("Sally") // PRINTS: name is: Sally

  def squareMethod(number: Float): Float =
    number * number
  end squareMethod // This line is optional in Scala 3.

  println(s"squareMethod(123.456F) = ${squareMethod(123.456F)}")
  // PRINTS: squareMethod(123.456F) = 15241.384
------------------------------------------------------------------------------

Scala methods that contain no arguments can be written these 2 ways:

1) with empty parenthesis, like this:  def writeToFile():Unit = ...

   You should use empty parenthises when the method has side effects,
   like printing text to the screen, manipulating a file, etc.

2) with no parenthesis, like this:  def calculateDistance:Double = ...

   You should use no parenthises when the method has no side effects;
   like when it only calculates and returns a result.

This is just a suggestion/convention; it's not enforced.  Even if you
adhere to this convention, it doesn't mean other programmers will do
the same.  Don't assume that code you didn't write follows this convention.

Each argument in a method definition must declare its data type; i.e.,
Int, Boolean, List[Sting], etc.  For example, the squareMethod() below
declares its argument "number" as type Float.

  def squareMethod(number: Float): Float =
    number * number
  end squareMethod // This line is optional in Scala 3.

In Scala, you can define a method argument to accept another method.
When you define a method to accept another method as one of its arguments,
you must declare that argument as a "function data type".  A "function data
type" is always written using the rocket symbol (=>).  The following program
shows the processNumber() method has an argument named myFunction.  The
myFunction argument is declared to be of this type:

Int=>Int

The rocket symbol (=>) designates the argument is a function.
The left-side Int designates the function accepts one Int argument.
The right-side Int designates the function returns an Int value.

The following program demonstrates passing the function named "addTen"
as an argument to the processNumber() method.

------------------------------------------------------------------------------
@main def main() =
  def addTen(number: Int): Int =
    number + 10
  end addTen

  def processNumber(number:Int, myFunction:Int=>Int):Int =
    myFunction(number)
  end processNumber

  val result:Int = processNumber(123, addTen)
  println(s"processNumber(123, addTen) = $result") // PRINTS: processNumber(123, addTen) = 133
------------------------------------------------------------------------------

======================================================================

======================================================================

======================================================================

======================================================================

======================================================================
PARTIAL FUNCTIONS
=================

IMPORTANT:  Don't confuse partial functions with partially-applied functions.
            Partial functions aren't related to partially-applied functions;
            the two are completely different.  Partially-applied functions
            are curried functions, which are covered in the "Currying" section.

A Scala partial function is a function that returns values for only a specific set of
values passed to its argument.  Because mathematics doesn't allow division by zero,
it could make sense to write a partial function to perform mathematical division;
where the partial function would return nothing when division by zero is attempted.

IMPORTANT: In Scala, partial functions are unary functions.  A unary function is
           a function that accepts only a single argument.  Therefore, you must
           always pass a single argument to invoke a partial function.  Partial
           functions in Scala implement this trait:

           PartialFunction[A, B]  // Where A is the argument type, and B the returned result type.

Because the PartialFunction trait is a value type, you can't define a partial function
using the "def" keyword.  As the "def" keyword in Scala is used to define methods,
not values.

The following program is self-explanatory.  Read in-line comments for details.
------------------------------------------------------------------------------

// As stated above, a partial function is always assigned to a val/var,
// and is never written using the "def" keyword.
val doubleOddNumbers: PartialFunction[Int, Int] =
  // NOTE: You can replace "number" below with any
  //       valid naming option you want.
  case number if (number % 2 == 1) => number * 2
end doubleOddNumbers

@main def main() =
  var intNumber: Int = 0 // Assign an EVEN number to intNumber.
  // The isDefinedAt() method is automatically generated by the
  // compiler for a partial function, and is used to determine
  // if the doubleOddNumbers() method should be invoked.
  if (doubleOddNumbers.isDefinedAt(intNumber))
  then // The following 2 lines DON'T execute.
     intNumber = doubleOddNumbers(intNumber)
     println(s"intResult = $intNumber")

  intNumber = 1 // Assign an ODD number to intNumber.
  if (doubleOddNumbers.isDefinedAt(intNumber))
  then // The following 2 lines DO execute.
    intNumber = doubleOddNumbers(intNumber)
    println(s"intResult = $intNumber") // PRINTS: intResult = 2

  // Some methods accept a partial function as an argument.
  // The collect() method below is like a "filter + map"
  // because it uses a PartialFunction to select elements
  // to which the function is applied.
  val intList:List[Int] = List(1, 2, 3).collect(doubleOddNumbers)
  println(s"intList = $intList") // PRINTS: intList = List(2, 6)

------------------------------------------------------------------------------

See the following web pages for more info. on partial functions.
https://docs.scala-lang.org/scala3/book/fun-partial-functions.html
https://www.scala-lang.org/files/archive/api/3.3.1/scala/PartialFunction.html#



======================================================================
======================================================================
======================================================================
======================================================================

