This web page covers the following topics, all of which are related to
Scala methods and functions.  Each of these topics contains its own
section; each section (further below) is designated with a heading of
the same name.

* METHODS VS. FUNCTIONS
* METHODS
* FUNCTIONS
* ETA EXPANSION
* ANONYMOUS FUNCTIONS
* NULLARY FUNCTIONS
* PARTIAL FUNCTIONS
* FUNCTIONS BUILT WITH ONLY CASE STATEMENTS


METHODS VS. FUNCTIONS
=====================
The words "method" and "function" are often used interchangeably as if
a method and a function are identical.  Generally, it doesn't matter
which terminology is used because it's usually not relevant.  However,
in Scala there are some important differences between a method and
a function that should be understood, and are described here.

   * A method is always written using the "def" keyword.
   * The "def" keyword is never used to write a function.
   * A function always has a data type, so functions can be assigned to a val/var.
   * A method never has a data type, so methods can't be assigned to a val/var.
   * A function can be passed to another method/function.
   * A method can't be passed to another method/function.  But a method can be
     transformed into a function by performing an "eta expansion" on it, so it
     can then be passed to another method/function.
   * In Scala there are two ways to write a function:

      1) You can write an "anonymous function" (also known as a "function literal").
         Anonymous functions get passed as arguments to methods/functions.  They're
         generally very short and simple.  In this example the anonymous function
         "x=>x*2" is passed as an argument to the List.map() method.

         var intList = List(1,2,3)
         intList = intList.map(x=>x*2)  // "x=>x*2" is an anonymous function.
         println(s"intList = $intList") // PRINTS: intList = List(2, 4, 6)

      2) You can write a function that is assigned to a val/var.  You can then
         invoke the function directly via the val/var name (as shown below).
         You can also pass that val/var as an argument to another method/function.
         Here's an example.

           // This function accepts 2 arguments (x and y) of type Double, adds
           // those 2 arguments, and returns a type Double.  The function is
           // assigned to val addFunction.  All vals/vars have a data type.
           // So the data type of addFunction is the data type of the function
           // it's assigned.  That data type is:  (Double, Double) => Double)
           //
           val addFunction:((Double, Double) => Double) = (x, y) => x + y
           val result:Double = addFunction(123.456D, 654.321D)
           println(s"result = $result") // PRINTS: result = 777.777



Interestingly, Scala allows you to pass a method as an argument to a method/function!
This appears to break the rule that says it's not allowed.  When you pass a method as
an argument to a method/function, the Scala compiler automatically transforms that
argument into a function, which is transparent to the programmer.  This is why you
don't need to distinguish methods from functions most of the time; because the
compiler often resolves those differences for you.

Transforming a method into a function is known as performing an "eta expansion" on
the method.  When you pass a method as an argument to a method/function, the Scala
compiler performs the "eta expansion" automatically.  However, the programmer can
perform an "eta expansion" on a method manually.  This allows you to transform
a method into a function, and then assign that function to a val/var.  This topic
is covered in more detail in the sections below.


METHODS
=======
Before reading this section read the above section titled:
METHODS VS. FUNCTIONS

A Scala method is always written using the "def" keyword.

IMPORTANT: The "def" keyword can also be used to define an abstract value
           (a val/var that's declared, but not initialized), or to define
           an abstract method (a method that's declared, but has no body
           of executable code).  Abstract vals/vars, and abstract methods
           are used only in Scala traits and in Scala abstract classes.

In Scala 2 a method must be defined inside another construct, such as...

* abstract class
* class
* case class
* object
* case object
* trait

In Scala 3 a method can also be defined outside any of those constructs,
as a stand-alone method.  These methods are known as "top-level"
definitions because they're not nested within another definition.
In other words, methods in Scala 3 can be defined almost anywhere.

In Scala 3 the last line of a method definition can include the Scala 3
soft keyword "end" followed by the method name.  Adding this text to
the end of a method in Scala 3 is optional, but makes it easier to
see exactly where a method definition ends.

Below is a Scala 3 program that defines two stand-alone methods, and uses
the Scala 3 soft keyword "end" to designate the end of both methods.

------------------------------------------------------------------------------
def printName(name: String) =
  println(s"name is: $name")
end printName // This line is optional in Scala 3.
/*********************************************************
 * main()
 ********************************************************/
@main def main() =
  printName("Sally") // PRINTS: name is: Sally

  def squareMethod(number: Float): Float =
    number * number
  end squareMethod // This line is optional in Scala 3.

  println(s"squareMethod(123.456F) = ${squareMethod(123.456F)}")
  // PRINTS: squareMethod(123.456F) = 15241.384
------------------------------------------------------------------------------

Scala methods that contain no arguments can be written these 2 ways:

1) with empty parenthesis, like this:  def writeToFile():Unit = ...

   You should use empty parenthises when the method has side effects,
   like printing text to the screen, manipulating a file, etc.

2) with no parenthesis, like this:  def calculateDistance:Double = ...

   You should use no parenthises when the method has no side effects;
   like when it only calculates and returns a result.

This is just a suggestion/convention; it's not enforced.  Even if you
adhere to this convention, it doesn't mean other programmers will do
the same.  Don't assume that code you didn't write follows this convention.

Each argument in a method definition must declare its data type; i.e.,
Int, Boolean, List[Sting], etc.  For example, the squareMethod() below
declares its argument "number" as type Float.

  def squareMethod(number: Float): Float =
    number * number
  end squareMethod // This line is optional in Scala 3.

In Scala, you can define a method argument to accept another method.
When you define a method to accept another method as one of its arguments,
you must declare that argument as a "function data type".  A "function data
type" is always written using the rocket symbol (=>).  The following program
shows the processNumber() method has an argument named myFunction.  The
myFunction argument is declared to be of this type:

Int=>Int

The rocket symbol (=>) designates the argument is a function.
The left-side Int designates the function accepts one Int argument.
The right-side Int designates the function returns an Int value.

The following program demonstrates passing the function named "addTen"
as an argument to the processNumber() method.

------------------------------------------------------------------------------
@main def main() =
  def addTen(number: Int): Int =
    number + 10
  end addTen

  def processNumber(number:Int, myFunction:Int=>Int):Int =
    myFunction(number)
  end processNumber

  val result:Int = processNumber(123, addTen)
  println(s"processNumber(123, addTen) = $result") // PRINTS: processNumber(123, addTen) = 133
------------------------------------------------------------------------------

======================================================================
FUNCTIONS
=========
Before reading this section read the above section titled:
METHODS VS. FUNCTIONS

======================================================================
ETA EXPANSION
=============
Before reading this section read the above section titled:
METHODS VS. FUNCTIONS

The following program shows how to do the following:

1) Write a function, assign it to a val named addFunction, then pass
   it to the myMethod method, which invokes the function.  When a
   function is passed to another method/function an eta expansion
   is NOT performed on it because it's already a function.

2) Write a method named addMethod and pass it to the myMethod method.
   When a method is passed to another method/function, an eta expansion
   MUST be performed on it to transform the method into a function.

Read the in-line comments for details

------------------------------------------------------------------------------
/**************************************
 * myMethod()
 **************************************/
def myMethod(functionArg:((Double, Double) => Double),
             methodArg:((Double, Double) => Double)):String =
  val x:Double = 123.456D
  val y:Double = 654.321D
  // Return the following String...
  s"functionArg($x, $y) = ${functionArg(x, y)}\n" +
  s"methodArg($x, $y)   = ${methodArg(x, y)}"

/**************************************
 * addMethod()
 **************************************/
def addMethod(x:Double, y:Double):Double = x + y

/**************************************
 * main()
 **************************************/
@main def main() =
  // **************************************************************************
  // Here we demonstrate how to write a FUNCTION (NOT A METHOD) and assign it
  // to a val named addFunction.  This function accepts 2 arguments (x and y)
  // of type Double, adds those 2 arguments, and returns a type Double.
  val addFunction:((Double, Double) => Double) =
    (x, y) => x + y
  // **************************************************************************

  // Call the myMethod method defined above.  Pass to it the addFunction
  // function and the addMethod method.  Then print the String that the
  // myMethod method returns.
  val result:String =
    myMethod(// addFunction is a function, so it gets passed to myMethod unaltered.
             addFunction,
             // addMethod is a method, so it must be transformed into a function via an
             // "eta expansion" before it's passed to myMethod.  Adding the underscore
             // char (_) here performs the "eta expansion."  The underscore char (_)
             // works in Scala 2 and Scala 3, but is no longer required in Scala 3.
             addMethod _)

  println(s"$result") // PRINTS: functionArg(123.456, 654.321) = 777.777
                      //         methodArg(123.456, 654.321)   = 777.777
------------------------------------------------------------------------------

def add10(x: Int): Int = x + 10

@main def main() =
  println("main() called.")
  val intList = List(1,2,3)
  val myFunction:(Int => Int) = add10
  var intListResult = intList.map(myFunction)
  println(s"intListResult = $intListResult") // PRINTS: intListResult = List(11, 12, 13)


======================================================================

======================================================================

======================================================================
PARTIAL FUNCTIONS
=================

IMPORTANT:  Don't confuse partial functions with partially-applied functions.
            Partial functions aren't related to partially-applied functions;
            the two are completely different.  Partially-applied functions
            are curried functions, which are covered in the "Currying" section.

A Scala partial function is a function that returns values for only a specific set of
values passed to its argument.  Because mathematics doesn't allow division by zero,
it could make sense to write a partial function to perform mathematical division;
where the partial function would return nothing when division by zero is attempted.

IMPORTANT: In Scala, partial functions are unary functions.  A unary function is
           a function that accepts only a single argument.  Therefore, you must
           always pass a single argument to invoke a partial function.  Partial
           functions in Scala implement this trait:

           PartialFunction[A, B]  // Where A is the argument type, and B the returned result type.

Because the PartialFunction trait is a value type, you can't define a partial function
using the "def" keyword.  As the "def" keyword in Scala is used to define methods,
not values.

The following program is self-explanatory.  Read in-line comments for details.
------------------------------------------------------------------------------

// As stated above, a partial function is always assigned to a val/var,
// and is never written using the "def" keyword.
val doubleOddNumbers: PartialFunction[Int, Int] =
  // NOTE: You can replace "number" below with any
  //       valid naming option you want.
  case number if (number % 2 == 1) => number * 2
end doubleOddNumbers

@main def main() =
  var intNumber: Int = 0 // Assign an EVEN number to intNumber.
  // The isDefinedAt() method is automatically generated by the
  // compiler for a partial function, and is used to determine
  // if the doubleOddNumbers() method should be invoked.
  if (doubleOddNumbers.isDefinedAt(intNumber))
  then // The following 2 lines DON'T execute.
     intNumber = doubleOddNumbers(intNumber)
     println(s"intResult = $intNumber")

  intNumber = 1 // Assign an ODD number to intNumber.
  if (doubleOddNumbers.isDefinedAt(intNumber))
  then // The following 2 lines DO execute.
    intNumber = doubleOddNumbers(intNumber)
    println(s"intResult = $intNumber") // PRINTS: intResult = 2

  // Some methods accept a partial function as an argument.
  // The collect() method below is like a "filter + map"
  // because it uses a PartialFunction to select elements
  // to which the function is applied.
  val intList:List[Int] = List(1, 2, 3).collect(doubleOddNumbers)
  println(s"intList = $intList") // PRINTS: intList = List(2, 6)

------------------------------------------------------------------------------

See the following web pages for more info. on partial functions.
https://docs.scala-lang.org/scala3/book/fun-partial-functions.html
https://www.scala-lang.org/files/archive/api/3.3.1/scala/PartialFunction.html#



======================================================================
======================================================================
======================================================================
======================================================================

