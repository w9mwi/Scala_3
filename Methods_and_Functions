This web page covers the following topics, all of which are related to
Scala methods and functions.  Each of these topics contains its own
section; each section (further below) is designated with a heading of
the same name.

* METHODS VS. FUNCTIONS
* METHODS
* FUNCTIONS
* ETA EXPANSION
* ANONYMOUS FUNCTIONS
* NULLARY FUNCTIONS
* PARTIAL FUNCTIONS
* FUNCTIONS BUILT WITH ONLY CASE STATEMENTS


METHODS VS. FUNCTIONS
=====================
The words "method" and "function" are often used interchangeably as if
a method and a function are identical.  Generally, it doesn't matter
which terminology is used because it's usually not relevant.  However,
in Scala there are some important differences between a method and
a function that should be understood, which are described here.

   * A method is always written using the "def" keyword.
   * The "def" keyword is never used to write a function.
   * A function is a value, so it has a data type, and can be assigned to a val/var.
   * A method isn't a value, so it has no data type, and can't be assigned to a val/var.
   * A function can be passed to another method/function.
   * A method can't be passed to another method/function.  But a method can be
     transformed into a function by performing an "eta expansion" on it, so it
     can then be passed to another method/function.
   * In Scala there are two ways to write a function:

      1) You can write an "anonymous function" (also known as a "function literal").
         Obviously, anonymous functions have no name.  Anonymous functions are often
         passed as arguments to methods/functions.  They're generally very short and
         simple.  In this example the anonymous function "x=>x*2" is passed as an
         argument to the List.map() method.

         var intList:List[Int] = List(1, 2, 3)
         intList = intList.map(x=>x*2)  // "x=>x*2" is an anonymous function.
         println(s"intList = $intList") // PRINTS: intList = List(2, 4, 6)

      2) You can write a function that is assigned to a val/var.  You can then
         invoke the function directly via the val/var name (as shown below).
         You can also pass that val/var as an argument to another method/function.

         NOTICE:  When you write a function that gets assigned to a val/var, the
                  function's executable code (which appears on the right-side
                  of the equals sign) would be an anonymous function if it stood
                  alone.  So you're effectively assigning an anonymous function
                  to a val/var. But since that function can be referenced via the
                  val/var name, it's no longer anonymous.

           // This function accepts 2 arguments (x and y) of type Double, adds
           // those 2 arguments, and returns a type Double.  The function is
           // assigned to val addFunction.  All vals/vars have a data type.
           // So the data type of addFunction is the data type of the function
           // it's assigned.  That data type is:  (Double, Double) => Double
           //
           val addFunction:((Double, Double) => Double) = (x, y) => x + y
           val result:Double = addFunction(123.456D, 654.321D)
           println(s"result = $result") // PRINTS: result = 777.777

As stated above, a method can't be passed to another method/function.  But a method
can be transformed into a function by performing an "eta expansion" on the method;
so it can then be passed to another method/function.  The following program shows
how to perform an "eta expansion" on the addMethod method, so it can be passed to
the myMethod method.

SUMMARY:  In most cases you'll write methods to obtain the functionality you need.
          And if you need a function (to assign to a val/var, or to pass it as an
          argument to a method/function), you can easily transform a method into
          a function via an "eta expansion", as is demonstrated in the following
          program.  So writing methods is far more common than writing functions.

------------------------------------------------------------------------------
// myMethod is a method that accepts a function as its argument.
def myMethod(addFunction:(Double, Double) => Double):Double=
  val x:Double = 123.456D
  val y:Double = 654.321D
  addFunction(x, y)
end myMethod // This line is optional in Scala 3

// addMethod is a method.
def addMethod(x:Double, y:Double):Double =
  x + y
end addMethod // This line is optional in Scala 3

// main()
@main def main() =
  // Here, we just confirm the addMethod method works.
  var result:Double = addMethod(123.456D, 654.321D)
  println(s"result = $result") // PRINTS:  result = 777.777

  // The following line of code passes the addMethod to myMethod as
  // an argument.  But as we stated above, you can't pass a method
  // to another method/function, unless it's first transformed into
  // a function.  The following line of code won't work in Scala 2,
  // but it works in Scala 3.  As Scala 3 automatically transforms
  // arguments that reference methods into functions.
  result = myMethod(addMethod) // This works only in Scala 3.
  println(s"result = $result") // PRINTS:  result = 777.777

  // The following line of code manually transforms the addMethod
  // argument into a function by performing an "eta expansion" on
  // it via the underscore operator (_).  So it works in both
  // Scala 2 and Scala 3.
  result = myMethod(addMethod _) // Works in Scala 2 and Scala 3.
  println(s"result = $result") // PRINTS:  result = 777.777

  // A function is a value, so it CAN be assigned to a val/var.
  // A method isn't a value, so it CAN'T be assigned to a val/var.
  // When you assign a method to a val/var, as in the following
  // line of code, both Scala 2 and Scala 3 will automatically
  // transform the method into a function.
  var function:(Double, Double) => Double = addMethod // Works in Scala 2 and Scala 3.
  result = myMethod(function)
  println(s"result = $result") // PRINTS:  result = 777.777

  // The following line of code manually performs an "eta expansion" on
  // addMethod via the underscore char (_).  The underscore char (_)
  // isn't needed here, it's optional.
  function = addMethod _ // Works in Scala 2 and Scala 3.
  result = myMethod(function)
  println(s"result = $result") // PRINTS:  result = 777.777
end main  // This line is optional in Scala 3
------------------------------------------------------------------------------


======================================================================
METHODS
=======
Before reading this section read the above section titled:
METHODS VS. FUNCTIONS

A Scala method is always written using the "def" keyword.

IMPORTANT: The "def" keyword can also be used to define an abstract value
           (a val/var that's declared, but not initialized), or to define
           an abstract method (a method that's declared, but has no body
           of executable code).  Abstract vals/vars, and abstract methods
           are used only in Scala traits and in Scala abstract classes.

In Scala 2 a method must be defined inside another construct, such as...

* abstract class
* class
* case class
* object
* case object
* trait

In Scala 3 a method can also be defined outside any of those constructs, as
a stand-alone method.  These methods are known as "top-level" definitions
because they're not nested within another definition.  In other words,
methods in Scala 3 can be defined almost anywhere.

In Scala 3 the last line of a method definition can include the Scala 3
soft keyword "end" followed by the method name.  Adding this text to
the end of a method in Scala 3 is optional, but makes it easier to
see exactly where a method definition ends.

Below is a Scala 3 program that defines two stand-alone methods, and uses
the Scala 3 soft keyword "end" to designate the end of both methods.

------------------------------------------------------------------------------
def printName(name: String) =
  println(s"name is: $name")
end printName // This line is optional in Scala 3.
/*********************************************************
 * main()
 ********************************************************/
@main def main() =
  printName("Sally") // PRINTS: name is: Sally

  def squareMethod(number: Float): Float =
    number * number
  end squareMethod // This line is optional in Scala 3.

  println(s"squareMethod(123.456F) = ${squareMethod(123.456F)}")
  // PRINTS: squareMethod(123.456F) = 15241.384
end main // This line is optional in Scala 3.
------------------------------------------------------------------------------

Scala methods that contain no arguments can be written these 2 ways:

1) with empty parenthesis, like this:  def writeToFile():Unit = ...

   You should use empty parenthises when the method has side effects,
   like printing text to the screen, manipulating a file, etc.

2) with no parenthesis, like this:  def calculateDistance:Double = ...

   You should use no parenthises when the method has no side effects;
   like when it only calculates and returns a result.

1) and 2) above are only suggestions; they're not enforced.  Even if you
adhere to this convention, it doesn't mean other programmers will do the
same.  Don't assume code you didn't write follows this convention.

======================================================================
FUNCTIONS
=========
Before reading this section read the above section titled:
METHODS VS. FUNCTIONS

When Scala compiles code that becomes a function, the function becomes
a Scala object named Function, which extends a trait corresponding
to the number of arguments the function accepts.  These are the
23 trait names that the object Function can extend:

Function0  (When the function accepts 0 arguments.)
Function1  (When the function accepts 1 arguments.)
Function2  (When the function accepts 2 arguments.)
...
Function22  (When the function accepts 22 arguments, which is the maximum limit.)

Unlike a method, the "def" keyword is never used when writing a function.
A val/var has a data type, and a function can be assigned to a val/var.
Therefore, all functions have a data type.  A function data type is always
specified using the "rocket symbol" (=>).  Here are some examples of
function data types.

   * ()=>Char                    (A function that accepts no arguments, and returns a Char.)
   * Int=>String                 (A function that accepts one Int argument, and returns a String.)
   * (Int,Char,Float)=>Boolean   (A function that accepts arguments Int, Char, Float, and returns a Boolean.)

A method, or a function, is a "higher-order function"
if one or both of the following is true.

   * It accepts at least one argument that's a function.
   * It returns a function.

------------------------------------------------------------------------------
@main def main() =
  // FUNCTIONS THAT ACCEPT NO ARGUMENTS.
  val getCurrentTime: () => Long    = () => System.currentTimeMillis()
  val getRandomNumber: () => Double = () => scala.util.Random.nextDouble()
  
  // FUNCTIONS THAT ACCEPT A SINGLE ARGUMENTS.
  val double: Int => Int       = x    => x * 2
  val isEven: Int => Boolean   = x    => x % 2 == 0
  val greet: String => String  = name => s"Hello, $name!"
  
  // FUNCTIONS THAT ACCEPT TWO ARGUMENTS.
  val add: (Int, Int) => Int                  = (a, b)   => a + b
  val multiply: (Double, Double) => Double    = (x, y)   => x * y
  val concatenate: (String, String) => String = (s1, s2) => s1 + s2
  
  // HIGHER-ORDER FUNCTIONS
  // NOTE:  A higher-order function is a method, or a function, that...
  //        * accepts at least one argument that's a function
  //           ...AND/OR...
  //        * returns a function
  val applyTwice: (Int => Int, Int)     => Int        = (f, x) => f(f(x))
  val compose: (Int => Int, Int => Int) => Int => Int = (f, g) => x => f(g(x))
end main
------------------------------------------------------------------------------

======================================================================
ETA EXPANSION
=============

An "eta expansion" transforms a Scala method into a Scala function.
In Scala 3 the compiler can perform this automatically, without any
programmer intervention.  However, an "eta expansion" can also be
perfomed manually by the programmer in Scala 3.

To perform an "eta expansion" in Scala 2 requires the programmer
to do it manually.

Read the "METHODS VS. FUNCTIONS" section above which explains this
topic.  It also contains a Scala program demonstrating how to perform
an "eta expansion" on a method automatically (in Scala 3) and manually.





======================================================================

======================================================================

======================================================================
PARTIAL FUNCTIONS
=================

IMPORTANT:  Don't confuse partial functions with partially-applied functions.
            Partial functions aren't related to partially-applied functions;
            the two are completely different.  Partially-applied functions
            are curried functions, which are covered in the "Currying" section.

A Scala partial function is a function that returns values for only a specific set of
values passed to its argument.  Because mathematics doesn't allow division by zero,
it could make sense to write a partial function to perform mathematical division;
where the partial function would return nothing when division by zero is attempted.

IMPORTANT: In Scala, partial functions are unary functions.  A unary function is
           a function that accepts only a single argument.  Therefore, you must
           always pass a single argument to invoke a partial function.  Partial
           functions in Scala implement this trait:

           PartialFunction[A, B]  // Where A is the argument type, and B the returned result type.

Because the PartialFunction trait is a value type, you can't define a partial function
using the "def" keyword.  As the "def" keyword in Scala is used to define methods,
not values.

The following program is self-explanatory.  Read in-line comments for details.
------------------------------------------------------------------------------

// As stated above, a partial function is always assigned to a val/var,
// and is never written using the "def" keyword.
val doubleOddNumbers: PartialFunction[Int, Int] =
  // NOTE: You can replace "number" below with any
  //       valid naming option you want.
  case number if (number % 2 == 1) => number * 2
end doubleOddNumbers

@main def main() =
  var intNumber: Int = 0 // Assign an EVEN number to intNumber.
  // The isDefinedAt() method is automatically generated by the
  // compiler for a partial function, and is used to determine
  // if the doubleOddNumbers() method should be invoked.
  if (doubleOddNumbers.isDefinedAt(intNumber))
  then // The following 2 lines DON'T execute.
     intNumber = doubleOddNumbers(intNumber)
     println(s"intResult = $intNumber")

  intNumber = 1 // Assign an ODD number to intNumber.
  if (doubleOddNumbers.isDefinedAt(intNumber))
  then // The following 2 lines DO execute.
    intNumber = doubleOddNumbers(intNumber)
    println(s"intResult = $intNumber") // PRINTS: intResult = 2

  // Some methods accept a partial function as an argument.
  // The collect() method below is like a "filter + map"
  // because it uses a PartialFunction to select elements
  // to which the function is applied.
  val intList:List[Int] = List(1, 2, 3).collect(doubleOddNumbers)
  println(s"intList = $intList") // PRINTS: intList = List(2, 6)

------------------------------------------------------------------------------

See the following web pages for more info. on partial functions.
https://docs.scala-lang.org/scala3/book/fun-partial-functions.html
https://www.scala-lang.org/files/archive/api/3.3.1/scala/PartialFunction.html#



======================================================================
======================================================================
======================================================================
======================================================================

